---
title: "Results Study 3: Personality Change Through Self-Improvement or Self-Acceptance"
author: "[blinded]"
toc: true
toc-depth: 5
toc-title: Contents
number-sections: true
execute:
  cache: true
format:
#  docx:
#    highlight-style: github
  html:
    link-external-icon: true
    link-external-newwindow: true
    code-block-bg: true
    code-block-border-left: "#31BAE9"
    embed-resources: true
#comments:
#  hypothesis: true
editor: source
#bibliography: references-zotero.bib
#csl: apa.csl
---
<!--
You can find the preregistration for Study 1 [here](https://osf.io/4syhg).
For Study 2 (separate script and results report), you can find the preregistration [here](https://osf.io/cdazs/?view_only=0ad7b53627c44510a99e8fda42af6502).
-->

## Load packages

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: false
library(renv)
library(tidyverse)
library(broom)
library(labelled)
library(psych)
library(GPArotation)
#library(devtools)
#install_github("cran/multicon") # not on CRAN atm
library(multicon)
library(correlation)
library(careless)
library(corrplot)
library(lavaan)
library(semTools)
library(semPlot)
library(knitr)
library(ggdist)
library(ggforce)
library(cowplot)
library(nortest)
library(lmerTest)
library(effectsize)
```

------------------------------------------------------------------------

## Data cleaning

```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: false
# source("clean_data_st3.R") 
# for data protection reasons, we provide the cleaned data sets here where potentially sensitive variables were dropped (see "clean_data_st3.R" for details)
base::load("data/df_sbsa3.rda")
```

Also need this list of the Big Five traits:
```{r}
#| echo: true
#| warning: false
#| output: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: false

### BFI-2 - Traits
b5t_extraversion = c("_01", "_06", "_11", "_16", "_21", "_26", 
                     "_31", "_36", "_41", "_46", "_51", "_56")
b5t_agreeableness = c("_02", "_07", "_12", "_17", "_22", "_27", 
                      "_32", "_37", "_42", "_47", "_52", "_57")
b5t_conscientiousness = c("_03", "_08", "_13", "_18", "_23", "_28", 
                          "_33", "_38", "_43", "_48", "_53", "_58")
b5t_neuroticism = c("_04", "_09", "_14", "_19", "_24", "_29", 
                    "_34", "_39", "_44", "_49", "_54", "_59")
b5t_openness = c("_05", "_10", "_15", "_20", "_25", "_30", 
                 "_35", "_40", "_45", "_50", "_55", "_60")
### BFI-2 - Facets
# facets of extraversion
b5f_sociability = c("_01", "_16", "_31", "_46") 
b5f_assertiveness = c("_06", "_21", "_36", "_51")
b5f_energy = c("_11", "_26", "_41", "_56")
# facets of agreeableness
b5f_compassion = c("_02", "_17", "_32", "_47")
b5f_respectfulness = c("_07", "_22", "_37", "_52")
b5f_trust = c("_12", "_27", "_42", "_57")
# facets of conscientiousness
b5f_organization = c("_03", "_18", "_33", "_48")
b5f_productiveness = c("_08", "_23", "_38", "_53")
b5f_responsibility = c("_13", "_28", "_43", "_58")
# facets of neuroticism
b5f_anxiety = c("_04", "_19", "_34", "_49")
b5f_depression = c("_09", "_24", "_39", "_54")
b5f_volatility = c("_14", "_29", "_44", "_59")
# facets of openness
b5f_curiosity = c("_10", "_25", "_40", "_55")
b5f_aesthetic = c("_05", "_20", "_35", "_50")
b5f_imagination = c("_15", "_30", "_45", "_60")

# add keys list (to indicate reverse scoring) - unfortunately this does not work (for the facets) automatically with psych function
keys_extraversion = c("+", "+", "-", "-", "+", "-", "-", "-", "+", "+", "-", "+")
keys_agreeableness = c("+", "+", "-", "-", "-", "+", "+", "-", "-", "-", "+", "+")
keys_conscientiousness = c("-", "-", "+", "+", "-", "-", "+", "+", "+", "-", "+", "-")
keys_neuroticism = c("-", "-", "+", "+", "-", "-", "+", "+", "-", "-", "+", "+")
keys_openness = c("-", "+", "+", "+", "-", "-", "+", "+", "-", "-", "-", "+")
# facets of extraversion
keys_sociability = c("+", "-", "-", "+") 
keys_assertiveness = c("+", "+", "-", "-")
keys_energy = c("-", "-", "+", "+")
# facets of agreeableness
keys_compassion = c("+", "-", "+", "-")
keys_respectfulness = c("+", "-", "-", "+")
keys_trust = c("-", "+", "-", "+")
# facets of conscientiousness
keys_organization = c("-", "+", "+", "-")
keys_productiveness = c("-", "-", "+", "+")
keys_responsibility = c("+", "-", "+", "-")
# facets of neuroticism
keys_anxiety = c("-", "+", "+", "-")
keys_depression = c("-", "-", "+", "+")
keys_volatility = c("+", "-", "-", "+")
# facets of openness
keys_curiosity = c("+", "-", "+", "-")
keys_aesthetic = c("-", "+", "+", "-")
keys_imagination = c("+", "-", "-", "+")

b5_vars <- list(list(b5t_extraversion, keys_extraversion), 
                list(b5t_agreeableness, keys_agreeableness), 
                list(b5t_conscientiousness, keys_conscientiousness), 
                list(b5t_neuroticism, keys_neuroticism), 
                list(b5t_openness, keys_openness),
                list(b5f_sociability, keys_sociability), 
                list(b5f_assertiveness, keys_assertiveness), 
                list(b5f_energy, keys_energy), 
                list(b5f_compassion, keys_compassion), 
                list(b5f_respectfulness, keys_respectfulness), 
                list(b5f_trust, keys_trust),
                list(b5f_organization, keys_organization), 
                list(b5f_productiveness, keys_productiveness), 
                list(b5f_responsibility, keys_responsibility),
                list(b5f_anxiety, keys_anxiety), 
                list(b5f_depression, keys_depression), 
                list(b5f_volatility, keys_volatility),
                list(b5f_curiosity, keys_curiosity), 
                list(b5f_aesthetic, keys_aesthetic), 
                list(b5f_imagination, keys_imagination))
names(b5_vars) = c("extraversion", "agreeableness", "conscientiousness", "neuroticism", "openness",
                   "sociability", "assertiveness", "energy", 
                   "compassion", "respectfulness", "trust",
                   "organization", "productiveness", "responsibility",
                   "anxiety", "depression", "volatility",
                   "curiosity", "aesthetic", "imagination")
```

------------------------------------------------------------------------

## Create item parcels

### Well-being measures

Reshape data
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

df_sbsa3_wide_wb <- df_sbsa3 %>% 
  arrange(pid, time) %>% 
  select(pid, time, group, starts_with(c("sw06", "ml01", "rs01", "sc01"))) %>% 
  pivot_wider(names_from = time,
              names_sep = "_t",
              values_from = starts_with(c("sw06", "ml01", "rs01", "sc01")))
# colnames(df_sbsa3_wide_wb)
```

#### Meaning in life

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false
cfa_meaning <- '
# Define the latent factors
meaning1 =~ NA*ml01_01_t1 + lambda1*ml01_01_t1 + lambda4*ml01_04_t1 + lambda5*ml01_05_t1 + lambda6*ml01_06_t1 + lambda9*ml01_09_t1

# Intercepts
ml01_01_t1 ~ i1*1
ml01_04_t1 ~ 1
ml01_05_t1 ~ 1
ml01_06_t1 ~ 1
ml01_09_t1 ~ 1

# Unique Variances
ml01_01_t1 ~~ ml01_01_t1
ml01_04_t1 ~~ ml01_04_t1
ml01_05_t1 ~~ ml01_05_t1
ml01_06_t1 ~~ ml01_06_t1
ml01_09_t1 ~~ ml01_09_t1

# Latent Variable Means
meaning1 ~ 0*1

# Latent Variable Variances and Covariance
meaning1 ~~ 1*meaning1
'
fit_cfa_meaning <- cfa(cfa_meaning, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_cfa_meaning, fit.measures = TRUE)
tidy(fit_cfa_meaning) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Fit is good (except for RMSEA, but close)! We don't need item parcels for meaning in life (5-item presence of meaning subscale).  

Also check search for meaning subscale:  
```{r}
#| echo: true
#| warning: false
cfa_search <- '
# Define the latent factors
search1 =~ NA*ml01_02_t1 + lambda1*ml01_02_t1 + lambda4*ml01_03_t1 + lambda5*ml01_07_t1 + lambda6*ml01_08_t1 + lambda9*ml01_10_t1

# Intercepts
ml01_02_t1 ~ i1*1
ml01_03_t1 ~ 1
ml01_07_t1 ~ 1
ml01_08_t1 ~ 1
ml01_10_t1 ~ 1

# Unique Variances
ml01_02_t1 ~~ ml01_02_t1
ml01_03_t1 ~~ ml01_03_t1
ml01_07_t1 ~~ ml01_07_t1
ml01_08_t1 ~~ ml01_08_t1
ml01_10_t1 ~~ ml01_10_t1

# Latent Variable Means
search1 ~ 0*1

# Latent Variable Variances and Covariance
search1 ~~ 1*search1
'
fit_cfa_search <- cfa(cfa_search, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_cfa_search, fit.measures = TRUE)
tidy(fit_cfa_search) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Also good fit (except for RMSEA again...).  

#### Self-esteem

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_selfes <- '
# Define the latent factors
selfes1 =~ NA*rs01_01_t1 + lambda1*rs01_01_t1 + lambda2*rs01_02_t1 + lambda3*rs01_03_t1 + lambda4*rs01_04_t1 + lambda5*rs01_05_t1 + lambda6*rs01_06_t1 + lambda7*rs01_07_t1 + lambda8*rs01_08_t1 + lambda9*rs01_09_t1 + lambda10*rs01_10_t1

# Intercepts
rs01_01_t1 ~ i1*1
rs01_02_t1 ~ 1
rs01_03_t1 ~ 1
rs01_04_t1 ~ 1
rs01_05_t1 ~ 1
rs01_06_t1 ~ 1
rs01_07_t1 ~ 1
rs01_08_t1 ~ 1
rs01_09_t1 ~ 1
rs01_10_t1 ~ 1

# Unique Variances
rs01_01_t1 ~~ rs01_01_t1
rs01_02_t1 ~~ rs01_02_t1
rs01_03_t1 ~~ rs01_03_t1
rs01_04_t1 ~~ rs01_04_t1
rs01_05_t1 ~~ rs01_05_t1
rs01_06_t1 ~~ rs01_06_t1
rs01_07_t1 ~~ rs01_07_t1
rs01_08_t1 ~~ rs01_08_t1
rs01_09_t1 ~~ rs01_09_t1
rs01_10_t1 ~~ rs01_10_t1

# Latent Variable Means
selfes1 ~ 0*1

# Latent Variable Variances and Covariance
selfes1 ~~ 1*selfes1
'
fit_cfa_selfes <- cfa(cfa_selfes, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_cfa_selfes, fit.measures = TRUE)
tidy(fit_cfa_selfes) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_wb <- df_sbsa3_wide_wb %>% 
  mutate(rs01_09_t1_r = rs01_09_t1,
         rs01_06_t1_r = rs01_06_t1,
         rs01_02_t1_r = rs01_02_t1,
         rs01_05_t1_r = rs01_05_t1,
         rs01_08_t1_r = rs01_08_t1,
         rs01_09_t2_r = rs01_09_t2,
         rs01_06_t2_r = rs01_06_t2,
         rs01_02_t2_r = rs01_02_t2,
         rs01_05_t2_r = rs01_05_t2,
         rs01_08_t2_r = rs01_08_t2) %>% 
  mutate(across(intersect(starts_with("rs01"), ends_with("_r")), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(selfes_par1_t1 = rowMeans(across(c(rs01_09_t1_r, rs01_01_t1, rs01_07_t1, rs01_03_t1)), na.rm=T),
         selfes_par2_t1 = rowMeans(across(c(rs01_06_t1_r, rs01_10_t1, rs01_04_t1)), na.rm=T),
         selfes_par3_t1 = rowMeans(across(c(rs01_02_t1_r, rs01_05_t1_r, rs01_08_t1_r)), na.rm=T),
         selfes_par1_t2 = rowMeans(across(c(rs01_09_t2_r, rs01_01_t2, rs01_07_t2, rs01_03_t2)), na.rm=T),
         selfes_par2_t2 = rowMeans(across(c(rs01_06_t2_r, rs01_10_t2, rs01_04_t2)), na.rm=T),
         selfes_par3_t2 = rowMeans(across(c(rs01_02_t2_r, rs01_05_t2_r, rs01_08_t2_r)), na.rm=T))
```

#### Self-concept clarity

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_concept <- '
# Define the latent factors
concept1 =~ NA*sc01_01_t1 + lambda1*sc01_01_t1 + lambda2*sc01_02_t1 + lambda3*sc01_03_t1 + lambda4*sc01_04_t1 + lambda5*sc01_05_t1 + lambda6*sc01_06_t1 + lambda7*sc01_07_t1 + lambda8*sc01_08_t1 + lambda9*sc01_09_t1 + lambda10*sc01_10_t1 + lambda11*sc01_11_t1 + lambda12*sc01_12_t1

# Intercepts
sc01_01_t1 ~ i1*1
sc01_02_t1 ~ 1
sc01_03_t1 ~ 1
sc01_04_t1 ~ 1
sc01_05_t1 ~ 1
sc01_06_t1 ~ 1
sc01_07_t1 ~ 1
sc01_08_t1 ~ 1
sc01_09_t1 ~ 1
sc01_10_t1 ~ 1
sc01_11_t1 ~ 1
sc01_12_t1 ~ 1

# Unique Variances
sc01_01_t1 ~~ sc01_01_t1
sc01_02_t1 ~~ sc01_02_t1
sc01_03_t1 ~~ sc01_03_t1
sc01_04_t1 ~~ sc01_04_t1
sc01_05_t1 ~~ sc01_05_t1
sc01_06_t1 ~~ sc01_06_t1
sc01_07_t1 ~~ sc01_07_t1
sc01_08_t1 ~~ sc01_08_t1
sc01_09_t1 ~~ sc01_09_t1
sc01_10_t1 ~~ sc01_10_t1
sc01_11_t1 ~~ sc01_11_t1
sc01_12_t1 ~~ sc01_12_t1

# Latent Variable Means
concept1 ~ 0*1

# Latent Variable Variances and Covariance
concept1 ~~ 1*concept1
'
fit_cfa_concept <- cfa(cfa_concept, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_cfa_concept, fit.measures = TRUE)
tidy(fit_cfa_concept) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_wb <- df_sbsa3_wide_wb %>% # based on the item content, it makes more sense here to recode all except sc01_11
  mutate(sc01_01_t1_r = sc01_01_t1,
         sc01_02_t1_r = sc01_02_t1,
         sc01_03_t1_r = sc01_03_t1,
         sc01_04_t1_r = sc01_04_t1,
         sc01_05_t1_r = sc01_05_t1,
         sc01_06_t1_r = sc01_06_t1,
         sc01_07_t1_r = sc01_07_t1,
         sc01_08_t1_r = sc01_08_t1,
         sc01_09_t1_r = sc01_09_t1,
         sc01_10_t1_r = sc01_10_t1,
         sc01_12_t1_r = sc01_12_t1,
         sc01_01_t2_r = sc01_01_t2,
         sc01_02_t2_r = sc01_02_t2,
         sc01_03_t2_r = sc01_03_t2,
         sc01_04_t2_r = sc01_04_t2,
         sc01_05_t2_r = sc01_05_t2,
         sc01_06_t2_r = sc01_06_t2,
         sc01_07_t2_r = sc01_07_t2,
         sc01_08_t2_r = sc01_08_t2,
         sc01_09_t2_r = sc01_09_t2,
         sc01_10_t2_r = sc01_10_t2,
         sc01_12_t2_r = sc01_12_t2) %>% 
  mutate(across(intersect(starts_with("sc01"), ends_with("_r")), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(concept_par1_t1 = rowMeans(across(c(sc01_04_t1_r, sc01_01_t1_r, sc01_05_t1_r, sc01_06_t1_r)), na.rm=T),
         concept_par2_t1 = rowMeans(across(c(sc01_02_t1_r, sc01_09_t1_r, sc01_10_t1_r, sc01_07_t1_r)), na.rm=T),
         concept_par3_t1 = rowMeans(across(c(sc01_03_t1_r, sc01_08_t1_r, sc01_12_t1_r, sc01_11_t1)), na.rm=T),
         concept_par1_t2 = rowMeans(across(c(sc01_04_t2_r, sc01_01_t2_r, sc01_05_t2_r, sc01_06_t2_r)), na.rm=T),
         concept_par2_t2 = rowMeans(across(c(sc01_02_t2_r, sc01_09_t2_r, sc01_10_t2_r, sc01_07_t2_r)), na.rm=T),
         concept_par3_t2 = rowMeans(across(c(sc01_03_t2_r, sc01_08_t2_r, sc01_12_t2_r, sc01_11_t2)), na.rm=T))

# replace NaN with regular NA
df_sbsa3_wide_wb <- df_sbsa3_wide_wb %>% 
  mutate_all(~ifelse(is.nan(.), NA, .))
```

### Big Five 
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

# all time points
df_sbsa3_wide_pers <- df_sbsa3 %>% 
  arrange(pid, time) %>% 
  select(pid, group, time, starts_with(c("bf05", "bf06"))) %>% 
  mutate(valid=1) %>% 
  pivot_wider(names_from = time,
              names_sep = "_t",
              values_from = c(valid, starts_with(c("bf05", "bf06"))))
# colnames(df_sbsa3_wide_pers)
```

#### Extraversion - current personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_extra_curr <- '
# Define the latent factors
extra_curr1 =~ NA*bf05_01_t1 + lambda1*bf05_01_t1 + lambda2*bf05_06_t1 + lambda3*bf05_11_t1 + lambda4*bf05_16_t1 + lambda5*bf05_21_t1 + lambda6*bf05_26_t1 + lambda7*bf05_31_t1 + lambda8*bf05_36_t1 + lambda9*bf05_41_t1 + lambda10*bf05_46_t1 + lambda11*bf05_51_t1 + lambda12*bf05_56_t1

# Intercepts
bf05_01_t1 ~ i1*1
bf05_06_t1 ~ 1
bf05_11_t1 ~ 1
bf05_16_t1 ~ 1
bf05_21_t1 ~ 1
bf05_26_t1 ~ 1
bf05_31_t1 ~ 1
bf05_36_t1 ~ 1
bf05_41_t1 ~ 1
bf05_46_t1 ~ 1
bf05_51_t1 ~ 1
bf05_56_t1 ~ 1

# Unique Variances
bf05_01_t1 ~~ bf05_01_t1
bf05_06_t1 ~~ bf05_06_t1
bf05_11_t1 ~~ bf05_11_t1
bf05_16_t1 ~~ bf05_16_t1
bf05_21_t1 ~~ bf05_21_t1
bf05_26_t1 ~~ bf05_26_t1
bf05_31_t1 ~~ bf05_31_t1
bf05_36_t1 ~~ bf05_36_t1
bf05_41_t1 ~~ bf05_41_t1
bf05_46_t1 ~~ bf05_46_t1
bf05_51_t1 ~~ bf05_51_t1
bf05_56_t1 ~~ bf05_56_t1

# Latent Variable Means
extra_curr1 ~ 0*1

# Latent Variable Variances and Covariance
extra_curr1 ~~ 1*extra_curr1
'
fit_cfa_extra_curr <- cfa(cfa_extra_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_cfa_extra_curr, fit.measures = TRUE)
tidy(fit_cfa_extra_curr) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf05_31_t1_r = bf05_31_t1,
         bf05_16_t1_r = bf05_16_t1,
         bf05_26_t1_r = bf05_26_t1,
         bf05_51_t1_r = bf05_51_t1,
         bf05_36_t1_r = bf05_36_t1,
         bf05_11_t1_r = bf05_11_t1,
         bf05_31_t2_r = bf05_31_t2,
         bf05_16_t2_r = bf05_16_t2,
         bf05_26_t2_r = bf05_26_t2,
         bf05_51_t2_r = bf05_51_t2,
         bf05_36_t2_r = bf05_36_t2,
         bf05_11_t2_r = bf05_11_t2) %>% 
  mutate(across(c(bf05_31_t1_r, bf05_16_t1_r, bf05_26_t1_r, bf05_51_t1_r, bf05_36_t1_r, bf05_11_t1_r, 
                  bf05_31_t2_r, bf05_16_t2_r, bf05_26_t2_r, bf05_51_t2_r, bf05_36_t2_r, bf05_11_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(extra_curr_par1_t1 = rowMeans(across(c(bf05_01_t1, bf05_41_t1, bf05_51_t1_r, bf05_11_t1_r)), na.rm=T),
         extra_curr_par2_t1 = rowMeans(across(c(bf05_46_t1, bf05_21_t1, bf05_26_t1_r, bf05_36_t1_r)), na.rm=T),
         extra_curr_par3_t1 = rowMeans(across(c(bf05_16_t1_r, bf05_31_t1_r, bf05_56_t1, bf05_06_t1)), na.rm=T),
         extra_curr_par1_t2 = rowMeans(across(c(bf05_01_t2, bf05_41_t2, bf05_51_t2_r, bf05_11_t2_r)), na.rm=T),
         extra_curr_par2_t2 = rowMeans(across(c(bf05_46_t2, bf05_21_t2, bf05_26_t2_r, bf05_36_t2_r)), na.rm=T),
         extra_curr_par3_t2 = rowMeans(across(c(bf05_16_t2_r, bf05_31_t2_r, bf05_56_t2, bf05_06_t2)), na.rm=T))
```

#### Extraversion - ideal personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_extra_ideal <- '
# Define the latent factors
extra_ideal1 =~ NA*bf06_01_t1 + lambda1*bf06_01_t1 + lambda2*bf06_06_t1 + lambda3*bf06_11_t1 + lambda4*bf06_16_t1 + lambda5*bf06_21_t1 + lambda6*bf06_26_t1 + lambda7*bf06_31_t1 + lambda8*bf06_36_t1 + lambda9*bf06_41_t1 + lambda10*bf06_46_t1 + lambda11*bf06_51_t1 + lambda12*bf06_56_t1

# Intercepts
bf06_01_t1 ~ i1*1
bf06_06_t1 ~ 1
bf06_11_t1 ~ 1
bf06_16_t1 ~ 1
bf06_21_t1 ~ 1
bf06_26_t1 ~ 1
bf06_31_t1 ~ 1
bf06_36_t1 ~ 1
bf06_41_t1 ~ 1
bf06_46_t1 ~ 1
bf06_51_t1 ~ 1
bf06_56_t1 ~ 1

# Unique Variances
bf06_01_t1 ~~ bf06_01_t1
bf06_06_t1 ~~ bf06_06_t1
bf06_11_t1 ~~ bf06_11_t1
bf06_16_t1 ~~ bf06_16_t1
bf06_21_t1 ~~ bf06_21_t1
bf06_26_t1 ~~ bf06_26_t1
bf06_31_t1 ~~ bf06_31_t1
bf06_36_t1 ~~ bf06_36_t1
bf06_41_t1 ~~ bf06_41_t1
bf06_46_t1 ~~ bf06_46_t1
bf06_51_t1 ~~ bf06_51_t1
bf06_56_t1 ~~ bf06_56_t1

# Latent Variable Means
extra_ideal1 ~ 0*1

# Latent Variable Variances and Covariance
extra_ideal1 ~~ 1*extra_ideal1
'
fit_cfa_extra_ideal <- cfa(cfa_extra_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                           mimic = "mplus", missing="ML")
summary(fit_cfa_extra_ideal, fit.measures = TRUE)
tidy(fit_cfa_extra_ideal) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf06_31_t1_r = bf06_31_t1,
         bf06_16_t1_r = bf06_16_t1,
         bf06_26_t1_r = bf06_26_t1,
         bf06_51_t1_r = bf06_51_t1,
         bf06_36_t1_r = bf06_36_t1,
         bf06_11_t1_r = bf06_11_t1,
         bf06_31_t2_r = bf06_31_t2,
         bf06_16_t2_r = bf06_16_t2,
         bf06_26_t2_r = bf06_26_t2,
         bf06_51_t2_r = bf06_51_t2,
         bf06_36_t2_r = bf06_36_t2,
         bf06_11_t2_r = bf06_11_t2) %>% 
  mutate(across(c(bf06_31_t1_r, bf06_16_t1_r, bf06_26_t1_r, bf06_51_t1_r, bf06_36_t1_r, bf06_11_t1_r, 
                  bf06_31_t2_r, bf06_16_t2_r, bf06_26_t2_r, bf06_51_t2_r, bf06_36_t2_r, bf06_11_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(extra_ideal_par1_t1 = rowMeans(across(c(bf06_31_t1_r, bf06_51_t1_r, bf06_46_t1, bf06_11_t1_r)), na.rm=T),
         extra_ideal_par2_t1 = rowMeans(across(c(bf06_16_t1_r, bf06_36_t1_r, bf06_26_t1_r, bf06_56_t1)), na.rm=T),
         extra_ideal_par3_t1 = rowMeans(across(c(bf06_01_t1, bf06_21_t1, bf06_41_t1, bf06_06_t1)), na.rm=T),
         extra_ideal_par1_t2 = rowMeans(across(c(bf06_31_t2_r, bf06_51_t2_r, bf06_46_t2, bf06_11_t2_r)), na.rm=T),
         extra_ideal_par2_t2 = rowMeans(across(c(bf06_16_t2_r, bf06_36_t2_r, bf06_26_t2_r, bf06_56_t2)), na.rm=T),
         extra_ideal_par3_t2 = rowMeans(across(c(bf06_01_t2, bf06_21_t2, bf06_41_t2, bf06_06_t2)), na.rm=T))
```

#### Agreeableness - current personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_agree_curr <- '
# Define the latent factors
agree_curr1 =~ NA*bf05_02_t1 + lambda1*bf05_02_t1 + lambda2*bf05_07_t1 + lambda3*bf05_12_t1 + lambda4*bf05_17_t1 + lambda5*bf05_22_t1 + lambda6*bf05_27_t1 + lambda7*bf05_32_t1 + lambda8*bf05_37_t1 + lambda9*bf05_42_t1 + lambda10*bf05_47_t1 + lambda11*bf05_52_t1 + lambda12*bf05_57_t1

# Intercepts
bf05_02_t1 ~ i1*1
bf05_07_t1 ~ 1
bf05_12_t1 ~ 1
bf05_17_t1 ~ 1
bf05_22_t1 ~ 1
bf05_27_t1 ~ 1
bf05_32_t1 ~ 1
bf05_37_t1 ~ 1
bf05_42_t1 ~ 1
bf05_47_t1 ~ 1
bf05_52_t1 ~ 1
bf05_57_t1 ~ 1

# Unique Variances
bf05_02_t1 ~~ bf05_02_t1
bf05_07_t1 ~~ bf05_07_t1
bf05_12_t1 ~~ bf05_12_t1
bf05_17_t1 ~~ bf05_17_t1
bf05_22_t1 ~~ bf05_22_t1
bf05_27_t1 ~~ bf05_27_t1
bf05_32_t1 ~~ bf05_32_t1
bf05_37_t1 ~~ bf05_37_t1
bf05_42_t1 ~~ bf05_42_t1
bf05_47_t1 ~~ bf05_47_t1
bf05_52_t1 ~~ bf05_52_t1
bf05_57_t1 ~~ bf05_57_t1

# Latent Variable Means
agree_curr1 ~ 0*1

# Latent Variable Variances and Covariance
agree_curr1 ~~ 1*agree_curr1
'
fit_cfa_agree_curr <- cfa(cfa_agree_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_cfa_agree_curr, fit.measures = TRUE)
tidy(fit_cfa_agree_curr) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf05_47_t1_r = bf05_47_t1,
         bf05_37_t1_r = bf05_37_t1,
         bf05_22_t1_r = bf05_22_t1,
         bf05_12_t1_r = bf05_12_t1,
         bf05_42_t1_r = bf05_42_t1,
         bf05_17_t1_r = bf05_17_t1,
         bf05_47_t2_r = bf05_47_t2,
         bf05_37_t2_r = bf05_37_t2,
         bf05_22_t2_r = bf05_22_t2,
         bf05_12_t2_r = bf05_12_t2,
         bf05_42_t2_r = bf05_42_t2,
         bf05_17_t2_r = bf05_17_t2) %>% 
  mutate(across(c(bf05_47_t1_r, bf05_37_t1_r, bf05_22_t1_r, bf05_12_t1_r, bf05_42_t1_r, bf05_17_t1_r, 
                  bf05_47_t2_r, bf05_37_t2_r, bf05_22_t2_r, bf05_12_t2_r, bf05_42_t2_r, bf05_17_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(agree_curr_par1_t1 = rowMeans(across(c(bf05_47_t1_r, bf05_22_t1_r, bf05_52_t1, bf05_17_t1_r)), na.rm=T),
         agree_curr_par2_t1 = rowMeans(across(c(bf05_37_t1_r, bf05_57_t1, bf05_02_t1, bf05_42_t1_r)), na.rm=T),
         agree_curr_par3_t1 = rowMeans(across(c(bf05_12_t1_r, bf05_27_t1, bf05_32_t1, bf05_07_t1)), na.rm=T),
         agree_curr_par1_t2 = rowMeans(across(c(bf05_47_t2_r, bf05_22_t2_r, bf05_52_t2, bf05_17_t2_r)), na.rm=T),
         agree_curr_par2_t2 = rowMeans(across(c(bf05_37_t2_r, bf05_57_t2, bf05_02_t2, bf05_42_t2_r)), na.rm=T),
         agree_curr_par3_t2 = rowMeans(across(c(bf05_12_t2_r, bf05_27_t2, bf05_32_t2, bf05_07_t2)), na.rm=T))
```

#### Agreeableness - ideal personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_agree_ideal <- '
# Define the latent factors
agree_ideal1 =~ NA*bf06_02_t1 + lambda1*bf06_02_t1 + lambda2*bf06_07_t1 + lambda3*bf06_12_t1 + lambda4*bf06_17_t1 + lambda5*bf06_22_t1 + lambda6*bf06_27_t1 + lambda7*bf06_32_t1 + lambda8*bf06_37_t1 + lambda9*bf06_42_t1 + lambda10*bf06_47_t1 + lambda11*bf06_52_t1 + lambda12*bf06_57_t1

# Intercepts
bf06_02_t1 ~ i1*1
bf06_07_t1 ~ 1
bf06_12_t1 ~ 1
bf06_17_t1 ~ 1
bf06_22_t1 ~ 1
bf06_27_t1 ~ 1
bf06_32_t1 ~ 1
bf06_37_t1 ~ 1
bf06_42_t1 ~ 1
bf06_47_t1 ~ 1
bf06_52_t1 ~ 1
bf06_57_t1 ~ 1

# Unique Variances
bf06_02_t1 ~~ bf06_02_t1
bf06_07_t1 ~~ bf06_07_t1
bf06_12_t1 ~~ bf06_12_t1
bf06_17_t1 ~~ bf06_17_t1
bf06_22_t1 ~~ bf06_22_t1
bf06_27_t1 ~~ bf06_27_t1
bf06_32_t1 ~~ bf06_32_t1
bf06_37_t1 ~~ bf06_37_t1
bf06_42_t1 ~~ bf06_42_t1
bf06_47_t1 ~~ bf06_47_t1
bf06_52_t1 ~~ bf06_52_t1
bf06_57_t1 ~~ bf06_57_t1

# Latent Variable Means
agree_ideal1 ~ 0*1

# Latent Variable Variances and Covariance
agree_ideal1 ~~ 1*agree_ideal1
'
fit_cfa_agree_ideal <- cfa(cfa_agree_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                           mimic = "mplus", missing="ML")
summary(fit_cfa_agree_ideal, fit.measures = TRUE)
tidy(fit_cfa_agree_ideal) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf06_47_t1_r = bf06_47_t1,
         bf06_37_t1_r = bf06_37_t1,
         bf06_22_t1_r = bf06_22_t1,
         bf06_12_t1_r = bf06_12_t1,
         bf06_42_t1_r = bf06_42_t1,
         bf06_17_t1_r = bf06_17_t1,
         bf06_47_t2_r = bf06_47_t2,
         bf06_37_t2_r = bf06_37_t2,
         bf06_22_t2_r = bf06_22_t2,
         bf06_12_t2_r = bf06_12_t2,
         bf06_42_t2_r = bf06_42_t2,
         bf06_17_t2_r = bf06_17_t2) %>% 
  mutate(across(c(bf06_47_t1_r, bf06_37_t1_r, bf06_22_t1_r, bf06_12_t1_r, bf06_42_t1_r, bf06_17_t1_r, 
                  bf06_47_t2_r, bf06_37_t2_r, bf06_22_t2_r, bf06_12_t2_r, bf06_42_t2_r, bf06_17_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(agree_ideal_par1_t1 = rowMeans(across(c(bf06_27_t1, bf06_02_t1, bf06_32_t1, bf06_17_t1_r)), na.rm=T),
         agree_ideal_par2_t1 = rowMeans(across(c(bf06_57_t1, bf06_37_t1_r, bf06_42_t1_r, bf06_07_t1)), na.rm=T),
         agree_ideal_par3_t1 = rowMeans(across(c(bf06_12_t1_r, bf06_47_t1_r, bf06_22_t1_r, bf06_52_t1)), na.rm=T),
         agree_ideal_par1_t2 = rowMeans(across(c(bf06_27_t2, bf06_02_t2, bf06_32_t2, bf06_17_t2_r)), na.rm=T),
         agree_ideal_par2_t2 = rowMeans(across(c(bf06_57_t2, bf06_37_t2_r, bf06_42_t2_r, bf06_07_t2)), na.rm=T),
         agree_ideal_par3_t2 = rowMeans(across(c(bf06_12_t2_r, bf06_47_t2_r, bf06_22_t2_r, bf06_52_t2)), na.rm=T))
```

#### Conscientiousness - current personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_consc_curr <- '
# Define the latent factors
consc_curr1 =~ NA*bf05_03_t1 + lambda1*bf05_03_t1 + lambda2*bf05_08_t1 + lambda3*bf05_13_t1 + lambda4*bf05_18_t1 + lambda5*bf05_23_t1 + lambda6*bf05_28_t1 + lambda7*bf05_33_t1 + lambda8*bf05_38_t1 + lambda9*bf05_43_t1 + lambda10*bf05_48_t1 + lambda11*bf05_53_t1 + lambda12*bf05_58_t1
# Intercepts
bf05_03_t1 ~ i1*1
bf05_08_t1 ~ 1
bf05_13_t1 ~ 1
bf05_18_t1 ~ 1
bf05_23_t1 ~ 1
bf05_28_t1 ~ 1
bf05_33_t1 ~ 1
bf05_38_t1 ~ 1
bf05_43_t1 ~ 1
bf05_48_t1 ~ 1
bf05_53_t1 ~ 1
bf05_58_t1 ~ 1

# Unique Variances
bf05_03_t1 ~~ bf05_03_t1
bf05_08_t1 ~~ bf05_08_t1
bf05_13_t1 ~~ bf05_13_t1
bf05_18_t1 ~~ bf05_18_t1
bf05_23_t1 ~~ bf05_23_t1
bf05_28_t1 ~~ bf05_28_t1
bf05_33_t1 ~~ bf05_33_t1
bf05_38_t1 ~~ bf05_38_t1
bf05_43_t1 ~~ bf05_43_t1
bf05_48_t1 ~~ bf05_48_t1
bf05_53_t1 ~~ bf05_53_t1
bf05_58_t1 ~~ bf05_58_t1

# Latent Variable Means
consc_curr1 ~ 0*1

# Latent Variable Variances and Covariance
consc_curr1 ~~ 1*consc_curr1
'
fit_cfa_consc_curr <- cfa(cfa_consc_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_cfa_consc_curr, fit.measures = TRUE)
tidy(fit_cfa_consc_curr) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf05_03_t1_r = bf05_03_t1,
         bf05_23_t1_r = bf05_23_t1,
         bf05_48_t1_r = bf05_48_t1,
         bf05_08_t1_r = bf05_08_t1,
         bf05_28_t1_r = bf05_28_t1,
         bf05_58_t1_r = bf05_58_t1,
         bf05_03_t2_r = bf05_03_t2,
         bf05_23_t2_r = bf05_23_t2,
         bf05_48_t2_r = bf05_48_t2,
         bf05_08_t2_r = bf05_08_t2,
         bf05_28_t2_r = bf05_28_t2,
         bf05_58_t2_r = bf05_58_t2) %>% 
  mutate(across(c(bf05_03_t1_r, bf05_23_t1_r, bf05_48_t1_r, bf05_08_t1_r, bf05_28_t1_r, bf05_58_t1_r,
                  bf05_03_t2_r, bf05_23_t2_r, bf05_48_t2_r, bf05_08_t2_r, bf05_28_t2_r, bf05_58_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(consc_curr_par1_t1 = rowMeans(across(c(bf05_03_t1_r, bf05_08_t1_r, bf05_58_t1_r, bf05_13_t1)), na.rm=T),
         consc_curr_par2_t1 = rowMeans(across(c(bf05_33_t1, bf05_23_t1_r, bf05_53_t1, bf05_43_t1)), na.rm=T),
         consc_curr_par3_t1 = rowMeans(across(c(bf05_18_t1, bf05_48_t1_r, bf05_28_t1_r, bf05_38_t1)), na.rm=T),
         consc_curr_par1_t2 = rowMeans(across(c(bf05_03_t2_r, bf05_08_t2_r, bf05_58_t2_r, bf05_13_t2)), na.rm=T),
         consc_curr_par2_t2 = rowMeans(across(c(bf05_33_t2, bf05_23_t2_r, bf05_53_t2, bf05_43_t2)), na.rm=T),
         consc_curr_par3_t2 = rowMeans(across(c(bf05_18_t2, bf05_48_t2_r, bf05_28_t2_r, bf05_38_t2)), na.rm=T))
```

#### Conscientiousness - ideal personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_consc_ideal <- '
# Define the latent factors
consc_ideal1 =~ NA*bf06_03_t1 + lambda1*bf06_03_t1 + lambda2*bf06_08_t1 + lambda3*bf06_13_t1 + lambda4*bf06_18_t1 + lambda5*bf06_23_t1 + lambda6*bf06_28_t1 + lambda7*bf06_33_t1 + lambda8*bf06_38_t1 + lambda9*bf06_43_t1 + lambda10*bf06_48_t1 + lambda11*bf06_53_t1 + lambda12*bf06_58_t1
# Intercepts
bf06_03_t1 ~ i1*1
bf06_08_t1 ~ 1
bf06_13_t1 ~ 1
bf06_18_t1 ~ 1
bf06_23_t1 ~ 1
bf06_28_t1 ~ 1
bf06_33_t1 ~ 1
bf06_38_t1 ~ 1
bf06_43_t1 ~ 1
bf06_48_t1 ~ 1
bf06_53_t1 ~ 1
bf06_58_t1 ~ 1

# Unique Variances
bf06_03_t1 ~~ bf06_03_t1
bf06_08_t1 ~~ bf06_08_t1
bf06_13_t1 ~~ bf06_13_t1
bf06_18_t1 ~~ bf06_18_t1
bf06_23_t1 ~~ bf06_23_t1
bf06_28_t1 ~~ bf06_28_t1
bf06_33_t1 ~~ bf06_33_t1
bf06_38_t1 ~~ bf06_38_t1
bf06_43_t1 ~~ bf06_43_t1
bf06_48_t1 ~~ bf06_48_t1
bf06_53_t1 ~~ bf06_53_t1
bf06_58_t1 ~~ bf06_58_t1

# Latent Variable Means
consc_ideal1 ~ 0*1

# Latent Variable Variances and Covariance
consc_ideal1 ~~ 1*consc_ideal1
'
fit_cfa_consc_ideal <- cfa(cfa_consc_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                           mimic = "mplus", missing="ML")
summary(fit_cfa_consc_ideal, fit.measures = TRUE)
tidy(fit_cfa_consc_ideal) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf06_03_t1_r = bf06_03_t1,
         bf06_23_t1_r = bf06_23_t1,
         bf06_48_t1_r = bf06_48_t1,
         bf06_08_t1_r = bf06_08_t1,
         bf06_28_t1_r = bf06_28_t1,
         bf06_58_t1_r = bf06_58_t1,
         bf06_03_t2_r = bf06_03_t2,
         bf06_23_t2_r = bf06_23_t2,
         bf06_48_t2_r = bf06_48_t2,
         bf06_08_t2_r = bf06_08_t2,
         bf06_28_t2_r = bf06_28_t2,
         bf06_58_t2_r = bf06_58_t2) %>% 
  mutate(across(c(bf06_03_t1_r, bf06_23_t1_r, bf06_48_t1_r, bf06_08_t1_r, bf06_28_t1_r, bf06_58_t1_r,
                  bf06_03_t2_r, bf06_23_t2_r, bf06_48_t2_r, bf06_08_t2_r, bf06_28_t2_r, bf06_58_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(consc_ideal_par1_t1 = rowMeans(across(c(bf06_48_t1_r, bf06_08_t1_r, bf06_33_t1, bf06_13_t1)), na.rm=T),
         consc_ideal_par2_t1 = rowMeans(across(c(bf06_23_t1_r, bf06_03_t1_r, bf06_38_t1, bf06_43_t1)), na.rm=T),
         consc_ideal_par3_t1 = rowMeans(across(c(bf06_53_t1, bf06_28_t1_r, bf06_58_t1_r, bf06_18_t1)), na.rm=T),
         consc_ideal_par1_t2 = rowMeans(across(c(bf06_48_t2_r, bf06_08_t2_r, bf06_33_t2, bf06_13_t2)), na.rm=T),
         consc_ideal_par2_t2 = rowMeans(across(c(bf06_23_t2_r, bf06_03_t2_r, bf06_38_t2, bf06_43_t2)), na.rm=T),
         consc_ideal_par3_t2 = rowMeans(across(c(bf06_53_t2, bf06_28_t2_r, bf06_58_t2_r, bf06_18_t2)), na.rm=T))
```

#### Neuroticism - current personality

Check CFA item loadings at T1
```{r}
#| echo: true
cfa_neuro_curr <- '
#| warning: false

# Define the latent factors
neuro_curr1 =~ NA*bf05_04_t1 + lambda1*bf05_04_t1 + lambda2*bf05_09_t1 + lambda3*bf05_14_t1 + lambda4*bf05_19_t1 + lambda5*bf05_24_t1 + lambda6*bf05_29_t1 + lambda7*bf05_34_t1 + lambda8*bf05_39_t1 + lambda9*bf05_44_t1 + lambda10*bf05_49_t1 + lambda11*bf05_54_t1 + lambda12*bf05_59_t1

# Intercepts
bf05_04_t1 ~ i1*1
bf05_09_t1 ~ 1
bf05_14_t1 ~ 1
bf05_19_t1 ~ 1
bf05_24_t1 ~ 1
bf05_29_t1 ~ 1
bf05_34_t1 ~ 1
bf05_39_t1 ~ 1
bf05_44_t1 ~ 1
bf05_49_t1 ~ 1
bf05_54_t1 ~ 1
bf05_59_t1 ~ 1

# Unique Variances
bf05_04_t1 ~~ bf05_04_t1
bf05_09_t1 ~~ bf05_09_t1
bf05_14_t1 ~~ bf05_14_t1
bf05_19_t1 ~~ bf05_19_t1
bf05_24_t1 ~~ bf05_24_t1
bf05_29_t1 ~~ bf05_29_t1
bf05_34_t1 ~~ bf05_34_t1
bf05_39_t1 ~~ bf05_39_t1
bf05_44_t1 ~~ bf05_44_t1
bf05_49_t1 ~~ bf05_49_t1
bf05_54_t1 ~~ bf05_54_t1
bf05_59_t1 ~~ bf05_59_t1

# Latent Variable Means
neuro_curr1 ~ 0*1

# Latent Variable Variances and Covariance
neuro_curr1 ~~ 1*neuro_curr1
'
fit_cfa_neuro_curr <- cfa(cfa_neuro_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_cfa_neuro_curr, fit.measures = TRUE)
tidy(fit_cfa_neuro_curr) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf05_29_t1_r = bf05_29_t1,
         bf05_04_t1_r = bf05_04_t1,
         bf05_24_t1_r = bf05_24_t1,
         bf05_44_t1_r = bf05_44_t1,
         bf05_09_t1_r = bf05_09_t1,
         bf05_49_t1_r = bf05_49_t1,
         bf05_29_t2_r = bf05_29_t2,
         bf05_04_t2_r = bf05_04_t2,
         bf05_24_t2_r = bf05_24_t2,
         bf05_44_t2_r = bf05_44_t2,
         bf05_09_t2_r = bf05_09_t2,
         bf05_49_t2_r = bf05_49_t2) %>% 
  mutate(across(c(bf05_29_t1_r, bf05_04_t1_r, bf05_24_t1_r, bf05_44_t1_r, bf05_09_t1_r, bf05_49_t1_r, 
                  bf05_29_t2_r, bf05_04_t2_r, bf05_24_t2_r, bf05_44_t2_r, bf05_09_t2_r, bf05_49_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(neuro_curr_par1_t1 = rowMeans(across(c(bf05_29_t1_r, bf05_14_t1, bf05_09_t1_r, bf05_19_t1)), na.rm=T),
         neuro_curr_par2_t1 = rowMeans(across(c(bf05_54_t1, bf05_34_t1, bf05_44_t1_r, bf05_49_t1_r)), na.rm=T),
         neuro_curr_par3_t1 = rowMeans(across(c(bf05_39_t1, bf05_04_t1_r, bf05_59_t1, bf05_24_t1_r)), na.rm=T),
         neuro_curr_par1_t2 = rowMeans(across(c(bf05_29_t2_r, bf05_14_t2, bf05_09_t2_r, bf05_19_t2)), na.rm=T),
         neuro_curr_par2_t2 = rowMeans(across(c(bf05_54_t2, bf05_34_t2, bf05_44_t2_r, bf05_49_t2_r)), na.rm=T),
         neuro_curr_par3_t2 = rowMeans(across(c(bf05_39_t2, bf05_04_t2_r, bf05_59_t2, bf05_24_t2_r)), na.rm=T))
```

#### Neuroticism - ideal personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_neuro_ideal <- '
# Define the latent factors
neuro_ideal1 =~ NA*bf06_04_t1 + lambda1*bf06_04_t1 + lambda2*bf06_09_t1 + lambda3*bf06_14_t1 + lambda4*bf06_19_t1 + lambda5*bf06_24_t1 + lambda6*bf06_29_t1 + lambda7*bf06_34_t1 + lambda8*bf06_39_t1 + lambda9*bf06_44_t1 + lambda10*bf06_49_t1 + lambda11*bf06_54_t1 + lambda12*bf06_59_t1

# Intercepts
bf06_04_t1 ~ i1*1
bf06_09_t1 ~ 1
bf06_14_t1 ~ 1
bf06_19_t1 ~ 1
bf06_24_t1 ~ 1
bf06_29_t1 ~ 1
bf06_34_t1 ~ 1
bf06_39_t1 ~ 1
bf06_44_t1 ~ 1
bf06_49_t1 ~ 1
bf06_54_t1 ~ 1
bf06_59_t1 ~ 1

# Unique Variances
bf06_04_t1 ~~ bf06_04_t1
bf06_09_t1 ~~ bf06_09_t1
bf06_14_t1 ~~ bf06_14_t1
bf06_19_t1 ~~ bf06_19_t1
bf06_24_t1 ~~ bf06_24_t1
bf06_29_t1 ~~ bf06_29_t1
bf06_34_t1 ~~ bf06_34_t1
bf06_39_t1 ~~ bf06_39_t1
bf06_44_t1 ~~ bf06_44_t1
bf06_49_t1 ~~ bf06_49_t1
bf06_54_t1 ~~ bf06_54_t1
bf06_59_t1 ~~ bf06_59_t1

# Latent Variable Means
neuro_ideal1 ~ 0*1

# Latent Variable Variances and Covariance
neuro_ideal1 ~~ 1*neuro_ideal1
'
fit_cfa_neuro_ideal <- cfa(cfa_neuro_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                           mimic = "mplus", missing="ML")
summary(fit_cfa_neuro_ideal, fit.measures = TRUE)
tidy(fit_cfa_neuro_ideal) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf06_29_t1_r = bf06_29_t1,
         bf06_04_t1_r = bf06_04_t1,
         bf06_24_t1_r = bf06_24_t1,
         bf06_44_t1_r = bf06_44_t1,
         bf06_09_t1_r = bf06_09_t1,
         bf06_49_t1_r = bf06_49_t1,
         bf06_29_t2_r = bf06_29_t2,
         bf06_04_t2_r = bf06_04_t2,
         bf06_24_t2_r = bf06_24_t2,
         bf06_44_t2_r = bf06_44_t2,
         bf06_09_t2_r = bf06_09_t2,
         bf06_49_t2_r = bf06_49_t2) %>% 
  mutate(across(c(bf06_29_t1_r, bf06_04_t1_r, bf06_24_t1_r, bf06_44_t1_r, bf06_09_t1_r, bf06_49_t1_r, 
                  bf06_29_t2_r, bf06_04_t2_r, bf06_24_t2_r, bf06_44_t2_r, bf06_09_t2_r, bf06_49_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(neuro_ideal_par1_t1 = rowMeans(across(c(bf06_39_t1, bf06_14_t1, bf06_44_t1_r, bf06_04_t1_r)), na.rm=T),
         neuro_ideal_par2_t1 = rowMeans(across(c(bf06_34_t1, bf06_49_t1, bf06_29_t1_r, bf06_24_t1_r)), na.rm=T),
         neuro_ideal_par3_t1 = rowMeans(across(c(bf06_54_t1, bf06_59_t1, bf06_19_t1, bf06_09_t1_r)), na.rm=T),
         neuro_ideal_par1_t2 = rowMeans(across(c(bf06_39_t2, bf06_14_t2, bf06_44_t2_r, bf06_04_t2_r)), na.rm=T),
         neuro_ideal_par2_t2 = rowMeans(across(c(bf06_34_t2, bf06_49_t2, bf06_29_t2_r, bf06_24_t2_r)), na.rm=T),
         neuro_ideal_par3_t2 = rowMeans(across(c(bf06_54_t2, bf06_59_t2, bf06_19_t2, bf06_09_t2_r)), na.rm=T))
```

#### Openness - current personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_openn_curr <- '
# Define the latent factors
openn_curr1 =~ NA*bf05_05_t1 + lambda1*bf05_05_t1 + lambda2*bf05_10_t1 + lambda3*bf05_15_t1 + lambda4*bf05_20_t1 + lambda5*bf05_25_t1 + lambda6*bf05_30_t1 + lambda7*bf05_35_t1 + lambda8*bf05_40_t1 + lambda9*bf05_45_t1 + lambda10*bf05_50_t1 + lambda11*bf05_55_t1 + lambda12*bf05_60_t1

# Intercepts
bf05_05_t1 ~ i1*1
bf05_10_t1 ~ 1
bf05_15_t1 ~ 1
bf05_20_t1 ~ 1
bf05_25_t1 ~ 1
bf05_30_t1 ~ 1
bf05_35_t1 ~ 1
bf05_40_t1 ~ 1
bf05_45_t1 ~ 1
bf05_50_t1 ~ 1
bf05_55_t1 ~ 1
bf05_60_t1 ~ 1

# Unique Variances
bf05_05_t1 ~~ bf05_05_t1
bf05_10_t1 ~~ bf05_10_t1
bf05_15_t1 ~~ bf05_15_t1
bf05_20_t1 ~~ bf05_20_t1
bf05_25_t1 ~~ bf05_25_t1
bf05_30_t1 ~~ bf05_30_t1
bf05_35_t1 ~~ bf05_35_t1
bf05_40_t1 ~~ bf05_40_t1
bf05_45_t1 ~~ bf05_45_t1
bf05_50_t1 ~~ bf05_50_t1
bf05_55_t1 ~~ bf05_55_t1
bf05_60_t1 ~~ bf05_60_t1

# Latent Variable Means
openn_curr1 ~ 0*1

# Latent Variable Variances and Covariance
openn_curr1 ~~ 1*openn_curr1
'
fit_cfa_openn_curr <- cfa(cfa_openn_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_cfa_openn_curr, fit.measures = TRUE)
tidy(fit_cfa_openn_curr) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf05_50_t1_r = bf05_50_t1,
         bf05_55_t1_r = bf05_55_t1,
         bf05_30_t1_r = bf05_30_t1,
         bf05_25_t1_r = bf05_25_t1,
         bf05_45_t1_r = bf05_45_t1,
         bf05_05_t1_r = bf05_05_t1,
         bf05_50_t2_r = bf05_50_t2,
         bf05_55_t2_r = bf05_55_t2,
         bf05_30_t2_r = bf05_30_t2,
         bf05_25_t2_r = bf05_25_t2,
         bf05_45_t2_r = bf05_45_t2,
         bf05_05_t2_r = bf05_05_t2) %>% 
  mutate(across(c(bf05_50_t1_r, bf05_55_t1_r, bf05_30_t1_r, bf05_25_t1_r, bf05_45_t1_r, bf05_05_t1_r,
                  bf05_50_t2_r, bf05_55_t2_r, bf05_30_t2_r, bf05_25_t2_r, bf05_45_t2_r, bf05_05_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(openn_curr_par1_t1 = rowMeans(across(c(bf05_30_t1_r, bf05_60_t1, bf05_15_t1, bf05_05_t1_r)), na.rm=T),
         openn_curr_par2_t1 = rowMeans(across(c(bf05_35_t1, bf05_55_t1_r, bf05_25_t1_r, bf05_40_t1)), na.rm=T),
         openn_curr_par3_t1 = rowMeans(across(c(bf05_50_t1_r, bf05_20_t1, bf05_45_t1_r, bf05_10_t1)), na.rm=T),
         openn_curr_par1_t2 = rowMeans(across(c(bf05_30_t2_r, bf05_60_t2, bf05_15_t2, bf05_05_t2_r)), na.rm=T),
         openn_curr_par2_t2 = rowMeans(across(c(bf05_35_t2, bf05_55_t2_r, bf05_25_t2_r, bf05_40_t2)), na.rm=T),
         openn_curr_par3_t2 = rowMeans(across(c(bf05_50_t2_r, bf05_20_t2, bf05_45_t2_r, bf05_10_t2)), na.rm=T))
```

#### Openness - ideal personality

Check CFA item loadings at T1
```{r}
#| echo: true
#| warning: false

cfa_openn_ideal <- '
# Define the latent factors
openn_ideal1 =~ NA*bf06_05_t1 + lambda1*bf06_05_t1 + lambda2*bf06_10_t1 + lambda3*bf06_15_t1 + lambda4*bf06_20_t1 + lambda5*bf06_25_t1 + lambda6*bf06_30_t1 + lambda7*bf06_35_t1 + lambda8*bf06_40_t1 + lambda9*bf06_45_t1 + lambda10*bf06_50_t1 + lambda11*bf06_55_t1 + lambda12*bf06_60_t1

# Intercepts
bf06_05_t1 ~ i1*1
bf06_10_t1 ~ 1
bf06_15_t1 ~ 1
bf06_20_t1 ~ 1
bf06_25_t1 ~ 1
bf06_30_t1 ~ 1
bf06_35_t1 ~ 1
bf06_40_t1 ~ 1
bf06_45_t1 ~ 1
bf06_50_t1 ~ 1
bf06_55_t1 ~ 1
bf06_60_t1 ~ 1

# Unique Variances
bf06_05_t1 ~~ bf06_05_t1
bf06_10_t1 ~~ bf06_10_t1
bf06_15_t1 ~~ bf06_15_t1
bf06_20_t1 ~~ bf06_20_t1
bf06_25_t1 ~~ bf06_25_t1
bf06_30_t1 ~~ bf06_30_t1
bf06_35_t1 ~~ bf06_35_t1
bf06_40_t1 ~~ bf06_40_t1
bf06_45_t1 ~~ bf06_45_t1
bf06_50_t1 ~~ bf06_50_t1
bf06_55_t1 ~~ bf06_55_t1
bf06_60_t1 ~~ bf06_60_t1

# Latent Variable Means
openn_ideal1 ~ 0*1

# Latent Variable Variances and Covariance
openn_ideal1 ~~ 1*openn_ideal1
'
fit_cfa_openn_ideal <- cfa(cfa_openn_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                           mimic = "mplus", missing="ML")
summary(fit_cfa_openn_ideal, fit.measures = TRUE)
tidy(fit_cfa_openn_ideal) %>% filter(str_detect(label, "lambda")) %>% mutate(abs_loading = abs(estimate)) %>% arrange(desc(abs_loading)) %>% select(1:5, std.all)
```

Reverse-code and form parcels:
```{r}
#| echo: true
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(bf06_50_t1_r = bf06_50_t1,
         bf06_55_t1_r = bf06_55_t1,
         bf06_30_t1_r = bf06_30_t1,
         bf06_25_t1_r = bf06_25_t1,
         bf06_45_t1_r = bf06_45_t1,
         bf06_05_t1_r = bf06_05_t1,
         bf06_50_t2_r = bf06_50_t2,
         bf06_55_t2_r = bf06_55_t2,
         bf06_30_t2_r = bf06_30_t2,
         bf06_25_t2_r = bf06_25_t2,
         bf06_45_t2_r = bf06_45_t2,
         bf06_05_t2_r = bf06_05_t2) %>% 
  mutate(across(c(bf06_50_t1_r, bf06_55_t1_r, bf06_30_t1_r, bf06_25_t1_r, bf06_45_t1_r, bf06_05_t1_r,
                  bf06_50_t2_r, bf06_55_t2_r, bf06_30_t2_r, bf06_25_t2_r, bf06_45_t2_r, bf06_05_t2_r), 
                ~ recode(.x, `1` = 5L, `2` = 4L, `3` = 3L, `4` = 2L, `5` = 1L, .default = NA_integer_))) %>% 
  mutate(openn_ideal_par1_t1 = rowMeans(across(c(bf06_30_t1_r, bf06_60_t1, bf06_50_t1_r, bf06_05_t1_r)), na.rm=T),
         openn_ideal_par2_t1 = rowMeans(across(c(bf06_35_t1, bf06_20_t1, bf06_25_t1_r, bf06_10_t1)), na.rm=T),
         openn_ideal_par3_t1 = rowMeans(across(c(bf06_45_t1_r, bf06_55_t1_r, bf06_40_t1, bf06_15_t1)), na.rm=T),
         openn_ideal_par1_t2 = rowMeans(across(c(bf06_30_t2_r, bf06_60_t2, bf06_50_t2_r, bf06_05_t2_r)), na.rm=T),
         openn_ideal_par2_t2 = rowMeans(across(c(bf06_35_t2, bf06_20_t2, bf06_25_t2_r, bf06_10_t2)), na.rm=T),
         openn_ideal_par3_t2 = rowMeans(across(c(bf06_45_t2_r, bf06_55_t2_r, bf06_40_t2, bf06_15_t2)), na.rm=T))

# replace NaN with regular NA
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
    mutate_all(~ifelse(is.nan(.), NA, .))
```

### Recode all reverse-keyed items

This is only relevant for the facet-level models. All trait-level models rely on the parcels created above. However, the facet-level models pick the first item as the anchor indicator which is sometimes reverse-keyed for the latent factor. For analyses below I want to use just positively keyed variables (for neuroticism facets higher values should indicate higher neuroticism). 

```{r}
#| echo: true
#| warning: false

# save all relevant variable names
names_rev_scored <- df_sbsa3_wide_pers %>% select(ends_with("_r")) %>% colnames()
names_rev_scored_orig <- gsub("_r", "", names_rev_scored) # variable names without the "_r" -> these are the original variables

# drop original variables
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% select(-all_of(names_rev_scored_orig))
# recreate original variable names -> these are the recoded variables now!
df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% rename_with(~ gsub("_r", "", .x))
```

------------------------------------------------------------------------

## Measurement invariance

### Well-being outcomes

Testing for measurement invariance of the latent traits across time.

#### Life satisfaction

Satisfaction with life scale (only the first four items - last one taps into a somewhat different construct)

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_swls <- '
# Define the latent factors
swls1 =~ NA*sw06_01_t1 + lambda1*sw06_01_t1 + sw06_02_t1 + sw06_03_t1 + sw06_04_t1
swls2 =~ NA*sw06_01_t2 + lambda1*sw06_01_t2 + sw06_02_t2 + sw06_03_t2 + sw06_04_t2

# Intercepts
sw06_01_t1 ~ i1*1
sw06_02_t1 ~ 1
sw06_03_t1 ~ 1
sw06_04_t1 ~ 1

sw06_01_t2 ~ i1*1
sw06_02_t2 ~ 1
sw06_03_t2 ~ 1
sw06_04_t2 ~ 1

# Unique Variances
sw06_01_t1 ~~ sw06_01_t1
sw06_02_t1 ~~ sw06_02_t1
sw06_03_t1 ~~ sw06_03_t1
sw06_04_t1 ~~ sw06_04_t1

sw06_01_t2 ~~ sw06_01_t2
sw06_02_t2 ~~ sw06_02_t2
sw06_03_t2 ~~ sw06_03_t2
sw06_04_t2 ~~ sw06_04_t2

# Latent Variable Means
swls1 ~ 0*1
swls2 ~ 1

# Latent Variable Variances and Covariance
swls1 ~~ 1*swls1
swls2 ~~ swls2
swls1 ~~ swls2
'
fit_configural_swls <- cfa(configural_swls, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_configural_swls, fit.measures = TRUE)

# Weak invariance model
weak_swls <- '
# Define the latent factors
swls1 =~ NA*sw06_01_t1 + lambda1*sw06_01_t1 + lambda2*sw06_02_t1 + lambda3*sw06_03_t1 + lambda4*sw06_04_t1
swls2 =~ NA*sw06_01_t2 + lambda1*sw06_01_t2 + lambda2*sw06_02_t2 + lambda3*sw06_03_t2 + lambda4*sw06_04_t2

# Intercepts
sw06_01_t1 ~ i1*1
sw06_02_t1 ~ 1
sw06_03_t1 ~ 1
sw06_04_t1 ~ 1

sw06_01_t2 ~ i1*1
sw06_02_t2 ~ 1
sw06_03_t2 ~ 1
sw06_04_t2 ~ 1

# Unique Variances
sw06_01_t1 ~~ sw06_01_t1
sw06_02_t1 ~~ sw06_02_t1
sw06_03_t1 ~~ sw06_03_t1
sw06_04_t1 ~~ sw06_04_t1

sw06_01_t2 ~~ sw06_01_t2
sw06_02_t2 ~~ sw06_02_t2
sw06_03_t2 ~~ sw06_03_t2
sw06_04_t2 ~~ sw06_04_t2

# Latent Variable Means
swls1 ~ 0*1
swls2 ~ 1

# Latent Variable Variances and Covariance
swls1 ~~ 1*swls1
swls2 ~~ swls2
swls1 ~~ swls2
'
fit_weak_swls <- cfa(weak_swls, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_weak_swls, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_swls <- '
# Define the latent factors
swls1 =~ NA*sw06_01_t1 + lambda1*sw06_01_t1 + lambda2*sw06_02_t1 + lambda3*sw06_03_t1 + lambda4*sw06_04_t1
swls2 =~ NA*sw06_01_t2 + lambda1*sw06_01_t2 + lambda2*sw06_02_t2 + lambda3*sw06_03_t2 + lambda4*sw06_04_t2

# Intercepts
sw06_01_t1 ~ i1*1
sw06_02_t1 ~ i2*1
sw06_03_t1 ~ i3*1
sw06_04_t1 ~ i4*1

sw06_01_t2 ~ i1*1
sw06_02_t2 ~ i2*1
sw06_03_t2 ~ i3*1
sw06_04_t2 ~ i4*1

# Unique Variances
sw06_01_t1 ~~ sw06_01_t1
sw06_02_t1 ~~ sw06_02_t1
sw06_03_t1 ~~ sw06_03_t1
sw06_04_t1 ~~ sw06_04_t1

sw06_01_t2 ~~ sw06_01_t2
sw06_02_t2 ~~ sw06_02_t2
sw06_03_t2 ~~ sw06_03_t2
sw06_04_t2 ~~ sw06_04_t2

# Latent Variable Means
swls1 ~ 0*1
swls2 ~ 1

# Latent Variable Variances and Covariance
swls1 ~~ 1*swls1
swls2 ~~ swls2
swls1 ~~ swls2
'
fit_strong_swls <- cfa(strong_swls, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strong_swls, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_swls <- '
# Define the latent factors
swls1 =~ NA*sw06_01_t1 + lambda1*sw06_01_t1 + lambda2*sw06_02_t1 + lambda3*sw06_03_t1 + lambda4*sw06_04_t1
swls2 =~ NA*sw06_01_t2 + lambda1*sw06_01_t2 + lambda2*sw06_02_t2 + lambda3*sw06_03_t2 + lambda4*sw06_04_t2

# Intercepts
sw06_01_t1 ~ i1*1
sw06_02_t1 ~ i2*1
sw06_03_t1 ~ i3*1
sw06_04_t1 ~ i4*1

sw06_01_t2 ~ i1*1
sw06_02_t2 ~ i2*1
sw06_03_t2 ~ i3*1
sw06_04_t2 ~ i4*1

# Unique Variances
sw06_01_t1 ~~ u1*sw06_01_t1
sw06_02_t1 ~~ u2*sw06_02_t1
sw06_03_t1 ~~ u3*sw06_03_t1
sw06_04_t1 ~~ u4*sw06_04_t1

sw06_01_t2 ~~ u1*sw06_01_t2
sw06_02_t2 ~~ u2*sw06_02_t2
sw06_03_t2 ~~ u3*sw06_03_t2
sw06_04_t2 ~~ u4*sw06_04_t2

# Latent Variable Means
swls1 ~ 0*1
swls2 ~ 1

# Latent Variable Variances and Covariance
swls1 ~~ 1*swls1
swls2 ~~ swls2
swls1 ~~ swls2
'
fit_strict_swls <- cfa(strict_swls, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strict_swls, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_swls) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_swls) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_swls) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_swls) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_swls, fit_weak_swls)

anova(fit_weak_swls, fit_strong_swls)

anova(fit_strong_swls, fit_strict_swls)
```

::: {.callout-note appearance="minimal"}
Model fit relatively similar across model specifications. Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Meaning in life

For the 5-item subscale presence of meaning in life.  

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_meaning <- '
# Define the latent factors
meaning1 =~ NA*ml01_01_t1 + lambda1*ml01_01_t1 + ml01_04_t1 + ml01_05_t1 + ml01_06_t1 + ml01_09_t1
meaning2 =~ NA*ml01_01_t2 + lambda1*ml01_01_t2 + ml01_04_t2 + ml01_05_t2 + ml01_06_t2 + ml01_09_t2

# Intercepts
ml01_01_t1 ~ i1*1
ml01_04_t1 ~ 1
ml01_05_t1 ~ 1
ml01_06_t1 ~ 1
ml01_09_t1 ~ 1

ml01_01_t2 ~ i1*1
ml01_04_t2 ~ 1
ml01_05_t2 ~ 1
ml01_06_t2 ~ 1
ml01_09_t2 ~ 1

# Unique Variances
ml01_01_t1 ~~ ml01_01_t1
ml01_04_t1 ~~ ml01_04_t1
ml01_05_t1 ~~ ml01_05_t1
ml01_06_t1 ~~ ml01_06_t1
ml01_09_t1 ~~ ml01_09_t1

ml01_01_t2 ~~ ml01_01_t2
ml01_04_t2 ~~ ml01_04_t2
ml01_05_t2 ~~ ml01_05_t2
ml01_06_t2 ~~ ml01_06_t2
ml01_09_t2 ~~ ml01_09_t2

# Latent Variable Means
meaning1 ~ 0*1
meaning2 ~ 1

# Latent Variable Variances and Covariance
meaning1 ~~ 1*meaning1
meaning2 ~~ meaning2
meaning1 ~~ meaning2
'
fit_configural_meaning <- cfa(configural_meaning, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_configural_meaning, fit.measures = TRUE)

# Weak invariance model
weak_meaning <- '
# Define the latent factors
meaning1 =~ NA*ml01_01_t1 + lambda1*ml01_01_t1 + lambda4*ml01_04_t1 + lambda5*ml01_05_t1 + lambda6*ml01_06_t1 + lambda9*ml01_09_t1
meaning2 =~ NA*ml01_01_t2 + lambda1*ml01_01_t2 + lambda4*ml01_04_t2 + lambda5*ml01_05_t2 + lambda6*ml01_06_t2 + lambda9*ml01_09_t2

# Intercepts
ml01_01_t1 ~ i1*1
ml01_04_t1 ~ 1
ml01_05_t1 ~ 1
ml01_06_t1 ~ 1
ml01_09_t1 ~ 1

ml01_01_t2 ~ i1*1
ml01_04_t2 ~ 1
ml01_05_t2 ~ 1
ml01_06_t2 ~ 1
ml01_09_t2 ~ 1

# Unique Variances
ml01_01_t1 ~~ ml01_01_t1
ml01_04_t1 ~~ ml01_04_t1
ml01_05_t1 ~~ ml01_05_t1
ml01_06_t1 ~~ ml01_06_t1
ml01_09_t1 ~~ ml01_09_t1

ml01_01_t2 ~~ ml01_01_t2
ml01_04_t2 ~~ ml01_04_t2
ml01_05_t2 ~~ ml01_05_t2
ml01_06_t2 ~~ ml01_06_t2
ml01_09_t2 ~~ ml01_09_t2

# Latent Variable Means
meaning1 ~ 0*1
meaning2 ~ 1

# Latent Variable Variances and Covariance
meaning1 ~~ 1*meaning1
meaning2 ~~ meaning2
meaning1 ~~ meaning2
'
fit_weak_meaning <- cfa(weak_meaning, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_weak_meaning, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_meaning <- '
# Define the latent factors
meaning1 =~ NA*ml01_01_t1 + lambda1*ml01_01_t1 + lambda4*ml01_04_t1 + lambda5*ml01_05_t1 + lambda6*ml01_06_t1 + lambda9*ml01_09_t1
meaning2 =~ NA*ml01_01_t2 + lambda1*ml01_01_t2 + lambda4*ml01_04_t2 + lambda5*ml01_05_t2 + lambda6*ml01_06_t2 + lambda9*ml01_09_t2

# Intercepts
ml01_01_t1 ~ i1*1
ml01_04_t1 ~ i2*1
ml01_05_t1 ~ i3*1
ml01_06_t1 ~ i4*1
ml01_09_t1 ~ i5*1

ml01_01_t2 ~ i1*1
ml01_04_t2 ~ i2*1
ml01_05_t2 ~ i3*1
ml01_06_t2 ~ i4*1
ml01_09_t2 ~ i5*1

# Unique Variances
ml01_01_t1 ~~ ml01_01_t1
ml01_04_t1 ~~ ml01_04_t1
ml01_05_t1 ~~ ml01_05_t1
ml01_06_t1 ~~ ml01_06_t1
ml01_09_t1 ~~ ml01_09_t1

ml01_01_t2 ~~ ml01_01_t2
ml01_04_t2 ~~ ml01_04_t2
ml01_05_t2 ~~ ml01_05_t2
ml01_06_t2 ~~ ml01_06_t2
ml01_09_t2 ~~ ml01_09_t2

# Latent Variable Means
meaning1 ~ 0*1
meaning2 ~ 1

# Latent Variable Variances and Covariance
meaning1 ~~ 1*meaning1
meaning2 ~~ meaning2
meaning1 ~~ meaning2
'
fit_strong_meaning <- cfa(strong_meaning, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strong_meaning, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_meaning <- '
# Define the latent factors
meaning1 =~ NA*ml01_01_t1 + lambda1*ml01_01_t1 + lambda4*ml01_04_t1 + lambda5*ml01_05_t1 + lambda6*ml01_06_t1 + lambda9*ml01_09_t1
meaning2 =~ NA*ml01_01_t2 + lambda1*ml01_01_t2 + lambda4*ml01_04_t2 + lambda5*ml01_05_t2 + lambda6*ml01_06_t2 + lambda9*ml01_09_t2

# Intercepts
ml01_01_t1 ~ i1*1
ml01_04_t1 ~ i2*1
ml01_05_t1 ~ i3*1
ml01_06_t1 ~ i4*1
ml01_09_t1 ~ i5*1

ml01_01_t2 ~ i1*1
ml01_04_t2 ~ i2*1
ml01_05_t2 ~ i3*1
ml01_06_t2 ~ i4*1
ml01_09_t2 ~ i5*1

# Unique Variances
ml01_01_t1 ~~ u1*ml01_01_t1
ml01_04_t1 ~~ u2*ml01_04_t1
ml01_05_t1 ~~ u3*ml01_05_t1
ml01_06_t1 ~~ u4*ml01_06_t1
ml01_09_t1 ~~ u5*ml01_09_t1

ml01_01_t2 ~~ u1*ml01_01_t2
ml01_04_t2 ~~ u2*ml01_04_t2
ml01_05_t2 ~~ u3*ml01_05_t2
ml01_06_t2 ~~ u4*ml01_06_t2
ml01_09_t2 ~~ u5*ml01_09_t2

# Latent Variable Means
meaning1 ~ 0*1
meaning2 ~ 1

# Latent Variable Variances and Covariance
meaning1 ~~ 1*meaning1
meaning2 ~~ meaning2
meaning1 ~~ meaning2
'
fit_strict_meaning <- cfa(strict_meaning, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strict_meaning, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_meaning) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_meaning) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_meaning) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_meaning) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_meaning, fit_weak_meaning)

anova(fit_weak_meaning, fit_strong_meaning)

anova(fit_strong_meaning, fit_strict_meaning)
```

::: {.callout-note appearance="minimal"}
Good model fit across all model specifications. Chi^2 tests indicate that strict measurement invariance is given.
:::

##### Search for Meaning

For the 5-item subscale search for meaning in life.  

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_search <- '
# Define the latent factors
search1 =~ NA*ml01_02_t1 + lambda1*ml01_02_t1 + ml01_03_t1 + ml01_07_t1 + ml01_08_t1 + ml01_10_t1
search2 =~ NA*ml01_02_t2 + lambda1*ml01_02_t2 + ml01_03_t2 + ml01_07_t2 + ml01_08_t2 + ml01_10_t2

# Intercepts
ml01_02_t1 ~ i1*1
ml01_03_t1 ~ 1
ml01_07_t1 ~ 1
ml01_08_t1 ~ 1
ml01_10_t1 ~ 1

ml01_02_t2 ~ i1*1
ml01_03_t2 ~ 1
ml01_07_t2 ~ 1
ml01_08_t2 ~ 1
ml01_10_t2 ~ 1

# Unique Variances
ml01_02_t1 ~~ ml01_02_t1
ml01_03_t1 ~~ ml01_03_t1
ml01_07_t1 ~~ ml01_07_t1
ml01_08_t1 ~~ ml01_08_t1
ml01_10_t1 ~~ ml01_10_t1

ml01_02_t2 ~~ ml01_02_t2
ml01_03_t2 ~~ ml01_03_t2
ml01_07_t2 ~~ ml01_07_t2
ml01_08_t2 ~~ ml01_08_t2
ml01_10_t2 ~~ ml01_10_t2

# Latent Variable Means
search1 ~ 0*1
search2 ~ 1

# Latent Variable Variances and Covariance
search1 ~~ 1*search1
search2 ~~ search2
search1 ~~ search2
'
fit_configural_search <- cfa(configural_search, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_configural_search, fit.measures = TRUE)

# Weak invariance model
weak_search <- '
# Define the latent factors
search1 =~ NA*ml01_02_t1 + lambda1*ml01_02_t1 + lambda4*ml01_03_t1 + lambda5*ml01_07_t1 + lambda6*ml01_08_t1 + lambda9*ml01_10_t1
search2 =~ NA*ml01_02_t2 + lambda1*ml01_02_t2 + lambda4*ml01_03_t2 + lambda5*ml01_07_t2 + lambda6*ml01_08_t2 + lambda9*ml01_10_t2

# Intercepts
ml01_02_t1 ~ i1*1
ml01_03_t1 ~ 1
ml01_07_t1 ~ 1
ml01_08_t1 ~ 1
ml01_10_t1 ~ 1

ml01_02_t2 ~ i1*1
ml01_03_t2 ~ 1
ml01_07_t2 ~ 1
ml01_08_t2 ~ 1
ml01_10_t2 ~ 1

# Unique Variances
ml01_02_t1 ~~ ml01_02_t1
ml01_03_t1 ~~ ml01_03_t1
ml01_07_t1 ~~ ml01_07_t1
ml01_08_t1 ~~ ml01_08_t1
ml01_10_t1 ~~ ml01_10_t1

ml01_02_t2 ~~ ml01_02_t2
ml01_03_t2 ~~ ml01_03_t2
ml01_07_t2 ~~ ml01_07_t2
ml01_08_t2 ~~ ml01_08_t2
ml01_10_t2 ~~ ml01_10_t2

# Latent Variable Means
search1 ~ 0*1
search2 ~ 1

# Latent Variable Variances and Covariance
search1 ~~ 1*search1
search2 ~~ search2
search1 ~~ search2
'
fit_weak_search <- cfa(weak_search, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_weak_search, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_search <- '
# Define the latent factors
search1 =~ NA*ml01_02_t1 + lambda1*ml01_02_t1 + lambda4*ml01_03_t1 + lambda5*ml01_07_t1 + lambda6*ml01_08_t1 + lambda9*ml01_10_t1
search2 =~ NA*ml01_02_t2 + lambda1*ml01_02_t2 + lambda4*ml01_03_t2 + lambda5*ml01_07_t2 + lambda6*ml01_08_t2 + lambda9*ml01_10_t2

# Intercepts
ml01_02_t1 ~ i1*1
ml01_03_t1 ~ i2*1
ml01_07_t1 ~ i3*1
ml01_08_t1 ~ i4*1
ml01_10_t1 ~ i5*1

ml01_02_t2 ~ i1*1
ml01_03_t2 ~ i2*1
ml01_07_t2 ~ i3*1
ml01_08_t2 ~ i4*1
ml01_10_t2 ~ i5*1

# Unique Variances
ml01_02_t1 ~~ ml01_02_t1
ml01_03_t1 ~~ ml01_03_t1
ml01_07_t1 ~~ ml01_07_t1
ml01_08_t1 ~~ ml01_08_t1
ml01_10_t1 ~~ ml01_10_t1

ml01_02_t2 ~~ ml01_02_t2
ml01_03_t2 ~~ ml01_03_t2
ml01_07_t2 ~~ ml01_07_t2
ml01_08_t2 ~~ ml01_08_t2
ml01_10_t2 ~~ ml01_10_t2

# Latent Variable Means
search1 ~ 0*1
search2 ~ 1

# Latent Variable Variances and Covariance
search1 ~~ 1*search1
search2 ~~ search2
search1 ~~ search2
'
fit_strong_search <- cfa(strong_search, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strong_search, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_search <- '
# Define the latent factors
search1 =~ NA*ml01_02_t1 + lambda1*ml01_02_t1 + lambda4*ml01_03_t1 + lambda5*ml01_07_t1 + lambda6*ml01_08_t1 + lambda9*ml01_10_t1
search2 =~ NA*ml01_02_t2 + lambda1*ml01_02_t2 + lambda4*ml01_03_t2 + lambda5*ml01_07_t2 + lambda6*ml01_08_t2 + lambda9*ml01_10_t2

# Intercepts
ml01_02_t1 ~ i1*1
ml01_03_t1 ~ i2*1
ml01_07_t1 ~ i3*1
ml01_08_t1 ~ i4*1
ml01_10_t1 ~ i5*1

ml01_02_t2 ~ i1*1
ml01_03_t2 ~ i2*1
ml01_07_t2 ~ i3*1
ml01_08_t2 ~ i4*1
ml01_10_t2 ~ i5*1

# Unique Variances
ml01_02_t1 ~~ u1*ml01_02_t1
ml01_03_t1 ~~ u2*ml01_03_t1
ml01_07_t1 ~~ u3*ml01_07_t1
ml01_08_t1 ~~ u4*ml01_08_t1
ml01_10_t1 ~~ u5*ml01_10_t1

ml01_02_t2 ~~ u1*ml01_02_t2
ml01_03_t2 ~~ u2*ml01_03_t2
ml01_07_t2 ~~ u3*ml01_07_t2
ml01_08_t2 ~~ u4*ml01_08_t2
ml01_10_t2 ~~ u5*ml01_10_t2

# Latent Variable Means
search1 ~ 0*1
search2 ~ 1

# Latent Variable Variances and Covariance
search1 ~~ 1*search1
search2 ~~ search2
search1 ~~ search2
'
fit_strict_search <- cfa(strict_search, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strict_search, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_search) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_search) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_search) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_search) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_search, fit_weak_search)

anova(fit_weak_search, fit_strong_search)

anova(fit_strong_search, fit_strict_search)
```

::: {.callout-note appearance="minimal"}
Good model fit across all model specifications (except for RMSEA but almost...). Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Self-esteem

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_selfes <- '
# Define the latent factors
selfes1 =~ NA*selfes_par1_t1 + lambda1*selfes_par1_t1 + selfes_par2_t1 + selfes_par3_t1
selfes2 =~ NA*selfes_par1_t2 + lambda1*selfes_par1_t2 + selfes_par2_t2 + selfes_par3_t2

# Intercepts
selfes_par1_t1 ~ i1*1
selfes_par2_t1 ~ 1
selfes_par3_t1 ~ 1

selfes_par1_t2 ~ i1*1
selfes_par2_t2 ~ 1
selfes_par3_t2 ~ 1

# Unique Variances
selfes_par1_t1 ~~ selfes_par1_t1
selfes_par2_t1 ~~ selfes_par2_t1
selfes_par3_t1 ~~ selfes_par3_t1

selfes_par1_t2 ~~ selfes_par1_t2
selfes_par2_t2 ~~ selfes_par2_t2
selfes_par3_t2 ~~ selfes_par3_t2

# Latent Variable Means
selfes1 ~ 0*1
selfes2 ~ 1

# Latent Variable Variances and Covariance
selfes1 ~~ 1*selfes1
selfes2 ~~ selfes2
selfes1 ~~ selfes2
'
fit_configural_selfes <- cfa(configural_selfes, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_configural_selfes, fit.measures = TRUE)

# Weak invariance model
weak_selfes <- '
# Define the latent factors
selfes1 =~ NA*selfes_par1_t1 + lambda1*selfes_par1_t1 + lambda2*selfes_par2_t1 + lambda3*selfes_par3_t1
selfes2 =~ NA*selfes_par1_t2 + lambda1*selfes_par1_t2 + lambda2*selfes_par2_t2 + lambda3*selfes_par3_t2

# Intercepts
selfes_par1_t1 ~ i1*1
selfes_par2_t1 ~ 1
selfes_par3_t1 ~ 1

selfes_par1_t2 ~ i1*1
selfes_par2_t2 ~ 1
selfes_par3_t2 ~ 1

# Unique Variances
selfes_par1_t1 ~~ selfes_par1_t1
selfes_par2_t1 ~~ selfes_par2_t1
selfes_par3_t1 ~~ selfes_par3_t1

selfes_par1_t2 ~~ selfes_par1_t2
selfes_par2_t2 ~~ selfes_par2_t2
selfes_par3_t2 ~~ selfes_par3_t2

# Latent Variable Means
selfes1 ~ 0*1
selfes2 ~ 1

# Latent Variable Variances and Covariance
selfes1 ~~ 1*selfes1
selfes2 ~~ selfes2
selfes1 ~~ selfes2
'
fit_weak_selfes <- cfa(weak_selfes, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_weak_selfes, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_selfes <- '
# Define the latent factors
selfes1 =~ NA*selfes_par1_t1 + lambda1*selfes_par1_t1 + lambda2*selfes_par2_t1 + lambda3*selfes_par3_t1
selfes2 =~ NA*selfes_par1_t2 + lambda1*selfes_par1_t2 + lambda2*selfes_par2_t2 + lambda3*selfes_par3_t2

# Intercepts
selfes_par1_t1 ~ i1*1
selfes_par2_t1 ~ i2*1
selfes_par3_t1 ~ i3*1

selfes_par1_t2 ~ i1*1
selfes_par2_t2 ~ i2*1
selfes_par3_t2 ~ i3*1

# Unique Variances
selfes_par1_t1 ~~ selfes_par1_t1
selfes_par2_t1 ~~ selfes_par2_t1
selfes_par3_t1 ~~ selfes_par3_t1

selfes_par1_t2 ~~ selfes_par1_t2
selfes_par2_t2 ~~ selfes_par2_t2
selfes_par3_t2 ~~ selfes_par3_t2

# Latent Variable Means
selfes1 ~ 0*1
selfes2 ~ 1

# Latent Variable Variances and Covariance
selfes1 ~~ 1*selfes1
selfes2 ~~ selfes2
selfes1 ~~ selfes2
'
fit_strong_selfes <- cfa(strong_selfes, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strong_selfes, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_selfes <- '
# Define the latent factors
selfes1 =~ NA*selfes_par1_t1 + lambda1*selfes_par1_t1 + lambda2*selfes_par2_t1 + lambda3*selfes_par3_t1
selfes2 =~ NA*selfes_par1_t2 + lambda1*selfes_par1_t2 + lambda2*selfes_par2_t2 + lambda3*selfes_par3_t2

# Intercepts
selfes_par1_t1 ~ i1*1
selfes_par2_t1 ~ i2*1
selfes_par3_t1 ~ i3*1

selfes_par1_t2 ~ i1*1
selfes_par2_t2 ~ i2*1
selfes_par3_t2 ~ i3*1

# Unique Variances
selfes_par1_t1 ~~ u1*selfes_par1_t1
selfes_par2_t1 ~~ u2*selfes_par2_t1
selfes_par3_t1 ~~ u3*selfes_par3_t1

selfes_par1_t2 ~~ u1*selfes_par1_t2
selfes_par2_t2 ~~ u2*selfes_par2_t2
selfes_par3_t2 ~~ u3*selfes_par3_t2

# Latent Variable Means
selfes1 ~ 0*1
selfes2 ~ 1

# Latent Variable Variances and Covariance
selfes1 ~~ 1*selfes1
selfes2 ~~ selfes2
selfes1 ~~ selfes2
'
fit_strict_selfes <- cfa(strict_selfes, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strict_selfes, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_selfes) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_selfes) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_selfes) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_selfes) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_selfes, fit_weak_selfes)

anova(fit_weak_selfes, fit_strong_selfes)

anova(fit_strong_selfes, fit_strict_selfes)
```

::: {.callout-note appearance="minimal"}
Good model fit across all model specifications (except for RMSEA). Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Self concept clarity

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_concept <- '
# Define the latent factors
concept1 =~ NA*concept_par1_t1 + lambda1*concept_par1_t1 + concept_par2_t1 + concept_par3_t1
concept2 =~ NA*concept_par1_t2 + lambda1*concept_par1_t2 + concept_par2_t2 + concept_par3_t2

# Intercepts
concept_par1_t1 ~ i1*1
concept_par2_t1 ~ 1
concept_par3_t1 ~ 1

concept_par1_t2 ~ i1*1
concept_par2_t2 ~ 1
concept_par3_t2 ~ 1

# Unique Variances
concept_par1_t1 ~~ concept_par1_t1
concept_par2_t1 ~~ concept_par2_t1
concept_par3_t1 ~~ concept_par3_t1

concept_par1_t2 ~~ concept_par1_t2
concept_par2_t2 ~~ concept_par2_t2
concept_par3_t2 ~~ concept_par3_t2

# Latent Variable Means
concept1 ~ 0*1
concept2 ~ 1

# Latent Variable Variances and Covariance
concept1 ~~ 1*concept1
concept2 ~~ concept2
concept1 ~~ concept2
'
fit_configural_concept <- cfa(configural_concept, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_configural_concept, fit.measures = TRUE)

# Weak invariance model
weak_concept <- '
# Define the latent factors
concept1 =~ NA*concept_par1_t1 + lambda1*concept_par1_t1 + lambda2*concept_par2_t1 + lambda3*concept_par3_t1
concept2 =~ NA*concept_par1_t2 + lambda1*concept_par1_t2 + lambda2*concept_par2_t2 + lambda3*concept_par3_t2

# Intercepts
concept_par1_t1 ~ i1*1
concept_par2_t1 ~ 1
concept_par3_t1 ~ 1

concept_par1_t2 ~ i1*1
concept_par2_t2 ~ 1
concept_par3_t2 ~ 1

# Unique Variances
concept_par1_t1 ~~ concept_par1_t1
concept_par2_t1 ~~ concept_par2_t1
concept_par3_t1 ~~ concept_par3_t1

concept_par1_t2 ~~ concept_par1_t2
concept_par2_t2 ~~ concept_par2_t2
concept_par3_t2 ~~ concept_par3_t2

# Latent Variable Means
concept1 ~ 0*1
concept2 ~ 1

# Latent Variable Variances and Covariance
concept1 ~~ 1*concept1
concept2 ~~ concept2
concept1 ~~ concept2
'
fit_weak_concept <- cfa(weak_concept, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_weak_concept, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_concept <- '
# Define the latent factors
concept1 =~ NA*concept_par1_t1 + lambda1*concept_par1_t1 + lambda2*concept_par2_t1 + lambda3*concept_par3_t1
concept2 =~ NA*concept_par1_t2 + lambda1*concept_par1_t2 + lambda2*concept_par2_t2 + lambda3*concept_par3_t2

# Intercepts
concept_par1_t1 ~ i1*1
concept_par2_t1 ~ i2*1
concept_par3_t1 ~ i3*1

concept_par1_t2 ~ i1*1
concept_par2_t2 ~ i2*1
concept_par3_t2 ~ i3*1

# Unique Variances
concept_par1_t1 ~~ concept_par1_t1
concept_par2_t1 ~~ concept_par2_t1
concept_par3_t1 ~~ concept_par3_t1

concept_par1_t2 ~~ concept_par1_t2
concept_par2_t2 ~~ concept_par2_t2
concept_par3_t2 ~~ concept_par3_t2

# Latent Variable Means
concept1 ~ 0*1
concept2 ~ 1

# Latent Variable Variances and Covariance
concept1 ~~ 1*concept1
concept2 ~~ concept2
concept1 ~~ concept2
'
fit_strong_concept <- cfa(strong_concept, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strong_concept, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_concept <- '
# Define the latent factors
concept1 =~ NA*concept_par1_t1 + lambda1*concept_par1_t1 + lambda2*concept_par2_t1 + lambda3*concept_par3_t1
concept2 =~ NA*concept_par1_t2 + lambda1*concept_par1_t2 + lambda2*concept_par2_t2 + lambda3*concept_par3_t2

# Intercepts
concept_par1_t1 ~ i1*1
concept_par2_t1 ~ i2*1
concept_par3_t1 ~ i3*1

concept_par1_t2 ~ i1*1
concept_par2_t2 ~ i2*1
concept_par3_t2 ~ i3*1

# Unique Variances
concept_par1_t1 ~~ u1*concept_par1_t1
concept_par2_t1 ~~ u2*concept_par2_t1
concept_par3_t1 ~~ u3*concept_par3_t1

concept_par1_t2 ~~ u1*concept_par1_t2
concept_par2_t2 ~~ u2*concept_par2_t2
concept_par3_t2 ~~ u3*concept_par3_t2

# Latent Variable Means
concept1 ~ 0*1
concept2 ~ 1

# Latent Variable Variances and Covariance
concept1 ~~ 1*concept1
concept2 ~~ concept2
concept1 ~~ concept2
'
fit_strict_concept <- cfa(strict_concept, data = df_sbsa3_wide_wb, mimic = "mplus", missing="ML")
summary(fit_strict_concept, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_concept) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_concept) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_concept) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_concept) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_concept, fit_weak_concept)

anova(fit_weak_concept, fit_strong_concept)

anova(fit_strong_concept, fit_strict_concept)
```

::: {.callout-note appearance="minimal"}
Good model fit across all model specifications (except for RMSEA). Chi^2 tests indicate that strict measurement invariance is given.
:::

### Big Five 

Testing for measurement invariance of the latent BFI-2 traits across time.

#### Extraversion: current personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_extra_curr <- '
# Define the latent factors
extra_curr1 =~ NA*extra_curr_par1_t1 + lambda1*extra_curr_par1_t1 + extra_curr_par2_t1 + extra_curr_par3_t1
extra_curr2 =~ NA*extra_curr_par1_t2 + lambda1*extra_curr_par1_t2 + extra_curr_par2_t2 + extra_curr_par3_t2

# Intercepts
extra_curr_par1_t1 ~ i1*1
extra_curr_par2_t1 ~ 1
extra_curr_par3_t1 ~ 1

extra_curr_par1_t2 ~ i1*1
extra_curr_par2_t2 ~ 1
extra_curr_par3_t2 ~ 1

# Unique Variances
extra_curr_par1_t1 ~~ extra_curr_par1_t1
extra_curr_par2_t1 ~~ extra_curr_par2_t1
extra_curr_par3_t1 ~~ extra_curr_par3_t1

extra_curr_par1_t2 ~~ extra_curr_par1_t2
extra_curr_par2_t2 ~~ extra_curr_par2_t2
extra_curr_par3_t2 ~~ extra_curr_par3_t2

# Latent Variable Means
extra_curr1 ~ 0*1
extra_curr2 ~ 1

# Latent Variable Variances and Covariance
extra_curr1 ~~ 1*extra_curr1
extra_curr2 ~~ extra_curr2
extra_curr1 ~~ extra_curr2
'
fit_configural_extra_curr <- cfa(configural_extra_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_configural_extra_curr, fit.measures = TRUE)

# Weak invariance model
weak_extra_curr <- '
# Define the latent factors
extra_curr1 =~ NA*extra_curr_par1_t1 + lambda1*extra_curr_par1_t1 + lambda2*extra_curr_par2_t1 + lambda3*extra_curr_par3_t1
extra_curr2 =~ NA*extra_curr_par1_t2 + lambda1*extra_curr_par1_t2 + lambda2*extra_curr_par2_t2 + lambda3*extra_curr_par3_t2

# Intercepts
extra_curr_par1_t1 ~ i1*1
extra_curr_par2_t1 ~ 1
extra_curr_par3_t1 ~ 1

extra_curr_par1_t2 ~ i1*1
extra_curr_par2_t2 ~ 1
extra_curr_par3_t2 ~ 1

# Unique Variances
extra_curr_par1_t1 ~~ extra_curr_par1_t1
extra_curr_par2_t1 ~~ extra_curr_par2_t1
extra_curr_par3_t1 ~~ extra_curr_par3_t1

extra_curr_par1_t2 ~~ extra_curr_par1_t2
extra_curr_par2_t2 ~~ extra_curr_par2_t2
extra_curr_par3_t2 ~~ extra_curr_par3_t2

# Latent Variable Means
extra_curr1 ~ 0*1
extra_curr2 ~ 1

# Latent Variable Variances and Covariance
extra_curr1 ~~ 1*extra_curr1
extra_curr2 ~~ extra_curr2
extra_curr1 ~~ extra_curr2
'
fit_weak_extra_curr <- cfa(weak_extra_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_weak_extra_curr, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_extra_curr <- '
# Define the latent factors
extra_curr1 =~ NA*extra_curr_par1_t1 + lambda1*extra_curr_par1_t1 + lambda2*extra_curr_par2_t1 + lambda3*extra_curr_par3_t1
extra_curr2 =~ NA*extra_curr_par1_t2 + lambda1*extra_curr_par1_t2 + lambda2*extra_curr_par2_t2 + lambda3*extra_curr_par3_t2

# Intercepts
extra_curr_par1_t1 ~ i1*1
extra_curr_par2_t1 ~ i2*1
extra_curr_par3_t1 ~ i3*1

extra_curr_par1_t2 ~ i1*1
extra_curr_par2_t2 ~ i2*1
extra_curr_par3_t2 ~ i3*1

# Unique Variances
extra_curr_par1_t1 ~~ extra_curr_par1_t1
extra_curr_par2_t1 ~~ extra_curr_par2_t1
extra_curr_par3_t1 ~~ extra_curr_par3_t1

extra_curr_par1_t2 ~~ extra_curr_par1_t2
extra_curr_par2_t2 ~~ extra_curr_par2_t2
extra_curr_par3_t2 ~~ extra_curr_par3_t2

# Latent Variable Means
extra_curr1 ~ 0*1
extra_curr2 ~ 1

# Latent Variable Variances and Covariance
extra_curr1 ~~ 1*extra_curr1
extra_curr2 ~~ extra_curr2
extra_curr1 ~~ extra_curr2
'
fit_strong_extra_curr <- cfa(strong_extra_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strong_extra_curr, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_extra_curr <- '
# Define the latent factors
extra_curr1 =~ NA*extra_curr_par1_t1 + lambda1*extra_curr_par1_t1 + lambda2*extra_curr_par2_t1 + lambda3*extra_curr_par3_t1
extra_curr2 =~ NA*extra_curr_par1_t2 + lambda1*extra_curr_par1_t2 + lambda2*extra_curr_par2_t2 + lambda3*extra_curr_par3_t2

# Intercepts
extra_curr_par1_t1 ~ i1*1
extra_curr_par2_t1 ~ i2*1
extra_curr_par3_t1 ~ i3*1

extra_curr_par1_t2 ~ i1*1
extra_curr_par2_t2 ~ i2*1
extra_curr_par3_t2 ~ i3*1

# Unique Variances
extra_curr_par1_t1 ~~ u1*extra_curr_par1_t1
extra_curr_par2_t1 ~~ u2*extra_curr_par2_t1
extra_curr_par3_t1 ~~ u3*extra_curr_par3_t1

extra_curr_par1_t2 ~~ u1*extra_curr_par1_t2
extra_curr_par2_t2 ~~ u2*extra_curr_par2_t2
extra_curr_par3_t2 ~~ u3*extra_curr_par3_t2

# Latent Variable Means
extra_curr1 ~ 0*1
extra_curr2 ~ 1

# Latent Variable Variances and Covariance
extra_curr1 ~~ 1*extra_curr1
extra_curr2 ~~ extra_curr2
extra_curr1 ~~ extra_curr2
'
fit_strict_extra_curr <- cfa(strict_extra_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strict_extra_curr, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_extra_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_extra_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_extra_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_extra_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_extra_curr, fit_weak_extra_curr)

anova(fit_weak_extra_curr, fit_strong_extra_curr)

anova(fit_strong_extra_curr, fit_strict_extra_curr)
```

::: {.callout-note appearance="minimal"}
Model fit satisfactory, except for RMSEA. Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Extraversion: ideal personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_extra_ideal <- '
# Define the latent factors
extra_ideal1 =~ NA*extra_ideal_par1_t1 + lambda1*extra_ideal_par1_t1 + extra_ideal_par2_t1 + extra_ideal_par3_t1
extra_ideal2 =~ NA*extra_ideal_par1_t2 + lambda1*extra_ideal_par1_t2 + extra_ideal_par2_t2 + extra_ideal_par3_t2

# Intercepts
extra_ideal_par1_t1 ~ i1*1
extra_ideal_par2_t1 ~ 1
extra_ideal_par3_t1 ~ 1

extra_ideal_par1_t2 ~ i1*1
extra_ideal_par2_t2 ~ 1
extra_ideal_par3_t2 ~ 1

# Unique Variances
extra_ideal_par1_t1 ~~ extra_ideal_par1_t1
extra_ideal_par2_t1 ~~ extra_ideal_par2_t1
extra_ideal_par3_t1 ~~ extra_ideal_par3_t1

extra_ideal_par1_t2 ~~ extra_ideal_par1_t2
extra_ideal_par2_t2 ~~ extra_ideal_par2_t2
extra_ideal_par3_t2 ~~ extra_ideal_par3_t2

# Latent Variable Means
extra_ideal1 ~ 0*1
extra_ideal2 ~ 1

# Latent Variable Variances and Covariance
extra_ideal1 ~~ 1*extra_ideal1
extra_ideal2 ~~ extra_ideal2
extra_ideal1 ~~ extra_ideal2
'
fit_configural_extra_ideal <- cfa(configural_extra_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                                  mimic = "mplus", missing="ML")
summary(fit_configural_extra_ideal, fit.measures = TRUE)

# Weak invariance model
weak_extra_ideal <- '
# Define the latent factors
extra_ideal1 =~ NA*extra_ideal_par1_t1 + lambda1*extra_ideal_par1_t1 + lambda2*extra_ideal_par2_t1 + lambda3*extra_ideal_par3_t1
extra_ideal2 =~ NA*extra_ideal_par1_t2 + lambda1*extra_ideal_par1_t2 + lambda2*extra_ideal_par2_t2 + lambda3*extra_ideal_par3_t2

# Intercepts
extra_ideal_par1_t1 ~ i1*1
extra_ideal_par2_t1 ~ 1
extra_ideal_par3_t1 ~ 1

extra_ideal_par1_t2 ~ i1*1
extra_ideal_par2_t2 ~ 1
extra_ideal_par3_t2 ~ 1

# Unique Variances
extra_ideal_par1_t1 ~~ extra_ideal_par1_t1
extra_ideal_par2_t1 ~~ extra_ideal_par2_t1
extra_ideal_par3_t1 ~~ extra_ideal_par3_t1

extra_ideal_par1_t2 ~~ extra_ideal_par1_t2
extra_ideal_par2_t2 ~~ extra_ideal_par2_t2
extra_ideal_par3_t2 ~~ extra_ideal_par3_t2

# Latent Variable Means
extra_ideal1 ~ 0*1
extra_ideal2 ~ 1

# Latent Variable Variances and Covariance
extra_ideal1 ~~ 1*extra_ideal1
extra_ideal2 ~~ extra_ideal2
extra_ideal1 ~~ extra_ideal2
'
fit_weak_extra_ideal <- cfa(weak_extra_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                            mimic = "mplus", missing="ML")
summary(fit_weak_extra_ideal, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_extra_ideal <- '
# Define the latent factors
extra_ideal1 =~ NA*extra_ideal_par1_t1 + lambda1*extra_ideal_par1_t1 + lambda2*extra_ideal_par2_t1 + lambda3*extra_ideal_par3_t1
extra_ideal2 =~ NA*extra_ideal_par1_t2 + lambda1*extra_ideal_par1_t2 + lambda2*extra_ideal_par2_t2 + lambda3*extra_ideal_par3_t2

# Intercepts
extra_ideal_par1_t1 ~ i1*1
extra_ideal_par2_t1 ~ i2*1
extra_ideal_par3_t1 ~ i3*1

extra_ideal_par1_t2 ~ i1*1
extra_ideal_par2_t2 ~ i2*1
extra_ideal_par3_t2 ~ i3*1

# Unique Variances
extra_ideal_par1_t1 ~~ extra_ideal_par1_t1
extra_ideal_par2_t1 ~~ extra_ideal_par2_t1
extra_ideal_par3_t1 ~~ extra_ideal_par3_t1

extra_ideal_par1_t2 ~~ extra_ideal_par1_t2
extra_ideal_par2_t2 ~~ extra_ideal_par2_t2
extra_ideal_par3_t2 ~~ extra_ideal_par3_t2

# Latent Variable Means
extra_ideal1 ~ 0*1
extra_ideal2 ~ 1

# Latent Variable Variances and Covariance
extra_ideal1 ~~ 1*extra_ideal1
extra_ideal2 ~~ extra_ideal2
extra_ideal1 ~~ extra_ideal2
'
fit_strong_extra_ideal <- cfa(strong_extra_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                              mimic = "mplus", missing="ML")
summary(fit_strong_extra_ideal, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_extra_ideal <- '
# Define the latent factors
extra_ideal1 =~ NA*extra_ideal_par1_t1 + lambda1*extra_ideal_par1_t1 + lambda2*extra_ideal_par2_t1 + lambda3*extra_ideal_par3_t1
extra_ideal2 =~ NA*extra_ideal_par1_t2 + lambda1*extra_ideal_par1_t2 + lambda2*extra_ideal_par2_t2 + lambda3*extra_ideal_par3_t2

# Intercepts
extra_ideal_par1_t1 ~ i1*1
extra_ideal_par2_t1 ~ i2*1
extra_ideal_par3_t1 ~ i3*1

extra_ideal_par1_t2 ~ i1*1
extra_ideal_par2_t2 ~ i2*1
extra_ideal_par3_t2 ~ i3*1

# Unique Variances
extra_ideal_par1_t1 ~~ u1*extra_ideal_par1_t1
extra_ideal_par2_t1 ~~ u2*extra_ideal_par2_t1
extra_ideal_par3_t1 ~~ u3*extra_ideal_par3_t1

extra_ideal_par1_t2 ~~ u1*extra_ideal_par1_t2
extra_ideal_par2_t2 ~~ u2*extra_ideal_par2_t2
extra_ideal_par3_t2 ~~ u3*extra_ideal_par3_t2

# Latent Variable Means
extra_ideal1 ~ 0*1
extra_ideal2 ~ 1

# Latent Variable Variances and Covariance
extra_ideal1 ~~ 1*extra_ideal1
extra_ideal2 ~~ extra_ideal2
extra_ideal1 ~~ extra_ideal2
'
fit_strict_extra_ideal <- cfa(strict_extra_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                              mimic = "mplus", missing="ML")
summary(fit_strict_extra_ideal, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_extra_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_extra_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_extra_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_extra_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_extra_ideal, fit_weak_extra_ideal)

anova(fit_weak_extra_ideal, fit_strong_extra_ideal)

anova(fit_strong_extra_ideal, fit_strict_extra_ideal)
```

::: {.callout-note appearance="minimal"}
Satisfactory model fit across all stages of measurement invariance (except for RMSEA). Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Agreeableness: current personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_agree_curr <- '
# Define the latent factors
agree_curr1 =~ NA*agree_curr_par1_t1 + lambda1*agree_curr_par1_t1 + agree_curr_par2_t1 + agree_curr_par3_t1
agree_curr2 =~ NA*agree_curr_par1_t2 + lambda1*agree_curr_par1_t2 + agree_curr_par2_t2 + agree_curr_par3_t2

# Intercepts
agree_curr_par1_t1 ~ i1*1
agree_curr_par2_t1 ~ 1
agree_curr_par3_t1 ~ 1

agree_curr_par1_t2 ~ i1*1
agree_curr_par2_t2 ~ 1
agree_curr_par3_t2 ~ 1

# Unique Variances
agree_curr_par1_t1 ~~ agree_curr_par1_t1
agree_curr_par2_t1 ~~ agree_curr_par2_t1
agree_curr_par3_t1 ~~ agree_curr_par3_t1

agree_curr_par1_t2 ~~ agree_curr_par1_t2
agree_curr_par2_t2 ~~ agree_curr_par2_t2
agree_curr_par3_t2 ~~ agree_curr_par3_t2

# Latent Variable Means
agree_curr1 ~ 0*1
agree_curr2 ~ 1

# Latent Variable Variances and Covariance
agree_curr1 ~~ 1*agree_curr1
agree_curr2 ~~ agree_curr2
agree_curr1 ~~ agree_curr2
'
fit_configural_agree_curr <- cfa(configural_agree_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_configural_agree_curr, fit.measures = TRUE)

# Weak invariance model
weak_agree_curr <- '
# Define the latent factors
agree_curr1 =~ NA*agree_curr_par1_t1 + lambda1*agree_curr_par1_t1 + lambda2*agree_curr_par2_t1 + lambda3*agree_curr_par3_t1
agree_curr2 =~ NA*agree_curr_par1_t2 + lambda1*agree_curr_par1_t2 + lambda2*agree_curr_par2_t2 + lambda3*agree_curr_par3_t2

# Intercepts
agree_curr_par1_t1 ~ i1*1
agree_curr_par2_t1 ~ 1
agree_curr_par3_t1 ~ 1

agree_curr_par1_t2 ~ i1*1
agree_curr_par2_t2 ~ 1
agree_curr_par3_t2 ~ 1

# Unique Variances
agree_curr_par1_t1 ~~ agree_curr_par1_t1
agree_curr_par2_t1 ~~ agree_curr_par2_t1
agree_curr_par3_t1 ~~ agree_curr_par3_t1

agree_curr_par1_t2 ~~ agree_curr_par1_t2
agree_curr_par2_t2 ~~ agree_curr_par2_t2
agree_curr_par3_t2 ~~ agree_curr_par3_t2

# Latent Variable Means
agree_curr1 ~ 0*1
agree_curr2 ~ 1

# Latent Variable Variances and Covariance
agree_curr1 ~~ 1*agree_curr1
agree_curr2 ~~ agree_curr2
agree_curr1 ~~ agree_curr2
'
fit_weak_agree_curr <- cfa(weak_agree_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_weak_agree_curr, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_agree_curr <- '
# Define the latent factors
agree_curr1 =~ NA*agree_curr_par1_t1 + lambda1*agree_curr_par1_t1 + lambda2*agree_curr_par2_t1 + lambda3*agree_curr_par3_t1
agree_curr2 =~ NA*agree_curr_par1_t2 + lambda1*agree_curr_par1_t2 + lambda2*agree_curr_par2_t2 + lambda3*agree_curr_par3_t2

# Intercepts
agree_curr_par1_t1 ~ i1*1
agree_curr_par2_t1 ~ i2*1
agree_curr_par3_t1 ~ i3*1

agree_curr_par1_t2 ~ i1*1
agree_curr_par2_t2 ~ i2*1
agree_curr_par3_t2 ~ i3*1

# Unique Variances
agree_curr_par1_t1 ~~ agree_curr_par1_t1
agree_curr_par2_t1 ~~ agree_curr_par2_t1
agree_curr_par3_t1 ~~ agree_curr_par3_t1

agree_curr_par1_t2 ~~ agree_curr_par1_t2
agree_curr_par2_t2 ~~ agree_curr_par2_t2
agree_curr_par3_t2 ~~ agree_curr_par3_t2

# Latent Variable Means
agree_curr1 ~ 0*1
agree_curr2 ~ 1

# Latent Variable Variances and Covariance
agree_curr1 ~~ 1*agree_curr1
agree_curr2 ~~ agree_curr2
agree_curr1 ~~ agree_curr2
'
fit_strong_agree_curr <- cfa(strong_agree_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strong_agree_curr, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_agree_curr <- '
# Define the latent factors
agree_curr1 =~ NA*agree_curr_par1_t1 + lambda1*agree_curr_par1_t1 + lambda2*agree_curr_par2_t1 + lambda3*agree_curr_par3_t1
agree_curr2 =~ NA*agree_curr_par1_t2 + lambda1*agree_curr_par1_t2 + lambda2*agree_curr_par2_t2 + lambda3*agree_curr_par3_t2

# Intercepts
agree_curr_par1_t1 ~ i1*1
agree_curr_par2_t1 ~ i2*1
agree_curr_par3_t1 ~ i3*1

agree_curr_par1_t2 ~ i1*1
agree_curr_par2_t2 ~ i2*1
agree_curr_par3_t2 ~ i3*1

# Unique Variances
agree_curr_par1_t1 ~~ u1*agree_curr_par1_t1
agree_curr_par2_t1 ~~ u2*agree_curr_par2_t1
agree_curr_par3_t1 ~~ u3*agree_curr_par3_t1

agree_curr_par1_t2 ~~ u1*agree_curr_par1_t2
agree_curr_par2_t2 ~~ u2*agree_curr_par2_t2
agree_curr_par3_t2 ~~ u3*agree_curr_par3_t2

# Latent Variable Means
agree_curr1 ~ 0*1
agree_curr2 ~ 1

# Latent Variable Variances and Covariance
agree_curr1 ~~ 1*agree_curr1
agree_curr2 ~~ agree_curr2
agree_curr1 ~~ agree_curr2
'
fit_strict_agree_curr <- cfa(strict_agree_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strict_agree_curr, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_agree_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_agree_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_agree_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_agree_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_agree_curr, fit_weak_agree_curr)

anova(fit_weak_agree_curr, fit_strong_agree_curr)

anova(fit_strong_agree_curr, fit_strict_agree_curr)
```

::: {.callout-note appearance="minimal"}
Model fit still not satisfactory. Chi^2 tests indicate that strong measurement invariance is given (at *p* < .05; strict at *p* < .01).
:::

#### Agreeableness: ideal personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_agree_ideal <- '
# Define the latent factors
agree_ideal1 =~ NA*agree_ideal_par1_t1 + lambda1*agree_ideal_par1_t1 + agree_ideal_par2_t1 + agree_ideal_par3_t1
agree_ideal2 =~ NA*agree_ideal_par1_t2 + lambda1*agree_ideal_par1_t2 + agree_ideal_par2_t2 + agree_ideal_par3_t2

# Intercepts
agree_ideal_par1_t1 ~ i1*1
agree_ideal_par2_t1 ~ 1
agree_ideal_par3_t1 ~ 1

agree_ideal_par1_t2 ~ i1*1
agree_ideal_par2_t2 ~ 1
agree_ideal_par3_t2 ~ 1

# Unique Variances
agree_ideal_par1_t1 ~~ agree_ideal_par1_t1
agree_ideal_par2_t1 ~~ agree_ideal_par2_t1
agree_ideal_par3_t1 ~~ agree_ideal_par3_t1

agree_ideal_par1_t2 ~~ agree_ideal_par1_t2
agree_ideal_par2_t2 ~~ agree_ideal_par2_t2
agree_ideal_par3_t2 ~~ agree_ideal_par3_t2

# Latent Variable Means
agree_ideal1 ~ 0*1
agree_ideal2 ~ 1

# Latent Variable Variances and Covariance
agree_ideal1 ~~ 1*agree_ideal1
agree_ideal2 ~~ agree_ideal2
agree_ideal1 ~~ agree_ideal2
'
fit_configural_agree_ideal <- cfa(configural_agree_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), 
                                  mimic = "mplus", missing="ML")
summary(fit_configural_agree_ideal, fit.measures = TRUE)

# Weak invariance model
weak_agree_ideal <- '
# Define the latent factors
agree_ideal1 =~ NA*agree_ideal_par1_t1 + lambda1*agree_ideal_par1_t1 + lambda2*agree_ideal_par2_t1 + lambda3*agree_ideal_par3_t1
agree_ideal2 =~ NA*agree_ideal_par1_t2 + lambda1*agree_ideal_par1_t2 + lambda2*agree_ideal_par2_t2 + lambda3*agree_ideal_par3_t2

# Intercepts
agree_ideal_par1_t1 ~ i1*1
agree_ideal_par2_t1 ~ 1
agree_ideal_par3_t1 ~ 1

agree_ideal_par1_t2 ~ i1*1
agree_ideal_par2_t2 ~ 1
agree_ideal_par3_t2 ~ 1

# Unique Variances
agree_ideal_par1_t1 ~~ agree_ideal_par1_t1
agree_ideal_par2_t1 ~~ agree_ideal_par2_t1
agree_ideal_par3_t1 ~~ agree_ideal_par3_t1

agree_ideal_par1_t2 ~~ agree_ideal_par1_t2
agree_ideal_par2_t2 ~~ agree_ideal_par2_t2
agree_ideal_par3_t2 ~~ agree_ideal_par3_t2

# Latent Variable Means
agree_ideal1 ~ 0*1
agree_ideal2 ~ 1

# Latent Variable Variances and Covariance
agree_ideal1 ~~ 1*agree_ideal1
agree_ideal2 ~~ agree_ideal2
agree_ideal1 ~~ agree_ideal2
'
fit_weak_agree_ideal <- cfa(weak_agree_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_weak_agree_ideal, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_agree_ideal <- '
# Define the latent factors
agree_ideal1 =~ NA*agree_ideal_par1_t1 + lambda1*agree_ideal_par1_t1 + lambda2*agree_ideal_par2_t1 + lambda3*agree_ideal_par3_t1
agree_ideal2 =~ NA*agree_ideal_par1_t2 + lambda1*agree_ideal_par1_t2 + lambda2*agree_ideal_par2_t2 + lambda3*agree_ideal_par3_t2

# Intercepts
agree_ideal_par1_t1 ~ i1*1
agree_ideal_par2_t1 ~ i2*1
agree_ideal_par3_t1 ~ i3*1

agree_ideal_par1_t2 ~ i1*1
agree_ideal_par2_t2 ~ i2*1
agree_ideal_par3_t2 ~ i3*1

# Unique Variances
agree_ideal_par1_t1 ~~ agree_ideal_par1_t1
agree_ideal_par2_t1 ~~ agree_ideal_par2_t1
agree_ideal_par3_t1 ~~ agree_ideal_par3_t1

agree_ideal_par1_t2 ~~ agree_ideal_par1_t2
agree_ideal_par2_t2 ~~ agree_ideal_par2_t2
agree_ideal_par3_t2 ~~ agree_ideal_par3_t2

# Latent Variable Means
agree_ideal1 ~ 0*1
agree_ideal2 ~ 1

# Latent Variable Variances and Covariance
agree_ideal1 ~~ 1*agree_ideal1
agree_ideal2 ~~ agree_ideal2
agree_ideal1 ~~ agree_ideal2
'
fit_strong_agree_ideal <- cfa(strong_agree_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strong_agree_ideal, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_agree_ideal <- '
# Define the latent factors
agree_ideal1 =~ NA*agree_ideal_par1_t1 + lambda1*agree_ideal_par1_t1 + lambda2*agree_ideal_par2_t1 + lambda3*agree_ideal_par3_t1
agree_ideal2 =~ NA*agree_ideal_par1_t2 + lambda1*agree_ideal_par1_t2 + lambda2*agree_ideal_par2_t2 + lambda3*agree_ideal_par3_t2

# Intercepts
agree_ideal_par1_t1 ~ i1*1
agree_ideal_par2_t1 ~ i2*1
agree_ideal_par3_t1 ~ i3*1

agree_ideal_par1_t2 ~ i1*1
agree_ideal_par2_t2 ~ i2*1
agree_ideal_par3_t2 ~ i3*1

# Unique Variances
agree_ideal_par1_t1 ~~ u1*agree_ideal_par1_t1
agree_ideal_par2_t1 ~~ u2*agree_ideal_par2_t1
agree_ideal_par3_t1 ~~ u3*agree_ideal_par3_t1

agree_ideal_par1_t2 ~~ u1*agree_ideal_par1_t2
agree_ideal_par2_t2 ~~ u2*agree_ideal_par2_t2
agree_ideal_par3_t2 ~~ u3*agree_ideal_par3_t2

# Latent Variable Means
agree_ideal1 ~ 0*1
agree_ideal2 ~ 1

# Latent Variable Variances and Covariance
agree_ideal1 ~~ 1*agree_ideal1
agree_ideal2 ~~ agree_ideal2
agree_ideal1 ~~ agree_ideal2
'
fit_strict_agree_ideal <- cfa(strict_agree_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strict_agree_ideal, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_agree_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_agree_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_agree_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_agree_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_agree_ideal, fit_weak_agree_ideal)

anova(fit_weak_agree_ideal, fit_strong_agree_ideal)

anova(fit_strong_agree_ideal, fit_strict_agree_ideal)
```

::: {.callout-note appearance="minimal"}
Good model fit across all stages of measurement invariance (except for RMSEA). Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Conscientiousness: current personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_consc_curr <- '
# Define the latent factors
consc_curr1 =~ NA*consc_curr_par1_t1 + lambda1*consc_curr_par1_t1 + consc_curr_par2_t1 + consc_curr_par3_t1
consc_curr2 =~ NA*consc_curr_par1_t2 + lambda1*consc_curr_par1_t2 + consc_curr_par2_t2 + consc_curr_par3_t2

# Intercepts
consc_curr_par1_t1 ~ i1*1
consc_curr_par2_t1 ~ 1
consc_curr_par3_t1 ~ 1

consc_curr_par1_t2 ~ i1*1
consc_curr_par2_t2 ~ 1
consc_curr_par3_t2 ~ 1

# Unique Variances
consc_curr_par1_t1 ~~ consc_curr_par1_t1
consc_curr_par2_t1 ~~ consc_curr_par2_t1
consc_curr_par3_t1 ~~ consc_curr_par3_t1

consc_curr_par1_t2 ~~ consc_curr_par1_t2
consc_curr_par2_t2 ~~ consc_curr_par2_t2
consc_curr_par3_t2 ~~ consc_curr_par3_t2

# Latent Variable Means
consc_curr1 ~ 0*1
consc_curr2 ~ 1

# Latent Variable Variances and Covariance
consc_curr1 ~~ 1*consc_curr1
consc_curr2 ~~ consc_curr2
consc_curr1 ~~ consc_curr2
'
fit_configural_consc_curr <- cfa(configural_consc_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_configural_consc_curr, fit.measures = TRUE)

# Weak invariance model
weak_consc_curr <- '
# Define the latent factors
consc_curr1 =~ NA*consc_curr_par1_t1 + lambda1*consc_curr_par1_t1 + lambda2*consc_curr_par2_t1 + lambda3*consc_curr_par3_t1
consc_curr2 =~ NA*consc_curr_par1_t2 + lambda1*consc_curr_par1_t2 + lambda2*consc_curr_par2_t2 + lambda3*consc_curr_par3_t2

# Intercepts
consc_curr_par1_t1 ~ i1*1
consc_curr_par2_t1 ~ 1
consc_curr_par3_t1 ~ 1

consc_curr_par1_t2 ~ i1*1
consc_curr_par2_t2 ~ 1
consc_curr_par3_t2 ~ 1

# Unique Variances
consc_curr_par1_t1 ~~ consc_curr_par1_t1
consc_curr_par2_t1 ~~ consc_curr_par2_t1
consc_curr_par3_t1 ~~ consc_curr_par3_t1

consc_curr_par1_t2 ~~ consc_curr_par1_t2
consc_curr_par2_t2 ~~ consc_curr_par2_t2
consc_curr_par3_t2 ~~ consc_curr_par3_t2

# Latent Variable Means
consc_curr1 ~ 0*1
consc_curr2 ~ 1

# Latent Variable Variances and Covariance
consc_curr1 ~~ 1*consc_curr1
consc_curr2 ~~ consc_curr2
consc_curr1 ~~ consc_curr2
'
fit_weak_consc_curr <- cfa(weak_consc_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_weak_consc_curr, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_consc_curr <- '
# Define the latent factors
consc_curr1 =~ NA*consc_curr_par1_t1 + lambda1*consc_curr_par1_t1 + lambda2*consc_curr_par2_t1 + lambda3*consc_curr_par3_t1
consc_curr2 =~ NA*consc_curr_par1_t2 + lambda1*consc_curr_par1_t2 + lambda2*consc_curr_par2_t2 + lambda3*consc_curr_par3_t2

# Intercepts
consc_curr_par1_t1 ~ i1*1
consc_curr_par2_t1 ~ i2*1
consc_curr_par3_t1 ~ i3*1

consc_curr_par1_t2 ~ i1*1
consc_curr_par2_t2 ~ i2*1
consc_curr_par3_t2 ~ i3*1

# Unique Variances
consc_curr_par1_t1 ~~ consc_curr_par1_t1
consc_curr_par2_t1 ~~ consc_curr_par2_t1
consc_curr_par3_t1 ~~ consc_curr_par3_t1

consc_curr_par1_t2 ~~ consc_curr_par1_t2
consc_curr_par2_t2 ~~ consc_curr_par2_t2
consc_curr_par3_t2 ~~ consc_curr_par3_t2

# Latent Variable Means
consc_curr1 ~ 0*1
consc_curr2 ~ 1

# Latent Variable Variances and Covariance
consc_curr1 ~~ 1*consc_curr1
consc_curr2 ~~ consc_curr2
consc_curr1 ~~ consc_curr2
'
fit_strong_consc_curr <- cfa(strong_consc_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strong_consc_curr, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_consc_curr <- '
# Define the latent factors
consc_curr1 =~ NA*consc_curr_par1_t1 + lambda1*consc_curr_par1_t1 + lambda2*consc_curr_par2_t1 + lambda3*consc_curr_par3_t1
consc_curr2 =~ NA*consc_curr_par1_t2 + lambda1*consc_curr_par1_t2 + lambda2*consc_curr_par2_t2 + lambda3*consc_curr_par3_t2

# Intercepts
consc_curr_par1_t1 ~ i1*1
consc_curr_par2_t1 ~ i2*1
consc_curr_par3_t1 ~ i3*1

consc_curr_par1_t2 ~ i1*1
consc_curr_par2_t2 ~ i2*1
consc_curr_par3_t2 ~ i3*1

# Unique Variances
consc_curr_par1_t1 ~~ u1*consc_curr_par1_t1
consc_curr_par2_t1 ~~ u2*consc_curr_par2_t1
consc_curr_par3_t1 ~~ u3*consc_curr_par3_t1

consc_curr_par1_t2 ~~ u1*consc_curr_par1_t2
consc_curr_par2_t2 ~~ u2*consc_curr_par2_t2
consc_curr_par3_t2 ~~ u3*consc_curr_par3_t2

# Latent Variable Means
consc_curr1 ~ 0*1
consc_curr2 ~ 1

# Latent Variable Variances and Covariance
consc_curr1 ~~ 1*consc_curr1
consc_curr2 ~~ consc_curr2
consc_curr1 ~~ consc_curr2
'
fit_strict_consc_curr <- cfa(strict_consc_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strict_consc_curr, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_consc_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_consc_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_consc_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_consc_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_consc_curr, fit_weak_consc_curr)

anova(fit_weak_consc_curr, fit_strong_consc_curr)

anova(fit_strong_consc_curr, fit_strict_consc_curr)
```

::: {.callout-note appearance="minimal"}
Good model fit across all stages of measurement invariance (except for RMSEA). Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Conscientiousness: ideal personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_consc_ideal <- '
# Define the latent factors
consc_ideal1 =~ NA*consc_ideal_par1_t1 + lambda1*consc_ideal_par1_t1 + consc_ideal_par2_t1 + consc_ideal_par3_t1
consc_ideal2 =~ NA*consc_ideal_par1_t2 + lambda1*consc_ideal_par1_t2 + consc_ideal_par2_t2 + consc_ideal_par3_t2

# Intercepts
consc_ideal_par1_t1 ~ i1*1
consc_ideal_par2_t1 ~ 1
consc_ideal_par3_t1 ~ 1

consc_ideal_par1_t2 ~ i1*1
consc_ideal_par2_t2 ~ 1
consc_ideal_par3_t2 ~ 1

# Unique Variances
consc_ideal_par1_t1 ~~ consc_ideal_par1_t1
consc_ideal_par2_t1 ~~ consc_ideal_par2_t1
consc_ideal_par3_t1 ~~ consc_ideal_par3_t1

consc_ideal_par1_t2 ~~ consc_ideal_par1_t2
consc_ideal_par2_t2 ~~ consc_ideal_par2_t2
consc_ideal_par3_t2 ~~ consc_ideal_par3_t2

# Latent Variable Means
consc_ideal1 ~ 0*1
consc_ideal2 ~ 1

# Latent Variable Variances and Covariance
consc_ideal1 ~~ 1*consc_ideal1
consc_ideal2 ~~ consc_ideal2
consc_ideal1 ~~ consc_ideal2
'
fit_configural_consc_ideal <- cfa(configural_consc_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_configural_consc_ideal, fit.measures = TRUE)

# Weak invariance model
weak_consc_ideal <- '
# Define the latent factors
consc_ideal1 =~ NA*consc_ideal_par1_t1 + lambda1*consc_ideal_par1_t1 + lambda2*consc_ideal_par2_t1 + lambda3*consc_ideal_par3_t1
consc_ideal2 =~ NA*consc_ideal_par1_t2 + lambda1*consc_ideal_par1_t2 + lambda2*consc_ideal_par2_t2 + lambda3*consc_ideal_par3_t2

# Intercepts
consc_ideal_par1_t1 ~ i1*1
consc_ideal_par2_t1 ~ 1
consc_ideal_par3_t1 ~ 1

consc_ideal_par1_t2 ~ i1*1
consc_ideal_par2_t2 ~ 1
consc_ideal_par3_t2 ~ 1

# Unique Variances
consc_ideal_par1_t1 ~~ consc_ideal_par1_t1
consc_ideal_par2_t1 ~~ consc_ideal_par2_t1
consc_ideal_par3_t1 ~~ consc_ideal_par3_t1

consc_ideal_par1_t2 ~~ consc_ideal_par1_t2
consc_ideal_par2_t2 ~~ consc_ideal_par2_t2
consc_ideal_par3_t2 ~~ consc_ideal_par3_t2

# Latent Variable Means
consc_ideal1 ~ 0*1
consc_ideal2 ~ 1

# Latent Variable Variances and Covariance
consc_ideal1 ~~ 1*consc_ideal1
consc_ideal2 ~~ consc_ideal2
consc_ideal1 ~~ consc_ideal2
'
fit_weak_consc_ideal <- cfa(weak_consc_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_weak_consc_ideal, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_consc_ideal <- '
# Define the latent factors
consc_ideal1 =~ NA*consc_ideal_par1_t1 + lambda1*consc_ideal_par1_t1 + lambda2*consc_ideal_par2_t1 + lambda3*consc_ideal_par3_t1
consc_ideal2 =~ NA*consc_ideal_par1_t2 + lambda1*consc_ideal_par1_t2 + lambda2*consc_ideal_par2_t2 + lambda3*consc_ideal_par3_t2

# Intercepts
consc_ideal_par1_t1 ~ i1*1
consc_ideal_par2_t1 ~ i2*1
consc_ideal_par3_t1 ~ i3*1

consc_ideal_par1_t2 ~ i1*1
consc_ideal_par2_t2 ~ i2*1
consc_ideal_par3_t2 ~ i3*1

# Unique Variances
consc_ideal_par1_t1 ~~ consc_ideal_par1_t1
consc_ideal_par2_t1 ~~ consc_ideal_par2_t1
consc_ideal_par3_t1 ~~ consc_ideal_par3_t1

consc_ideal_par1_t2 ~~ consc_ideal_par1_t2
consc_ideal_par2_t2 ~~ consc_ideal_par2_t2
consc_ideal_par3_t2 ~~ consc_ideal_par3_t2

# Latent Variable Means
consc_ideal1 ~ 0*1
consc_ideal2 ~ 1

# Latent Variable Variances and Covariance
consc_ideal1 ~~ 1*consc_ideal1
consc_ideal2 ~~ consc_ideal2
consc_ideal1 ~~ consc_ideal2
'
fit_strong_consc_ideal <- cfa(strong_consc_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strong_consc_ideal, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_consc_ideal <- '
# Define the latent factors
consc_ideal1 =~ NA*consc_ideal_par1_t1 + lambda1*consc_ideal_par1_t1 + lambda2*consc_ideal_par2_t1 + lambda3*consc_ideal_par3_t1
consc_ideal2 =~ NA*consc_ideal_par1_t2 + lambda1*consc_ideal_par1_t2 + lambda2*consc_ideal_par2_t2 + lambda3*consc_ideal_par3_t2

# Intercepts
consc_ideal_par1_t1 ~ i1*1
consc_ideal_par2_t1 ~ i2*1
consc_ideal_par3_t1 ~ i3*1

consc_ideal_par1_t2 ~ i1*1
consc_ideal_par2_t2 ~ i2*1
consc_ideal_par3_t2 ~ i3*1

# Unique Variances
consc_ideal_par1_t1 ~~ u1*consc_ideal_par1_t1
consc_ideal_par2_t1 ~~ u2*consc_ideal_par2_t1
consc_ideal_par3_t1 ~~ u3*consc_ideal_par3_t1

consc_ideal_par1_t2 ~~ u1*consc_ideal_par1_t2
consc_ideal_par2_t2 ~~ u2*consc_ideal_par2_t2
consc_ideal_par3_t2 ~~ u3*consc_ideal_par3_t2

# Latent Variable Means
consc_ideal1 ~ 0*1
consc_ideal2 ~ 1

# Latent Variable Variances and Covariance
consc_ideal1 ~~ 1*consc_ideal1
consc_ideal2 ~~ consc_ideal2
consc_ideal1 ~~ consc_ideal2
'
fit_strict_consc_ideal <- cfa(strict_consc_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strict_consc_ideal, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_consc_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_consc_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_consc_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_consc_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_consc_ideal, fit_weak_consc_ideal)

anova(fit_weak_consc_ideal, fit_strong_consc_ideal)

anova(fit_strong_consc_ideal, fit_strict_consc_ideal)
```

::: {.callout-note appearance="minimal"}
Good model fit across all stages of measurement invariance. Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Neuroticism: current personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_neuro_curr <- '
# Define the latent factors
neuro_curr1 =~ NA*neuro_curr_par1_t1 + lambda1*neuro_curr_par1_t1 + neuro_curr_par2_t1 + neuro_curr_par3_t1
neuro_curr2 =~ NA*neuro_curr_par1_t2 + lambda1*neuro_curr_par1_t2 + neuro_curr_par2_t2 + neuro_curr_par3_t2

# Intercepts
neuro_curr_par1_t1 ~ i1*1
neuro_curr_par2_t1 ~ 1
neuro_curr_par3_t1 ~ 1

neuro_curr_par1_t2 ~ i1*1
neuro_curr_par2_t2 ~ 1
neuro_curr_par3_t2 ~ 1

# Unique Variances
neuro_curr_par1_t1 ~~ neuro_curr_par1_t1
neuro_curr_par2_t1 ~~ neuro_curr_par2_t1
neuro_curr_par3_t1 ~~ neuro_curr_par3_t1

neuro_curr_par1_t2 ~~ neuro_curr_par1_t2
neuro_curr_par2_t2 ~~ neuro_curr_par2_t2
neuro_curr_par3_t2 ~~ neuro_curr_par3_t2

# Latent Variable Means
neuro_curr1 ~ 0*1
neuro_curr2 ~ 1

# Latent Variable Variances and Covariance
neuro_curr1 ~~ 1*neuro_curr1
neuro_curr2 ~~ neuro_curr2
neuro_curr1 ~~ neuro_curr2
'
fit_configural_neuro_curr <- cfa(configural_neuro_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_configural_neuro_curr, fit.measures = TRUE)

# Weak invariance model
weak_neuro_curr <- '
# Define the latent factors
neuro_curr1 =~ NA*neuro_curr_par1_t1 + lambda1*neuro_curr_par1_t1 + lambda2*neuro_curr_par2_t1 + lambda3*neuro_curr_par3_t1
neuro_curr2 =~ NA*neuro_curr_par1_t2 + lambda1*neuro_curr_par1_t2 + lambda2*neuro_curr_par2_t2 + lambda3*neuro_curr_par3_t2

# Intercepts
neuro_curr_par1_t1 ~ i1*1
neuro_curr_par2_t1 ~ 1
neuro_curr_par3_t1 ~ 1

neuro_curr_par1_t2 ~ i1*1
neuro_curr_par2_t2 ~ 1
neuro_curr_par3_t2 ~ 1

# Unique Variances
neuro_curr_par1_t1 ~~ neuro_curr_par1_t1
neuro_curr_par2_t1 ~~ neuro_curr_par2_t1
neuro_curr_par3_t1 ~~ neuro_curr_par3_t1

neuro_curr_par1_t2 ~~ neuro_curr_par1_t2
neuro_curr_par2_t2 ~~ neuro_curr_par2_t2
neuro_curr_par3_t2 ~~ neuro_curr_par3_t2

# Latent Variable Means
neuro_curr1 ~ 0*1
neuro_curr2 ~ 1

# Latent Variable Variances and Covariance
neuro_curr1 ~~ 1*neuro_curr1
neuro_curr2 ~~ neuro_curr2
neuro_curr1 ~~ neuro_curr2
'
fit_weak_neuro_curr <- cfa(weak_neuro_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_weak_neuro_curr, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_neuro_curr <- '
# Define the latent factors
neuro_curr1 =~ NA*neuro_curr_par1_t1 + lambda1*neuro_curr_par1_t1 + lambda2*neuro_curr_par2_t1 + lambda3*neuro_curr_par3_t1
neuro_curr2 =~ NA*neuro_curr_par1_t2 + lambda1*neuro_curr_par1_t2 + lambda2*neuro_curr_par2_t2 + lambda3*neuro_curr_par3_t2

# Intercepts
neuro_curr_par1_t1 ~ i1*1
neuro_curr_par2_t1 ~ i2*1
neuro_curr_par3_t1 ~ i3*1

neuro_curr_par1_t2 ~ i1*1
neuro_curr_par2_t2 ~ i2*1
neuro_curr_par3_t2 ~ i3*1

# Unique Variances
neuro_curr_par1_t1 ~~ neuro_curr_par1_t1
neuro_curr_par2_t1 ~~ neuro_curr_par2_t1
neuro_curr_par3_t1 ~~ neuro_curr_par3_t1

neuro_curr_par1_t2 ~~ neuro_curr_par1_t2
neuro_curr_par2_t2 ~~ neuro_curr_par2_t2
neuro_curr_par3_t2 ~~ neuro_curr_par3_t2

# Latent Variable Means
neuro_curr1 ~ 0*1
neuro_curr2 ~ 1

# Latent Variable Variances and Covariance
neuro_curr1 ~~ 1*neuro_curr1
neuro_curr2 ~~ neuro_curr2
neuro_curr1 ~~ neuro_curr2
'
fit_strong_neuro_curr <- cfa(strong_neuro_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strong_neuro_curr, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_neuro_curr <- '
# Define the latent factors
neuro_curr1 =~ NA*neuro_curr_par1_t1 + lambda1*neuro_curr_par1_t1 + lambda2*neuro_curr_par2_t1 + lambda3*neuro_curr_par3_t1
neuro_curr2 =~ NA*neuro_curr_par1_t2 + lambda1*neuro_curr_par1_t2 + lambda2*neuro_curr_par2_t2 + lambda3*neuro_curr_par3_t2

# Intercepts
neuro_curr_par1_t1 ~ i1*1
neuro_curr_par2_t1 ~ i2*1
neuro_curr_par3_t1 ~ i3*1

neuro_curr_par1_t2 ~ i1*1
neuro_curr_par2_t2 ~ i2*1
neuro_curr_par3_t2 ~ i3*1

# Unique Variances
neuro_curr_par1_t1 ~~ u1*neuro_curr_par1_t1
neuro_curr_par2_t1 ~~ u2*neuro_curr_par2_t1
neuro_curr_par3_t1 ~~ u3*neuro_curr_par3_t1

neuro_curr_par1_t2 ~~ u1*neuro_curr_par1_t2
neuro_curr_par2_t2 ~~ u2*neuro_curr_par2_t2
neuro_curr_par3_t2 ~~ u3*neuro_curr_par3_t2

# Latent Variable Means
neuro_curr1 ~ 0*1
neuro_curr2 ~ 1

# Latent Variable Variances and Covariance
neuro_curr1 ~~ 1*neuro_curr1
neuro_curr2 ~~ neuro_curr2
neuro_curr1 ~~ neuro_curr2
'
fit_strict_neuro_curr <- cfa(strict_neuro_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strict_neuro_curr, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_neuro_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_neuro_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_neuro_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_neuro_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_neuro_curr, fit_weak_neuro_curr)

anova(fit_weak_neuro_curr, fit_strong_neuro_curr)

anova(fit_strong_neuro_curr, fit_strict_neuro_curr)
```

::: {.callout-note appearance="minimal"}
Good model fit across all stages of measurement invariance (except for RMSEA). Chi^2 tests indicate that weak measurement invariance is given (at *p* < .05; strict at *p* < .01).
:::

#### Neuroticism: ideal personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_neuro_ideal <- '
# Define the latent factors
neuro_ideal1 =~ NA*neuro_ideal_par1_t1 + lambda1*neuro_ideal_par1_t1 + neuro_ideal_par2_t1 + neuro_ideal_par3_t1
neuro_ideal2 =~ NA*neuro_ideal_par1_t2 + lambda1*neuro_ideal_par1_t2 + neuro_ideal_par2_t2 + neuro_ideal_par3_t2

# Intercepts
neuro_ideal_par1_t1 ~ i1*1
neuro_ideal_par2_t1 ~ 1
neuro_ideal_par3_t1 ~ 1

neuro_ideal_par1_t2 ~ i1*1
neuro_ideal_par2_t2 ~ 1
neuro_ideal_par3_t2 ~ 1

# Unique Variances
neuro_ideal_par1_t1 ~~ neuro_ideal_par1_t1
neuro_ideal_par2_t1 ~~ neuro_ideal_par2_t1
neuro_ideal_par3_t1 ~~ neuro_ideal_par3_t1

neuro_ideal_par1_t2 ~~ neuro_ideal_par1_t2
neuro_ideal_par2_t2 ~~ neuro_ideal_par2_t2
neuro_ideal_par3_t2 ~~ neuro_ideal_par3_t2

# Latent Variable Means
neuro_ideal1 ~ 0*1
neuro_ideal2 ~ 1

# Latent Variable Variances and Covariance
neuro_ideal1 ~~ 1*neuro_ideal1
neuro_ideal2 ~~ neuro_ideal2
neuro_ideal1 ~~ neuro_ideal2
'
fit_configural_neuro_ideal <- cfa(configural_neuro_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_configural_neuro_ideal, fit.measures = TRUE)

# Weak invariance model
weak_neuro_ideal <- '
# Define the latent factors
neuro_ideal1 =~ NA*neuro_ideal_par1_t1 + lambda1*neuro_ideal_par1_t1 + lambda2*neuro_ideal_par2_t1 + lambda3*neuro_ideal_par3_t1
neuro_ideal2 =~ NA*neuro_ideal_par1_t2 + lambda1*neuro_ideal_par1_t2 + lambda2*neuro_ideal_par2_t2 + lambda3*neuro_ideal_par3_t2

# Intercepts
neuro_ideal_par1_t1 ~ i1*1
neuro_ideal_par2_t1 ~ 1
neuro_ideal_par3_t1 ~ 1

neuro_ideal_par1_t2 ~ i1*1
neuro_ideal_par2_t2 ~ 1
neuro_ideal_par3_t2 ~ 1

# Unique Variances
neuro_ideal_par1_t1 ~~ neuro_ideal_par1_t1
neuro_ideal_par2_t1 ~~ neuro_ideal_par2_t1
neuro_ideal_par3_t1 ~~ neuro_ideal_par3_t1

neuro_ideal_par1_t2 ~~ neuro_ideal_par1_t2
neuro_ideal_par2_t2 ~~ neuro_ideal_par2_t2
neuro_ideal_par3_t2 ~~ neuro_ideal_par3_t2

# Latent Variable Means
neuro_ideal1 ~ 0*1
neuro_ideal2 ~ 1

# Latent Variable Variances and Covariance
neuro_ideal1 ~~ 1*neuro_ideal1
neuro_ideal2 ~~ neuro_ideal2
neuro_ideal1 ~~ neuro_ideal2
'
fit_weak_neuro_ideal <- cfa(weak_neuro_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_weak_neuro_ideal, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_neuro_ideal <- '
# Define the latent factors
neuro_ideal1 =~ NA*neuro_ideal_par1_t1 + lambda1*neuro_ideal_par1_t1 + lambda2*neuro_ideal_par2_t1 + lambda3*neuro_ideal_par3_t1
neuro_ideal2 =~ NA*neuro_ideal_par1_t2 + lambda1*neuro_ideal_par1_t2 + lambda2*neuro_ideal_par2_t2 + lambda3*neuro_ideal_par3_t2

# Intercepts
neuro_ideal_par1_t1 ~ i1*1
neuro_ideal_par2_t1 ~ i2*1
neuro_ideal_par3_t1 ~ i3*1

neuro_ideal_par1_t2 ~ i1*1
neuro_ideal_par2_t2 ~ i2*1
neuro_ideal_par3_t2 ~ i3*1

# Unique Variances
neuro_ideal_par1_t1 ~~ neuro_ideal_par1_t1
neuro_ideal_par2_t1 ~~ neuro_ideal_par2_t1
neuro_ideal_par3_t1 ~~ neuro_ideal_par3_t1

neuro_ideal_par1_t2 ~~ neuro_ideal_par1_t2
neuro_ideal_par2_t2 ~~ neuro_ideal_par2_t2
neuro_ideal_par3_t2 ~~ neuro_ideal_par3_t2

# Latent Variable Means
neuro_ideal1 ~ 0*1
neuro_ideal2 ~ 1

# Latent Variable Variances and Covariance
neuro_ideal1 ~~ 1*neuro_ideal1
neuro_ideal2 ~~ neuro_ideal2
neuro_ideal1 ~~ neuro_ideal2
'
fit_strong_neuro_ideal <- cfa(strong_neuro_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strong_neuro_ideal, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_neuro_ideal <- '
# Define the latent factors
neuro_ideal1 =~ NA*neuro_ideal_par1_t1 + lambda1*neuro_ideal_par1_t1 + lambda2*neuro_ideal_par2_t1 + lambda3*neuro_ideal_par3_t1
neuro_ideal2 =~ NA*neuro_ideal_par1_t2 + lambda1*neuro_ideal_par1_t2 + lambda2*neuro_ideal_par2_t2 + lambda3*neuro_ideal_par3_t2

# Intercepts
neuro_ideal_par1_t1 ~ i1*1
neuro_ideal_par2_t1 ~ i2*1
neuro_ideal_par3_t1 ~ i3*1

neuro_ideal_par1_t2 ~ i1*1
neuro_ideal_par2_t2 ~ i2*1
neuro_ideal_par3_t2 ~ i3*1

# Unique Variances
neuro_ideal_par1_t1 ~~ u1*neuro_ideal_par1_t1
neuro_ideal_par2_t1 ~~ u2*neuro_ideal_par2_t1
neuro_ideal_par3_t1 ~~ u3*neuro_ideal_par3_t1

neuro_ideal_par1_t2 ~~ u1*neuro_ideal_par1_t2
neuro_ideal_par2_t2 ~~ u2*neuro_ideal_par2_t2
neuro_ideal_par3_t2 ~~ u3*neuro_ideal_par3_t2

# Latent Variable Means
neuro_ideal1 ~ 0*1
neuro_ideal2 ~ 1

# Latent Variable Variances and Covariance
neuro_ideal1 ~~ 1*neuro_ideal1
neuro_ideal2 ~~ neuro_ideal2
neuro_ideal1 ~~ neuro_ideal2
'
fit_strict_neuro_ideal <- cfa(strict_neuro_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strict_neuro_ideal, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_neuro_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_neuro_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_neuro_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_neuro_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_neuro_ideal, fit_weak_neuro_ideal)

anova(fit_weak_neuro_ideal, fit_strong_neuro_ideal)

anova(fit_strong_neuro_ideal, fit_strict_neuro_ideal)
```

::: {.callout-note appearance="minimal"}
Good model fit across all stages of measurement invariance. Chi^2 tests indicate that weak measurement invariance is given (at *p* < .05; strict at *p* < .01).
:::

#### Openness: current personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_openn_curr <- '
# Define the latent factors
openn_curr1 =~ NA*openn_curr_par1_t1 + lambda1*openn_curr_par1_t1 + openn_curr_par2_t1 + openn_curr_par3_t1
openn_curr2 =~ NA*openn_curr_par1_t2 + lambda1*openn_curr_par1_t2 + openn_curr_par2_t2 + openn_curr_par3_t2

# Intercepts
openn_curr_par1_t1 ~ i1*1
openn_curr_par2_t1 ~ 1
openn_curr_par3_t1 ~ 1

openn_curr_par1_t2 ~ i1*1
openn_curr_par2_t2 ~ 1
openn_curr_par3_t2 ~ 1

# Unique Variances
openn_curr_par1_t1 ~~ openn_curr_par1_t1
openn_curr_par2_t1 ~~ openn_curr_par2_t1
openn_curr_par3_t1 ~~ openn_curr_par3_t1

openn_curr_par1_t2 ~~ openn_curr_par1_t2
openn_curr_par2_t2 ~~ openn_curr_par2_t2
openn_curr_par3_t2 ~~ openn_curr_par3_t2

# Latent Variable Means
openn_curr1 ~ 0*1
openn_curr2 ~ 1

# Latent Variable Variances and Covariance
openn_curr1 ~~ 1*openn_curr1
openn_curr2 ~~ openn_curr2
openn_curr1 ~~ openn_curr2
'
fit_configural_openn_curr <- cfa(configural_openn_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_configural_openn_curr, fit.measures = TRUE)

# Weak invariance model
weak_openn_curr <- '
# Define the latent factors
openn_curr1 =~ NA*openn_curr_par1_t1 + lambda1*openn_curr_par1_t1 + lambda2*openn_curr_par2_t1 + lambda3*openn_curr_par3_t1
openn_curr2 =~ NA*openn_curr_par1_t2 + lambda1*openn_curr_par1_t2 + lambda2*openn_curr_par2_t2 + lambda3*openn_curr_par3_t2

# Intercepts
openn_curr_par1_t1 ~ i1*1
openn_curr_par2_t1 ~ 1
openn_curr_par3_t1 ~ 1

openn_curr_par1_t2 ~ i1*1
openn_curr_par2_t2 ~ 1
openn_curr_par3_t2 ~ 1

# Unique Variances
openn_curr_par1_t1 ~~ openn_curr_par1_t1
openn_curr_par2_t1 ~~ openn_curr_par2_t1
openn_curr_par3_t1 ~~ openn_curr_par3_t1

openn_curr_par1_t2 ~~ openn_curr_par1_t2
openn_curr_par2_t2 ~~ openn_curr_par2_t2
openn_curr_par3_t2 ~~ openn_curr_par3_t2

# Latent Variable Means
openn_curr1 ~ 0*1
openn_curr2 ~ 1

# Latent Variable Variances and Covariance
openn_curr1 ~~ 1*openn_curr1
openn_curr2 ~~ openn_curr2
openn_curr1 ~~ openn_curr2
'
fit_weak_openn_curr <- cfa(weak_openn_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_weak_openn_curr, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_openn_curr <- '
# Define the latent factors
openn_curr1 =~ NA*openn_curr_par1_t1 + lambda1*openn_curr_par1_t1 + lambda2*openn_curr_par2_t1 + lambda3*openn_curr_par3_t1
openn_curr2 =~ NA*openn_curr_par1_t2 + lambda1*openn_curr_par1_t2 + lambda2*openn_curr_par2_t2 + lambda3*openn_curr_par3_t2

# Intercepts
openn_curr_par1_t1 ~ i1*1
openn_curr_par2_t1 ~ i2*1
openn_curr_par3_t1 ~ i3*1

openn_curr_par1_t2 ~ i1*1
openn_curr_par2_t2 ~ i2*1
openn_curr_par3_t2 ~ i3*1

# Unique Variances
openn_curr_par1_t1 ~~ openn_curr_par1_t1
openn_curr_par2_t1 ~~ openn_curr_par2_t1
openn_curr_par3_t1 ~~ openn_curr_par3_t1

openn_curr_par1_t2 ~~ openn_curr_par1_t2
openn_curr_par2_t2 ~~ openn_curr_par2_t2
openn_curr_par3_t2 ~~ openn_curr_par3_t2

# Latent Variable Means
openn_curr1 ~ 0*1
openn_curr2 ~ 1

# Latent Variable Variances and Covariance
openn_curr1 ~~ 1*openn_curr1
openn_curr2 ~~ openn_curr2
openn_curr1 ~~ openn_curr2
'
fit_strong_openn_curr <- cfa(strong_openn_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strong_openn_curr, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_openn_curr <- '
# Define the latent factors
openn_curr1 =~ NA*openn_curr_par1_t1 + lambda1*openn_curr_par1_t1 + lambda2*openn_curr_par2_t1 + lambda3*openn_curr_par3_t1
openn_curr2 =~ NA*openn_curr_par1_t2 + lambda1*openn_curr_par1_t2 + lambda2*openn_curr_par2_t2 + lambda3*openn_curr_par3_t2

# Intercepts
openn_curr_par1_t1 ~ i1*1
openn_curr_par2_t1 ~ i2*1
openn_curr_par3_t1 ~ i3*1

openn_curr_par1_t2 ~ i1*1
openn_curr_par2_t2 ~ i2*1
openn_curr_par3_t2 ~ i3*1

# Unique Variances
openn_curr_par1_t1 ~~ u1*openn_curr_par1_t1
openn_curr_par2_t1 ~~ u2*openn_curr_par2_t1
openn_curr_par3_t1 ~~ u3*openn_curr_par3_t1

openn_curr_par1_t2 ~~ u1*openn_curr_par1_t2
openn_curr_par2_t2 ~~ u2*openn_curr_par2_t2
openn_curr_par3_t2 ~~ u3*openn_curr_par3_t2

# Latent Variable Means
openn_curr1 ~ 0*1
openn_curr2 ~ 1

# Latent Variable Variances and Covariance
openn_curr1 ~~ 1*openn_curr1
openn_curr2 ~~ openn_curr2
openn_curr1 ~~ openn_curr2
'
fit_strict_openn_curr <- cfa(strict_openn_curr, data = df_sbsa3_wide_pers, mimic = "mplus", missing="ML")
summary(fit_strict_openn_curr, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_openn_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_openn_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_openn_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_openn_curr) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_openn_curr, fit_weak_openn_curr)

anova(fit_weak_openn_curr, fit_strong_openn_curr)

anova(fit_strong_openn_curr, fit_strict_openn_curr)
```

::: {.callout-note appearance="minimal"}
Model fit not satisfactory across all stages of measurement invariance. Chi^2 tests indicate that strict measurement invariance is given.
:::

#### Openness: ideal personality

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from https://quantdev.ssri.psu.edu/sites/qdev/files/LongitudinalMeasurementInvariance_2017_1108.html

# Configural invariance model
configural_openn_ideal <- '
# Define the latent factors
openn_ideal1 =~ NA*openn_ideal_par1_t1 + lambda1*openn_ideal_par1_t1 + openn_ideal_par2_t1 + openn_ideal_par3_t1
openn_ideal2 =~ NA*openn_ideal_par1_t2 + lambda1*openn_ideal_par1_t2 + openn_ideal_par2_t2 + openn_ideal_par3_t2

# Intercepts
openn_ideal_par1_t1 ~ i1*1
openn_ideal_par2_t1 ~ 1
openn_ideal_par3_t1 ~ 1

openn_ideal_par1_t2 ~ i1*1
openn_ideal_par2_t2 ~ 1
openn_ideal_par3_t2 ~ 1

# Unique Variances
openn_ideal_par1_t1 ~~ openn_ideal_par1_t1
openn_ideal_par2_t1 ~~ openn_ideal_par2_t1
openn_ideal_par3_t1 ~~ openn_ideal_par3_t1

openn_ideal_par1_t2 ~~ openn_ideal_par1_t2
openn_ideal_par2_t2 ~~ openn_ideal_par2_t2
openn_ideal_par3_t2 ~~ openn_ideal_par3_t2

# Latent Variable Means
openn_ideal1 ~ 0*1
openn_ideal2 ~ 1

# Latent Variable Variances and Covariance
openn_ideal1 ~~ 1*openn_ideal1
openn_ideal2 ~~ openn_ideal2
openn_ideal1 ~~ openn_ideal2
'
fit_configural_openn_ideal <- cfa(configural_openn_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_configural_openn_ideal, fit.measures = TRUE)

# Weak invariance model
weak_openn_ideal <- '
# Define the latent factors
openn_ideal1 =~ NA*openn_ideal_par1_t1 + lambda1*openn_ideal_par1_t1 + lambda2*openn_ideal_par2_t1 + lambda3*openn_ideal_par3_t1
openn_ideal2 =~ NA*openn_ideal_par1_t2 + lambda1*openn_ideal_par1_t2 + lambda2*openn_ideal_par2_t2 + lambda3*openn_ideal_par3_t2

# Intercepts
openn_ideal_par1_t1 ~ i1*1
openn_ideal_par2_t1 ~ 1
openn_ideal_par3_t1 ~ 1

openn_ideal_par1_t2 ~ i1*1
openn_ideal_par2_t2 ~ 1
openn_ideal_par3_t2 ~ 1

# Unique Variances
openn_ideal_par1_t1 ~~ openn_ideal_par1_t1
openn_ideal_par2_t1 ~~ openn_ideal_par2_t1
openn_ideal_par3_t1 ~~ openn_ideal_par3_t1

openn_ideal_par1_t2 ~~ openn_ideal_par1_t2
openn_ideal_par2_t2 ~~ openn_ideal_par2_t2
openn_ideal_par3_t2 ~~ openn_ideal_par3_t2

# Latent Variable Means
openn_ideal1 ~ 0*1
openn_ideal2 ~ 1

# Latent Variable Variances and Covariance
openn_ideal1 ~~ 1*openn_ideal1
openn_ideal2 ~~ openn_ideal2
openn_ideal1 ~~ openn_ideal2
'
fit_weak_openn_ideal <- cfa(weak_openn_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_weak_openn_ideal, fit.measures = TRUE)

# Strong invariance model (additional constraints on manifest intercepts)
strong_openn_ideal <- '
# Define the latent factors
openn_ideal1 =~ NA*openn_ideal_par1_t1 + lambda1*openn_ideal_par1_t1 + lambda2*openn_ideal_par2_t1 + lambda3*openn_ideal_par3_t1
openn_ideal2 =~ NA*openn_ideal_par1_t2 + lambda1*openn_ideal_par1_t2 + lambda2*openn_ideal_par2_t2 + lambda3*openn_ideal_par3_t2

# Intercepts
openn_ideal_par1_t1 ~ i1*1
openn_ideal_par2_t1 ~ i2*1
openn_ideal_par3_t1 ~ i3*1

openn_ideal_par1_t2 ~ i1*1
openn_ideal_par2_t2 ~ i2*1
openn_ideal_par3_t2 ~ i3*1

# Unique Variances
openn_ideal_par1_t1 ~~ openn_ideal_par1_t1
openn_ideal_par2_t1 ~~ openn_ideal_par2_t1
openn_ideal_par3_t1 ~~ openn_ideal_par3_t1

openn_ideal_par1_t2 ~~ openn_ideal_par1_t2
openn_ideal_par2_t2 ~~ openn_ideal_par2_t2
openn_ideal_par3_t2 ~~ openn_ideal_par3_t2

# Latent Variable Means
openn_ideal1 ~ 0*1
openn_ideal2 ~ 1

# Latent Variable Variances and Covariance
openn_ideal1 ~~ 1*openn_ideal1
openn_ideal2 ~~ openn_ideal2
openn_ideal1 ~~ openn_ideal2
'
fit_strong_openn_ideal <- cfa(strong_openn_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strong_openn_ideal, fit.measures = TRUE)

# Strict invariance model (additional constraints on manifest variances)
strict_openn_ideal <- '
# Define the latent factors
openn_ideal1 =~ NA*openn_ideal_par1_t1 + lambda1*openn_ideal_par1_t1 + lambda2*openn_ideal_par2_t1 + lambda3*openn_ideal_par3_t1
openn_ideal2 =~ NA*openn_ideal_par1_t2 + lambda1*openn_ideal_par1_t2 + lambda2*openn_ideal_par2_t2 + lambda3*openn_ideal_par3_t2

# Intercepts
openn_ideal_par1_t1 ~ i1*1
openn_ideal_par2_t1 ~ i2*1
openn_ideal_par3_t1 ~ i3*1

openn_ideal_par1_t2 ~ i1*1
openn_ideal_par2_t2 ~ i2*1
openn_ideal_par3_t2 ~ i3*1

# Unique Variances
openn_ideal_par1_t1 ~~ u1*openn_ideal_par1_t1
openn_ideal_par2_t1 ~~ u2*openn_ideal_par2_t1
openn_ideal_par3_t1 ~~ u3*openn_ideal_par3_t1

openn_ideal_par1_t2 ~~ u1*openn_ideal_par1_t2
openn_ideal_par2_t2 ~~ u2*openn_ideal_par2_t2
openn_ideal_par3_t2 ~~ u3*openn_ideal_par3_t2

# Latent Variable Means
openn_ideal1 ~ 0*1
openn_ideal2 ~ 1

# Latent Variable Variances and Covariance
openn_ideal1 ~~ 1*openn_ideal1
openn_ideal2 ~~ openn_ideal2
openn_ideal1 ~~ openn_ideal2
'
fit_strict_openn_ideal <- cfa(strict_openn_ideal, data = df_sbsa3_wide_pers %>% filter(group=="Group 1"), mimic = "mplus", missing="ML")
summary(fit_strict_openn_ideal, fit.measures = TRUE)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# compare model fit
bind_rows(broom::glance(fit_configural_openn_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_weak_openn_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strong_openn_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr),
          broom::glance(fit_strict_openn_ideal) %>% 
            select(nobs, npar, chisq, AIC, BIC, cfi, tli, rmsea, srmr)) %>% 
  mutate(model = c("configural", "weak", "strong", "strict")) %>% 
  select(model, everything())

# chi-square difference test for nested models 
anova(fit_configural_openn_ideal, fit_weak_openn_ideal)

anova(fit_weak_openn_ideal, fit_strong_openn_ideal)

anova(fit_strong_openn_ideal, fit_strict_openn_ideal)
```

::: {.callout-note appearance="minimal"}
Model fit satisfactory (except for RMSEA) across all stages of measurement invariance. Chi^2 tests indicate that strict measurement invariance is given.
:::

------------------------------------------------------------------------

## Descriptives

### Sample size

How many participants at each time point and in each condition?
```{r}
#| echo: true
#| warning: false
df_sbsa3 %>% summarise(n_distinct(pid)) # N (after exclusions)

df_sbsa3 %>% group_by(time, group) %>% tally()
```

One in Group 1 only has T2 data.

### Demographics

Gender and age distribution
```{r}
#| echo: true
#| warning: false

# across all participants
df_sbsa3 %>% group_by(pid) %>% slice_head(n=1) %>% ungroup() %>% 
  mutate(gender_num = ifelse(gender=="Female", 1, 0)) %>% 
  summarise(n = n(), women = sum(gender_num), m_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), min_age = min(age, na.rm=T), max_age = max(age, na.rm=T)) %>% kable(digits = 2)

# by group and time point
df_sbsa3 %>% group_by(time, group) %>% 
  summarise(n = n(), m_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), min_age = min(age, na.rm=T), max_age = max(age, na.rm=T)) %>% kable(digits = 2)

df_sbsa3 %>% group_by(time, group, gender) %>% 
  summarise(n = n(), m_age = mean(age, na.rm=T), sd_age = sd(age, na.rm=T), min_age = min(age, na.rm=T), max_age = max(age, na.rm=T)) %>% kable(digits = 2)
```

Other demographics (from Prolific info):

```{r}
#| echo: true
#| warning: false

# across all participants: ethnicity
df_sbsa3 %>% group_by(pid) %>% slice_head(n=1) %>% ungroup() %>% 
  group_by(ethnicity) %>% summarise(n = n()) %>% ungroup() %>% mutate(prop = round(n / sum(n) * 100, 3)) %>% 
  kable(digits = 1)

# across all participants: country of residence
df_sbsa3 %>% group_by(pid) %>% slice_head(n=1) %>% ungroup() %>% 
  group_by(country) %>% summarise(n = n()) %>% ungroup() %>% 
  arrange(desc(n)) %>% mutate(prop = round(n / sum(n) * 100, 3)) %>% print(n=20) %>% kable(digits = 1)

# across all participants: student status
df_sbsa3 %>% group_by(pid) %>% slice_head(n=1) %>% ungroup() %>% 
  group_by(student) %>% summarise(n = n()) %>% ungroup() %>% 
  arrange(desc(n)) %>% mutate(prop = round(n / sum(n) * 100, 3)) %>% kable(digits = 1)

# across all participants: employment status
df_sbsa3 %>% group_by(pid) %>% slice_head(n=1) %>% ungroup() %>% 
  group_by(employed) %>% summarise(n = n()) %>% ungroup() %>% 
  arrange(desc(n)) %>% mutate(prop = round(n / sum(n) * 100, 3)) %>% kable(digits = 1)
```

### Internal consistencies

On the trait/dimensional level:
```{r}
#| echo: true
#| warning: false

# created in study 3 cleaning script 
base::load("data/int_consist_traits_st3.rda")
kable(int_consist_traits_st3, digits = 3)
```

McDonald's omega only really makes sense for the Big Five dimensions (with their three facets each) but I've added it for the well-being measures as well. Keep in mind that a few of the omega computations for the well-being measures only converged with error messages. These constructs were not neccessarily intended to be tested in this multidimensional manner for internal consistency.  

On the facet level:
```{r}
#| echo: true
#| warning: false

# created in study 3 cleaning script 
base::load("data/int_consist_facets_st3.rda")
kable(int_consist_facets_st3, digits = 3)
```

### Attrition analyses

Do participants who only took part in T1 differ from those taking part in T1 and T2?

Determine groups of "remainers" vs. "drop-outs" and run analyses:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

attrition_sample <- df_sbsa3 %>% 
  group_by(pid) %>% mutate(last_time = max(time)) %>% ungroup() %>% 
  filter(time==1) %>% 
  select(pid, last_time, 
         contains("_comb_"), c("swls", "meaning", "selfes", "concept"), # outcomes
         gender, age, ethnicity, student, employed) %>% # demographics
  mutate(remained = last_time - 1,
         female = if_else(gender=="Female", 1, 0, NA_real_),
         white = if_else(ethnicity=="White", 1, 0, NA_real_),
         black = if_else(ethnicity=="Black", 1, 0, NA_real_),
         student = if_else(student=="Yes", 1, 0, NA_real_),
         fulltime = if_else(employed=="Full-Time", 1, 0, NA_real_),
         parttime = if_else(employed=="Part-Time", 1, 0, NA_real_),
         notemployed = if_else(employed=="Unemployed (and job seeking)" | 
                                 employed=="Not in paid work (e.g. homemaker', 'retired or disabled)" | 
                                 employed=="Due to start a new job within the next month", 1, 0, NA_real_),) %>% 
  select(-c(last_time, na_comb_curr, na_comb_ideal, gender, ethnicity, employed))

attrition_analysis <- colnames(attrition_sample) %>%                                # Start with all column names
    setdiff( c("pid", "remained" ) ) %>%                 # ...that are not Sepal.Length
    rlang::syms() %>%                             # Convert them to symbols
    map( ~rlang::expr(lm(!!.x ~ remained,
                         data=attrition_sample)) ) %>%        # Create expressions
    map( eval.parent ) %>%                        # Evaluate expressions
    map( broom::tidy ) %>%                        # Tidy up the output
    bind_rows() %>%                               # Combine into a single data frame
    filter( term != "(Intercept)" ) %>%                # Drop all (Intercept) entries
    mutate(outcome = colnames(attrition_sample) %>% setdiff( c("pid", "remained" ) ))
```

Display significant differences: 
```{r}
#| echo: true
#| warning: false

attrition_analysis %>% filter(p.value < .05) %>% arrange(desc(abs(estimate)))

effectsize::cohens_d(compa_comb_curr ~ remained, data = attrition_sample)
effectsize::phi(table(attrition_sample$female, attrition_sample$remained), alternative = "two.sided")
effectsize::phi(table(attrition_sample$black, attrition_sample$remained), alternative = "two.sided")
effectsize::phi(table(attrition_sample$white, attrition_sample$remained), alternative = "two.sided")
```

Participants who dropped out at T2 were less compassionate, d = -0.32, 95% CI [-0.58; -0.06], p = .016, less likely to be female, phi = .11, 95% CI [0; .20], p = .007, and Black, phi = .10, 95% CI [0; .19], p = .001, and more likely to be White, phi = .07, 95% CI [0; .17], p = .048.  

Show all results: 
```{r}
#| echo: true
#| warning: false

attrition_analysis %>% arrange(desc(abs(estimate))) %>% print(n=200)
```

### Descriptive plots: mean-level changes

#### Personality

Prepare data frame for plotting:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

df_manip_check_forplot <- df_sbsa3 %>% 
  mutate(time_d = time - 1) %>% 
  select(pid, time_d, group, contains("_comb_"), -c(na_comb_curr, na_comb_ideal)) %>% 
  pivot_longer(-c(pid, time_d, group), 
               cols_vary = "slowest",
               names_to = c("trait", "reference"),
               names_pattern = "(.*)_(.*)",
               values_to = "score") %>% 
  mutate(trait = gsub("_comb", "", trait),
         reference = ifelse(reference=="curr", "current", reference)) %>% 
  left_join(tibble(long = str_to_title(names(b5_vars)), trait = str_trunc(names(b5_vars), 5, ellipsis = ""))) %>% 
  select(-trait, trait = long, time = time_d) %>% 
  filter(!is.na(score)) %>% 
  group_by(trait, reference, group, time) %>% 
  summarise(n = n(), m_trait = mean(score), sd_trait = sd(score)) %>% 
  ungroup() %>% 
  mutate(Group = factor(group, levels = c("Group 1", "Group 2", "Group 3"), labels = c("Group 1", "Group 2", "Group 3")),
         Time = factor(time+1),
         Trait = factor(trait, 
                        levels = str_to_title(names(b5_vars))[c(1,6:8, 2,9:11, 3,12:14, 4,15:17, 5,18:20)], # group facets with each trait
                        labels = str_to_title(names(b5_vars))[c(1,6:8, 2,9:11, 3,12:14, 4,15:17, 5,18:20)]),
         Reference = factor(reference, levels = c("current", "ideal"), labels = c("Current Personality", "Ideal Personality")),
         lwr95 = m_trait - qnorm(0.975)*sd_trait/sqrt(n),
         upr95 = m_trait + qnorm(0.975)*sd_trait/sqrt(n)) %>% 
  select(-c(time, group, trait, reference))
```

Table of all outcomes:

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true

df_manip_check_forplot %>% arrange(Trait) %>% 
  mutate_if(is.numeric, round, digits=2) %>% 
  select(Trait, Reference, Group, Time, n, m_trait, lwr95, upr95, sd_trait) %>% 
  kable(digits = 2)
```

Plotting mean-level changes on a descriptive level: Big Five dimensions and facets
```{r}
#| echo: true
#| fig-width: 8
#| fig-height: 9.5
#| code-fold: true
#| code-summary: "Show the code"

ggplot(df_manip_check_forplot, 
       aes(y = m_trait, x = Time, shape = Group, color = Reference)) + 
  geom_point(position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width=.3, position=position_dodge(0.3)) +
  ylab("Mean Trait Level (95% CI)") + 
  facet_wrap( ~ Trait, ncol = 4) +
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting mean-level changes on a descriptive level: Extraversion
```{r}
#| echo: true
#| fig-width: 5
#| fig-height: 3.5
#| code-fold: true
#| code-summary: "Show the code"

ggplot(df_manip_check_forplot %>% filter(Trait=="Extraversion"), 
       aes(y = m_trait, x = Time, shape = Group, color = Reference)) + 
  geom_point(position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width=.3, position=position_dodge(0.3)) +
  ylab("Mean Trait Level (95% CI)") + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting mean-level changes on a descriptive level: Agreeableness
```{r}
#| echo: true
#| fig-width: 5
#| fig-height: 3.5
#| code-fold: true
#| code-summary: "Show the code"

ggplot(df_manip_check_forplot %>% filter(Trait=="Agreeableness"), 
       aes(y = m_trait, x = Time, shape = Group, color = Reference)) + 
  geom_point(position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width=.3, position=position_dodge(0.3)) +
  ylab("Mean Trait Level (95% CI)") + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting mean-level changes on a descriptive level: Conscientiousness
```{r}
#| echo: true
#| fig-width: 5
#| fig-height: 3.5
#| code-fold: true
#| code-summary: "Show the code"

ggplot(df_manip_check_forplot %>% filter(Trait=="Conscientiousness"), 
       aes(y = m_trait, x = Time, shape = Group, color = Reference)) + 
  geom_point(position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width=.3, position=position_dodge(0.3)) +
  ylab("Mean Trait Level (95% CI)") + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting mean-level changes on a descriptive level: Neuroticism
```{r}
#| echo: true
#| fig-width: 5
#| fig-height: 3.5
#| code-fold: true
#| code-summary: "Show the code"

ggplot(df_manip_check_forplot %>% filter(Trait=="Neuroticism"), 
       aes(y = m_trait, x = Time, shape = Group, color = Reference)) + 
  geom_point(position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width=.3, position=position_dodge(0.3)) +
  ylab("Mean Trait Level (95% CI)") + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting mean-level changes on a descriptive level: Openness
```{r}
#| echo: true
#| fig-width: 5
#| fig-height: 3.5
#| code-fold: true
#| code-summary: "Show the code"

ggplot(df_manip_check_forplot %>% filter(Trait=="Openness"), 
       aes(y = m_trait, x = Time, shape = Group, color = Reference)) + 
  geom_point(position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width=.3, position=position_dodge(0.3)) +
  ylab("Mean Trait Level (95% CI)") + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

#### Well-Being

Prepare data frame for plotting:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

df_manip_check_wb_forplot <- df_sbsa3 %>% 
  mutate(time_d = time - 1) %>% 
  select(pid, time_d, group, swls, meaning, search, selfes, concept) %>% 
  pivot_longer(-c(pid, time_d, group), 
               cols_vary = "slowest",
               names_to = c("trait"),
               values_to = "score") %>% 
  mutate(trait = case_when(trait=="swls" ~ "Life Satisfaction", trait=="meaning" ~ "Meaning in Life", 
                           trait=="search" ~ "Search for Meaning", 
                           trait=="selfes" ~ "Self-Esteem", trait=="concept" ~ "Self-Concept Clarity")) %>% 
  filter(!is.na(score)) %>% 
  group_by(trait, group, time_d) %>% 
  summarise(n = n(), m_trait = mean(score), sd_trait = sd(score)) %>% 
  ungroup() %>% 
  mutate(Group = factor(group, levels = c("Group 1", "Group 2", "Group 3"), labels = c("Group 1", "Group 2", "Group 3")),
         Time = factor(time_d+1),
         Trait = factor(trait, 
                        levels = c("Life Satisfaction", "Meaning in Life", "Search for Meaning", 
                                   "Self-Esteem", "Self-Concept Clarity"), # group facets with each trait
                        labels = c("Life Satisfaction", "Meaning in Life", "Search for Meaning", 
                                   "Self-Esteem", "Self-Concept Clarity")),
         lwr95 = m_trait - qnorm(0.975)*sd_trait/sqrt(n),
         upr95 = m_trait + qnorm(0.975)*sd_trait/sqrt(n)) %>% 
  select(-c(time_d, group, trait))
```

Table of all outcomes:

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| cache: true

df_manip_check_wb_forplot %>% arrange(Trait) %>% 
  mutate_if(is.numeric, round, digits=2) %>% 
  select(Trait, Group, Time, n, m_trait, lwr95, upr95, sd_trait) %>% 
  kable(digits = 2)
```

Plotting mean-level changes on a descriptive level: all four well-being aspects
```{r}
#| echo: true
#| fig-width: 6.5
#| fig-height: 6.5
#| code-fold: true
#| code-summary: "Show the code"

ggplot(df_manip_check_wb_forplot %>% filter(Trait!="Search for Meaning"), 
       aes(y = m_trait, x = Time, shape = Group)) + 
  geom_point(position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(ymin = lwr95, ymax = upr95), width=.3, position=position_dodge(0.3)) +
  ylab("Mean Well-Being Level (95% CI)") + 
  facet_wrap( ~ Trait, ncol = 2) +
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

### Standard deviations (for later standardization)

Personality
```{r}
#| echo: true
#| warning: false

sd_pers_st3 <- df_sbsa3 %>% 
  select(pid, time, group, contains("_comb_"), -c(na_comb_curr, na_comb_ideal)) %>% 
  pivot_longer(-c(pid, time, group), 
               cols_vary = "slowest",
               names_to = c("trait", "reference"),
               names_pattern = "(.*)_(.*)",
               values_to = "score") %>% 
  mutate(trait = gsub("_comb", "", trait),
         reference = ifelse(reference=="curr", "current", reference)) %>% 
  left_join(tibble(long = str_to_title(names(b5_vars)), trait = str_trunc(names(b5_vars), 5, ellipsis = ""))) %>% 
  filter(!is.na(score)) %>% 
  group_by(long, trait, reference, time) %>% 
  summarise(n = n(), m_trait = mean(score), sd_trait = sd(score)) %>% 
  ungroup()
```

Well-being

```{r}
#| echo: true
#| warning: false

sd_wb_st3 <- df_sbsa3 %>% 
  select(pid, time, group, swls, meaning, search, selfes, concept) %>% 
  pivot_longer(-c(pid, time, group), 
               cols_vary = "slowest",
               names_to = c("trait"),
               values_to = "score") %>% 
  mutate(long = case_when(trait=="swls" ~ "Life Satisfaction", trait=="meaning" ~ "Meaning in Life", 
                          trait=="search" ~ "Search for Meaning", 
                           trait=="selfes" ~ "Self-Esteem", trait=="concept" ~ "Self-Concept Clarity")) %>% 
  filter(!is.na(score)) %>% 
  group_by(long, trait, time) %>% 
  summarise(n = n(), m_trait = mean(score), sd_trait = sd(score)) %>% 
  ungroup()
```

------------------------------------------------------------------------

## Confirmatory results

For Study 3, most of these moedls are only possible in Group 1 which answered both current and ideal personality trait items.  

I only left the heading "*confirmatory*" here for better comparability with Study 1 and Study 2 analyses. The preregistered, confirmatory analyses for Study 3 are found below in section 7!  

### Well-being - similarity correlations (H4 in paper) {#hyp1}

*All four psychological well-being indicators will be positively correlated with a greater similarity between current- and ideal personality-ratings of personality.* 

To examine this at the level of overall profiles, we will compute the correlations between the psychological well-being indicators and the Fisher z transformed correlations between the facet- and item-level real-ideal personality-profiles. To examine this at the level of individual traits, we will compute the correlation between psychological well-being indicators and the squared difference between current- and ideal personality rating for each Big Five trait and facet.  

*In Study 3, we can only examine this in Group 3 because the other groups only received current personality items.* 

#### Profile similarity 

Computations:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

cormat_profile <- cor(df_sbsa3[, c("swls", "meaning", "search", "selfes", "concept",
                                  "profile_corr_item_z", "profile_corr_facet_z")], use = "pairwise.complete.obs")

rownames(cormat_profile) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", 
                              "Self-Esteem" , "Self Concept Clarity", 
                              "Item-Level Profile Corr (z)", "Facet-Level Profile Corr (z)")
colnames(cormat_profile) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", 
                              "Self-Esteem" , "Self Concept Clarity", 
                              "Item-Level Profile Corr (z)", "Facet-Level Profile Corr (z)")
```

```{r}
#| echo: true
corrplot(cormat_profile, type = "lower", order = "original", tl.col = "black", tl.srt = 10,
                      addCoef.col ='black', number.cex = 0.7, diag = FALSE) # also add numbers
```

::: {.callout-note appearance="minimal"}
Positive correlations of well-being indicators with profile similarity between current personality and ideal personality personality. Especially high correlation with self-esteem. High congruence of item-level and facet-level profile similarity.
:::

As a table with confidence intervals - profile similarity:  
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

bind_rows(
  bind_cols(
  cormat_profile[6, c(1:5)] %>% as_tibble() %>% 
    mutate(wellbeing = c("swls", "meaning", "search", "selfes", "concept"),
           profile_sim = rep("item-level", 5)) %>% 
    select(profile_sim, wellbeing, corr = value),
  correlation::cor_to_ci(cormat_profile[6, c(1:5)], n = (df_sbsa3 %>% filter(!is.na(swls)) 
                                        %>% tally() %>% pull())) %>% as_tibble(),
  correlation::cor_to_p(cormat_profile[6, c(1:5)], n = (df_sbsa3 %>% filter(!is.na(swls)) 
                                      %>% tally() %>% pull())) %>% as_tibble() %>% select(p) 
  ),
bind_cols(
  cormat_profile[7, c(1:5)] %>% as_tibble() %>% 
    mutate(wellbeing = c("swls", "meaning", "search", "selfes", "concept"),
           profile_sim = rep("facet-level", 5)) %>% 
    select(profile_sim, wellbeing, corr = value),
  correlation::cor_to_ci(cormat_profile[7, c(1:5)], n = (df_sbsa3 %>% filter(!is.na(swls)) 
                                        %>% tally() %>% pull())) %>% as_tibble(),
  correlation::cor_to_p(cormat_profile[7, c(1:5)], n = (df_sbsa3 %>% filter(!is.na(swls)) 
                                      %>% tally() %>% pull())) %>% as_tibble() %>% select(p)
  )
) %>% kable(digits = 3)
```

##### Change in this relation over time and across intervention groups

Computations:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

# T1
cormat_profile_gr1_t1 <- cor((df_sbsa3 %>% filter(group=="Group 1" & time==1))[, c("swls", "meaning", "search", "selfes", "concept",                                  "profile_corr_item_z", "profile_corr_facet_z")], use = "pairwise.complete.obs")
rownames(cormat_profile_gr1_t1) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                              "Item-Level Profile Corr (z)", "Facet-Level Profile Corr (z)")
colnames(cormat_profile_gr1_t1) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                              "Item-Level Profile Corr (z)", "Facet-Level Profile Corr (z)")

# T2
cormat_profile_gr1_t2 <- cor((df_sbsa3 %>% filter(group=="Group 1" & time==2))[, c("swls", "meaning", "search", "selfes", "concept",                                  "profile_corr_item_z", "profile_corr_facet_z")], use = "pairwise.complete.obs")
rownames(cormat_profile_gr1_t2) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                              "Item-Level Profile Corr (z)", "Facet-Level Profile Corr (z)")
colnames(cormat_profile_gr1_t2) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                              "Item-Level Profile Corr (z)", "Facet-Level Profile Corr (z)")
```

T1  

First assessment
```{r}
#| echo: true
corrplot(cormat_profile_gr1_t1, type = "lower", order = "original", tl.col = "black", tl.srt = 10,
                      addCoef.col ='black', number.cex = 0.7, diag = FALSE) # also add numbers
```

T2  
Second assessment
```{r}
#| echo: true
corrplot(cormat_profile_gr1_t2, type = "lower", order = "original", tl.col = "black", tl.srt = 10,
                      addCoef.col ='black', number.cex = 0.7, diag = FALSE) # also add numbers
```

::: {.callout-note appearance="minimal"}
No pronounced differences across time.
:::

#### Individual traits: squared differences

Computations:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

cormat_sqtraits <- cor(df_sbsa3[, c("swls", "meaning", "search", "selfes", "concept",
                                   paste0(str_trunc(names(b5_vars)[1:5], 5, ellipsis = ""), "_sqdiff"))], 
                       use = "pairwise.complete.obs")

rownames(cormat_sqtraits) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[1:5]))
colnames(cormat_sqtraits) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[1:5]))

cormat_sqfacets <- cor(df_sbsa3[, c("swls", "meaning", "search", "selfes", "concept",
                                   paste0(str_trunc(names(b5_vars)[6:20], 5, ellipsis = ""), "_sqdiff"))], 
                       use = "pairwise.complete.obs")

rownames(cormat_sqfacets) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[6:20]))
colnames(cormat_sqfacets) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[6:20]))
```

Big Five traits
```{r}
#| echo: true
corrplot(cormat_sqtraits, type = "lower", order = "original", tl.col = "black", tl.srt = 10,
         addCoef.col ='black', number.cex = 0.7, diag = FALSE) # also add numbers
```

As a table with confidence intervals - squared differences:  
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

cormat_sqtraits[c(6:10), c(1:5)] %>% as_tibble() %>% 
    mutate(personality = names(b5_vars)[1:5]) %>% 
    rename(swls = `Life Satisfaction`, meaning = `Meaning in Life`, search = `Search for Meaning`,
           selfes = `Self-Esteem`, concept = `Self Concept Clarity`) %>% 
    pivot_longer(1:5, names_to = "wellbeing", values_to = "corr") %>% 
    mutate(CI_low = correlation::cor_to_ci(corr, n = (df_sbsa3 %>% filter(!is.na(swls)) 
                                        %>% tally() %>% pull())) %>% 
             as_tibble() %>% pull(CI_low),
           CI_high = correlation::cor_to_ci(corr, n = (df_sbsa3 %>% filter(!is.na(swls)) 
                                        %>% tally() %>% pull())) %>% 
             as_tibble() %>% pull(CI_high),
           p = correlation::cor_to_p(corr, n = (df_sbsa3 %>% filter(!is.na(swls)) 
                                        %>% tally() %>% pull())) %>% 
             as_tibble() %>% pull(p)) %>% 
  kable(digits = 3)
```

Big Five facets
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
corrplot(cormat_sqfacets, type = "lower", order = "original", tl.col = "black", tl.srt = 10,
         addCoef.col ='black', number.cex = 0.6, diag = FALSE) # also add numbers
```

::: {.callout-note appearance="minimal"}
Here we see negative correlations of well-being indicators with squared trait- and facet-level mean-score differences between current personality and ideal personality personality. Especially pronounced negative correlations for neuroticism, extraversion, and conscientiousness (in that order).
:::

##### Change in this relation over time and across intervention groups

Only looking at the trait level for now!  

Computations:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

# T1
cormat_sqtraits_gr1_t1 <- cor((df_sbsa3 %>% filter(group=="Group 1" & time==1))[, c("swls", "meaning", "search", "selfes", "concept",
                                   paste0(str_trunc(names(b5_vars)[1:5], 5, ellipsis = ""), "_sqdiff"))], 
                       use = "pairwise.complete.obs")
rownames(cormat_sqtraits_gr1_t1) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[1:5]))
colnames(cormat_sqtraits_gr1_t1) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[1:5]))

# T2
cormat_sqtraits_gr1_t2 <- cor((df_sbsa3 %>% filter(group=="Group 1" & time==2))[, c("swls", "meaning", "search", "selfes", "concept",
                                   paste0(str_trunc(names(b5_vars)[1:5], 5, ellipsis = ""), "_sqdiff"))], 
                       use = "pairwise.complete.obs")
rownames(cormat_sqtraits_gr1_t2) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[1:5]))
colnames(cormat_sqtraits_gr1_t2) <- c("Life Satisfaction", "Meaning in Life", "Search for Meaning", "Self-Esteem" , "Self Concept Clarity", 
                               str_to_title(names(b5_vars)[1:5]))
```

T1  

First assessment: 
```{r}
#| echo: true
corrplot(cormat_sqtraits_gr1_t1, type = "lower", order = "original", tl.col = "black", tl.srt = 10,
                      addCoef.col ='black', number.cex = 0.7, diag = FALSE) # also add numbers
```

T2  
Second assessment: 
```{r}
#| echo: true
corrplot(cormat_sqtraits_gr1_t2, type = "lower", order = "original", tl.col = "black", tl.srt = 10,
                      addCoef.col ='black', number.cex = 0.7, diag = FALSE) # also add numbers
```

::: {.callout-note appearance="minimal"}
At T2, slightly lower correlations for openness. Relatively similar results across time, otherwise.  
:::

##### Exploratory: Controlling for initial trait levels

Additional, exploratory analysis: Are the relationships of the squared trait differences with well-being similar when we control for initial trait levels (at T1)?

Example with extraversion:
```{r}
#| echo: true
#| warning: false

cor(df_sbsa3 %>% filter(group=="Group 1" & time==1) %>% pull(swls), 
    df_sbsa3 %>% filter(group=="Group 1" & time==1) %>% pull(extra_sqdiff), 
    use = "pairwise.complete.obs") %>% round(2)

# basic model to replicate the correlation
mod_ex_1 <- lm(swls ~ extra_sqdiff, data = df_sbsa3 %>% filter(group=="Group 1" & time==1))
summary(mod_ex_1)$coef
effectsize::standardize_parameters(mod_ex_1)

# adjusted model controlling for initial trait level
mod_ex_2 <- lm(swls ~ extra_sqdiff + extra_comb_curr, 
               data = df_sbsa3 %>% filter(group=="Group 1" & time==1))
summary(mod_ex_2)$coef
effectsize::standardize_parameters(mod_ex_2)
```

::: {.callout-note appearance="minimal"}
Reduced correlation (effect size) in the adjusted model that is not significant, anymore (but small sample here in Study 3).  
:::

Only T1:  
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# prepare df
df_check_adjusted <- df_sbsa3 %>% 
  # reshape with well-being outcomes and current trait levels
  filter(group=="Group 1" & time==1) %>% 
  select(pid, group, 
         swls, meaning, selfes, concept,
         paste0(str_trunc(names(b5_vars), 5, ellipsis = ""), "_comb_curr")) %>% 
  pivot_longer(ends_with("_comb_curr"), 
               names_to = "test", names_prefix = "facet", values_to = "initial", values_drop_na = TRUE) %>% 
  mutate(test = sub("_.*", "", test)) %>% 
  left_join(
    df_sbsa3 %>% 
    # reshape with squared differences -> add to previous
      filter(group=="Group 1" & time==1) %>% 
      select(pid, group, ends_with("_sqdiff")) %>% 
      pivot_longer(ends_with("_sqdiff"), 
                   names_to = "test", names_prefix = "facet", values_to = "score", values_drop_na = TRUE) %>% 
      mutate(test = sub("_.*", "", test))
  )

# run models 
# swls
df_check_adjusted_swls <- df_check_adjusted %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lm(score ~ swls + initial, data = .x))) %>% 
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_swls_unlist <- as.data.frame(summary(df_check_adjusted_swls[[1]])$coefficients) %>% as_tibble() %>% 
  mutate(d = effectsize::standardize_parameters(df_check_adjusted_swls[[1]])$Std_Coefficient) # standardized beta
for (i in 2:length(df_check_adjusted_swls)) {
  df_check_adjusted_swls_unlist <- 
    bind_rows(df_check_adjusted_swls_unlist, 
              as.data.frame(summary(df_check_adjusted_swls[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_swls[[i]])$Std_Coefficient))
}
df_check_adjusted_swls_unlist <- df_check_adjusted_swls_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "swls", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))

# meaning
df_check_adjusted_meaning <- df_check_adjusted %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lm(score ~ meaning + initial, data = .x))) %>% 
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_meaning_unlist <- as.data.frame(summary(df_check_adjusted_meaning[[1]])$coefficients) %>% as_tibble() %>% 
  mutate(d = effectsize::standardize_parameters(df_check_adjusted_meaning[[1]])$Std_Coefficient) # standardized beta
for (i in 2:length(df_check_adjusted_meaning)) {
  df_check_adjusted_meaning_unlist <- 
    bind_rows(df_check_adjusted_meaning_unlist, 
              as.data.frame(summary(df_check_adjusted_meaning[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_meaning[[i]])$Std_Coefficient))
}
df_check_adjusted_meaning_unlist <- df_check_adjusted_meaning_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "meaning", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))

# selfes
df_check_adjusted_selfes <- df_check_adjusted %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lm(score ~ selfes + initial, data = .x))) %>% 
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_selfes_unlist <- as.data.frame(summary(df_check_adjusted_selfes[[1]])$coefficients) %>% as_tibble() %>% 
  mutate(d = effectsize::standardize_parameters(df_check_adjusted_selfes[[1]])$Std_Coefficient) # standardized beta
for (i in 2:length(df_check_adjusted_selfes)) {
  df_check_adjusted_selfes_unlist <- 
    bind_rows(df_check_adjusted_selfes_unlist, 
              as.data.frame(summary(df_check_adjusted_selfes[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_selfes[[i]])$Std_Coefficient))
}
df_check_adjusted_selfes_unlist <- df_check_adjusted_selfes_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "selfes", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))

# concept
df_check_adjusted_concept <- df_check_adjusted %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lm(score ~ concept + initial, data = .x))) %>% 
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_concept_unlist <- as.data.frame(summary(df_check_adjusted_concept[[1]])$coefficients) %>% as_tibble() %>% 
  mutate(d = effectsize::standardize_parameters(df_check_adjusted_concept[[1]])$Std_Coefficient) # standardized beta
for (i in 2:length(df_check_adjusted_concept)) {
  df_check_adjusted_concept_unlist <- 
    bind_rows(df_check_adjusted_concept_unlist, 
              as.data.frame(summary(df_check_adjusted_concept[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_concept[[i]])$Std_Coefficient))
}
df_check_adjusted_concept_unlist <- df_check_adjusted_concept_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "concept", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))
```

Does the relationship between the squared difference in one trait (current vs. ideal) and well-being aspects still hold if we control for the initial trait level?  

Combine as one table:  
```{r}
#| echo: true
#| warning: false

kable(df_check_adjusted_swls_unlist %>% 
        filter(!term %in% c("Intercept", "initial")) %>% 
        select(outcome, d_swls = d, p_ls = p, sig_ls = sig) %>% 
        left_join(
          df_check_adjusted_meaning_unlist %>% 
            filter(!term %in% c("Intercept", "initial")) %>% 
            select(outcome, d_meaning = d, p_m = p, sig_m = sig)
        ) %>% 
          left_join(
            df_check_adjusted_selfes_unlist %>% 
              filter(!term %in% c("Intercept", "initial")) %>% 
              select(outcome, d_selfes = d, p_se = p, sig_se = sig)
          ) %>% 
          left_join(
            df_check_adjusted_concept_unlist %>% 
              filter(!term %in% c("Intercept", "initial")) %>% 
              select(outcome, d_concept = d, p_c = p, sig_c = sig)
          ), 
       digits = 3)
```

::: {.callout-note appearance="minimal"}
Effects mostly not significant, anymore but much smaller sample size here in Study 3. 
:::

Across all time points, using a mixed model:  
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# prepare df
df_check_adjusted_all <- df_sbsa3 %>% 
  # reshape with well-being outcomes and current trait levels
  filter(group=="Group 1") %>% 
  select(pid, group, time,
         swls, meaning, selfes, concept,
         paste0(str_trunc(names(b5_vars), 5, ellipsis = ""), "_sqdiff")) %>% 
  pivot_longer(ends_with("_sqdiff"), 
               names_to = "test", names_prefix = "facet", values_to = "score", values_drop_na = TRUE) %>% 
  mutate(test = sub("_.*", "", test)) %>% 
  left_join(
    df_sbsa3 %>% 
    # reshape with squared differences -> add to previous
      filter(group=="Group 1" & time==1) %>% 
      select(pid, group, ends_with("_comb_curr")) %>% 
      pivot_longer(ends_with("_comb_curr"), 
                   names_to = "test", names_prefix = "facet", values_to = "initial", values_drop_na = TRUE) %>% 
      mutate(test = sub("_.*", "", test))
  )

# run models 
# swls
df_check_adjusted_swls_all <- df_check_adjusted_all %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lmerTest::lmer(score ~ swls + initial + (1 | pid), data = .x))) %>% # groupm intercept model
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_swls_all_unlist <- as.data.frame(summary(df_check_adjusted_swls_all[[1]])$coefficients) %>% as_tibble() %>% 
  mutate(d = effectsize::standardize_parameters(df_check_adjusted_swls_all[[1]])$Std_Coefficient) # standardized beta
for (i in 2:length(df_check_adjusted_swls_all)) {
  df_check_adjusted_swls_all_unlist <- 
    bind_rows(df_check_adjusted_swls_all_unlist, 
              as.data.frame(summary(df_check_adjusted_swls_all[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_swls_all[[i]])$Std_Coefficient))
}
df_check_adjusted_swls_all_unlist <- df_check_adjusted_swls_all_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "swls", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))

# meaning
df_check_adjusted_meaning_all <- df_check_adjusted_all %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lmerTest::lmer(score ~ meaning + initial + (1 | pid), data = .x))) %>% # groupm intercept model
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_meaning_all_unlist <- as.data.frame(summary(df_check_adjusted_meaning_all[[1]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_meaning_all[[1]])$Std_Coefficient)
for (i in 2:length(df_check_adjusted_meaning_all)) {
  df_check_adjusted_meaning_all_unlist <- 
    bind_rows(df_check_adjusted_meaning_all_unlist, 
              as.data.frame(summary(df_check_adjusted_meaning_all[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_meaning_all[[i]])$Std_Coefficient))
}
df_check_adjusted_meaning_all_unlist <- df_check_adjusted_meaning_all_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "meaning", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))

# selfes
df_check_adjusted_selfes_all <- df_check_adjusted_all %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lmerTest::lmer(score ~ selfes + initial + (1 | pid), data = .x))) %>% # groupm intercept model
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_selfes_all_unlist <- as.data.frame(summary(df_check_adjusted_selfes_all[[1]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_selfes_all[[1]])$Std_Coefficient)
for (i in 2:length(df_check_adjusted_selfes_all)) {
  df_check_adjusted_selfes_all_unlist <- 
    bind_rows(df_check_adjusted_selfes_all_unlist, 
              as.data.frame(summary(df_check_adjusted_selfes_all[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_selfes_all[[i]])$Std_Coefficient))
}
df_check_adjusted_selfes_all_unlist <- df_check_adjusted_selfes_all_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "selfes", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))

# concept
df_check_adjusted_concept_all <- df_check_adjusted_all %>% 
  group_nest(test) %>% 
  mutate(lm_mods = map(data, ~lmerTest::lmer(score ~ concept + initial + (1 | pid), data = .x))) %>% # groupm intercept model
  pull(lm_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_check_adjusted_concept_all_unlist <- as.data.frame(summary(df_check_adjusted_concept_all[[1]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_concept_all[[1]])$Std_Coefficient)
for (i in 2:length(df_check_adjusted_concept_all)) {
  df_check_adjusted_concept_all_unlist <- 
    bind_rows(df_check_adjusted_concept_all_unlist, 
              as.data.frame(summary(df_check_adjusted_concept_all[[i]])$coefficients) %>% as_tibble() %>% 
                mutate(d = effectsize::standardize_parameters(df_check_adjusted_concept_all[[i]])$Std_Coefficient))
}
df_check_adjusted_concept_all_unlist <- df_check_adjusted_concept_all_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=3), 
               term = c(rep(c("Intercept", "concept", "initial"), 20))) %>% 
        rename(p = `Pr(>|t|)`, std_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, d, std_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars))))
```

Does the relationship between the squared difference in one trait (current vs. ideal) and well-being aspects still hold if we control for the initial trait level?  

Combine as one table:  
```{r}
#| echo: true
#| warning: false

kable(df_check_adjusted_swls_all_unlist %>% 
        filter(!term %in% c("Intercept", "initial")) %>% 
        select(outcome, d_swls = d, p_ls = p, sig_ls = sig) %>% 
        left_join(
          df_check_adjusted_meaning_all_unlist %>% 
            filter(!term %in% c("Intercept", "initial")) %>% 
            select(outcome, d_meaning = d, p_m = p, sig_m = sig)
        ) %>% 
          left_join(
            df_check_adjusted_selfes_all_unlist %>% 
              filter(!term %in% c("Intercept", "initial")) %>% 
              select(outcome, d_selfes = d, p_se = p, sig_se = sig)
          ) %>% 
          left_join(
            df_check_adjusted_concept_all_unlist %>% 
              filter(!term %in% c("Intercept", "initial")) %>% 
              select(outcome, d_concept = d, p_c = p, sig_c = sig)
          ), 
       digits = 3)
```

::: {.callout-note appearance="minimal"}
Effects mostly not significant, anymore, but much smaller sample size here in Study 3 (only Group 1). Exceptions: productiveness, depression & life satisfaction. Depression & meaning in life. Sociability & self-esteem.  
:::

------------------------------------------------------------------------

### Well-being - latent change (H5 in paper) {#hyp2}

*Both groups will increase in all four psychological well-being indicators.* 

We will test the mean-level difference between baseline and follow up using a latent change model.

#### Life satisfaction

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from Kievit et al. (2018) -- CC-BY -- https://doi.org/10.1016/j.dcn.2017.11.007

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_swls_hyp2 <- '
swls_t1 =~ 1*sw06_01_t1 + lamb2*sw06_02_t1 + lamb3*sw06_03_t1 + lamb4*sw06_04_t1 # This specifies the measurement model for swls_t1 
swls_t2 =~ 1*sw06_01_t2 + lamb2*sw06_02_t2 + lamb3*sw06_03_t2 + lamb4*sw06_04_t2 # This specifies the measurement model for swls_t2 with the equality constrained factor loadings

swls_t2 ~ 1*swls_t1     # This parameter regresses swls_t2 perfectly on swls_t1
d_swls_1 =~ 1*swls_t2   # This defines the latent change score factor as measured perfectly by scores on swls_t2
swls_t2 ~ 0*1           # This line constrains the intercept of swls_t2 to 0
swls_t2 ~~ 0*swls_t2    # This fixes the variance of swls_t2 to 0

d_swls_1 ~ 1           # This estimates the intercept of the change score 
swls_t1 ~ 1            # This estimates the intercept of swls_t1 
d_swls_1 ~~ d_swls_1   # This estimates the variance of the change scores 
swls_t1 ~~ swls_t1     # This estimates the variance of the swls_t1 
d_swls_1 ~~ swls_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

sw06_01_t1 ~~ sw06_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
sw06_02_t1 ~~ sw06_02_t2   # This allows residual covariance on indicator X2 across T1 and T2
sw06_03_t1 ~~ sw06_03_t2   # This allows residual covariance on indicator X3 across T1 and T2
sw06_04_t1 ~~ sw06_04_t2   # This allows residual covariance on indicator X4 across T1 and T2

sw06_01_t1 ~~ res1*sw06_01_t1   # This allows residual variance on indicator X1 at T1 
sw06_02_t1 ~~ res2*sw06_02_t1   # This allows residual variance on indicator X2 at T1
sw06_03_t1 ~~ res3*sw06_03_t1   # This allows residual variance on indicator X3 at T1
sw06_04_t1 ~~ res4*sw06_04_t1   # This allows residual variance on indicator X4 at T1

sw06_01_t2 ~~ res1*sw06_01_t2  # This allows residual variance on indicator X1 at T2 
sw06_02_t2 ~~ res2*sw06_02_t2  # This allows residual variance on indicator X2 at T2 
sw06_03_t2 ~~ res3*sw06_03_t2  # This allows residual variance on indicator X3 at T2
sw06_04_t2 ~~ res4*sw06_04_t2  # This allows residual variance on indicator X4 at T2

sw06_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
sw06_02_t1 ~ m2*1     # This estimates the intercept of X2 at T1
sw06_03_t1 ~ m3*1     # This estimates the intercept of X3 at T1
sw06_04_t1 ~ m4*1     # This estimates the intercept of X4 at T1

sw06_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
sw06_02_t2 ~ m2*1     # This estimates the intercept of X2 at T2
sw06_03_t2 ~ m3*1     # This estimates the intercept of X3 at T2
sw06_04_t2 ~ m4*1     # This estimates the intercept of X4 at T2
'
fit_mi_lcs_swls_hyp2 <- lavaan(mi_lcs_swls_hyp2, data=df_sbsa3_wide_wb, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_swls_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true

# model fit
kable(broom::glance(fit_mi_lcs_swls_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_swls_hyp2 <- broom::tidy(fit_mi_lcs_swls_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("swls_t2 ~ swls_t1", "d_swls_1 =~ swls_t2", "swls_t1 ~~ d_swls_1", # change parameters
                           "d_swls_1 ~1 ", "swls_t1 ~1 ", "", # means
                           "d_swls_1 ~~ d_swls_1")) # variances
kable(params_lcs_swls_hyp2, digits = 3)
```

Plot model:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

semPaths(fit_mi_lcs_swls_hyp2, what="est", 
         sizeLat = 7, sizeMan = 7, edge.label.cex = .75, intercepts = T, edge.color="black")
```

::: {.callout-note appearance="minimal"}
Significantly higher life satisfaction at the post test, *b* = `r round(params_lcs_swls_hyp2 %>% filter(term=="d_swls_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_swls_hyp2 %>% filter(term=="d_swls_1 ~1 ") %>% pull(estimate) / (sd_wb_st3 %>% filter(trait=="swls" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_swls_hyp2 %>% filter(term=="d_swls_1 ~1 ") %>% pull(p.value), 3)`. Those with initially higher levels of life satisfaction (at T1) change to a lesser degree.
:::

#### Meaning in life

For the 5-item subscale presence of meaning in life.  

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from Kievit et al. (2018) -- CC-BY -- https://doi.org/10.1016/j.dcn.2017.11.007

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_meaning_hyp2 <- '
meaning_t1 =~ 1*ml01_01_t1 + lamb2*ml01_04_t1 + lamb3*ml01_05_t1 + lamb4*ml01_06_t1 + lamb5*ml01_09_t1 # This specifies the measurement model for meaning_t1 
meaning_t2 =~ 1*ml01_01_t2 + lamb2*ml01_04_t2 + lamb3*ml01_05_t2 + lamb4*ml01_06_t2 + lamb5*ml01_09_t2 # This specifies the measurement model for meaning_t2 with the equality constrained factor loadings

meaning_t2 ~ 1*meaning_t1     # This parameter regresses meaning_t2 perfectly on meaning_t1
d_meaning_1 =~ 1*meaning_t2   # This defines the latent change score factor as measured perfectly by scores on meaning_t2
meaning_t2 ~ 0*1              # This line constrains the intercept of meaning_t2 to 0
meaning_t2 ~~ 0*meaning_t2    # This fixes the variance of meaning_t2 to 0

d_meaning_1 ~ 1              # This estimates the intercept of the change score 
meaning_t1 ~ 1               # This estimates the intercept of meaning_t1 
d_meaning_1 ~~ d_meaning_1   # This estimates the variance of the change scores 
meaning_t1 ~~ meaning_t1     # This estimates the variance of the meaning_t1 
d_meaning_1 ~~ meaning_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

ml01_01_t1 ~~ ml01_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_04_t1 ~~ ml01_04_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_05_t1 ~~ ml01_05_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_06_t1 ~~ ml01_06_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_09_t1 ~~ ml01_09_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_01_t1 ~~ res1*ml01_01_t1   # This allows residual variance on indicator X1 at T1 
ml01_04_t1 ~~ res2*ml01_04_t1   # This allows residual variance on indicator X2 at T1
ml01_05_t1 ~~ res3*ml01_05_t1   # This allows residual variance on indicator X3 at T1
ml01_06_t1 ~~ res4*ml01_06_t1   # This allows residual variance on indicator X4 at T1
ml01_09_t1 ~~ res5*ml01_09_t1   # This allows residual variance on indicator X5 at T1

ml01_01_t2 ~~ res1*ml01_01_t2  # This allows residual variance on indicator X1 at T2 
ml01_04_t2 ~~ res2*ml01_04_t2  # This allows residual variance on indicator X2 at T2 
ml01_05_t2 ~~ res3*ml01_05_t2  # This allows residual variance on indicator X3 at T2
ml01_06_t2 ~~ res4*ml01_06_t2  # This allows residual variance on indicator X4 at T2
ml01_09_t2 ~~ res5*ml01_09_t2  # This allows residual variance on indicator X5 at T2

ml01_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_04_t1 ~ m2*1     # This estimates the intercept of X2 at T1
ml01_05_t1 ~ m3*1     # This estimates the intercept of X3 at T1
ml01_06_t1 ~ m4*1     # This estimates the intercept of X4 at T1
ml01_09_t1 ~ m5*1     # This estimates the intercept of X5 at T1

ml01_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_04_t2 ~ m2*1     # This estimates the intercept of X2 at T2
ml01_05_t2 ~ m3*1     # This estimates the intercept of X3 at T2
ml01_06_t2 ~ m4*1     # This estimates the intercept of X4 at T2
ml01_09_t2 ~ m5*1     # This estimates the intercept of X5 at T2
'
fit_mi_lcs_meaning_hyp2 <- lavaan(mi_lcs_meaning_hyp2, data=df_sbsa3_wide_wb, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_meaning_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model fit
kable(broom::glance(fit_mi_lcs_meaning_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_meaning_hyp2 <- broom::tidy(fit_mi_lcs_meaning_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("meaning_t2 ~ meaning_t1", "d_meaning_1 =~ meaning_t2", "meaning_t1 ~~ d_meaning_1", # change parameters
                           "d_meaning_1 ~1 ", "meaning_t1 ~1 ", "", # means
                           "d_meaning_1 ~~ d_meaning_1")) # variances

kable(params_lcs_meaning_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
Participants did not improve significantly in meaning in life across time, *b* = `r round(params_lcs_meaning_hyp2 %>% filter(term=="d_meaning_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_meaning_hyp2 %>% filter(term=="d_meaning_1 ~1 ") %>% pull(estimate) / (sd_wb_st3 %>% filter(trait=="meaning" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_meaning_hyp2 %>% filter(term=="d_meaning_1 ~1 ") %>% pull(p.value), 3)`.  
:::

##### Search for Meaning

For the 5-item subscale search for meaning in life.  

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from Kievit et al. (2018) -- CC-BY -- https://doi.org/10.1016/j.dcn.2017.11.007

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_search_hyp2 <- '
search_t1 =~ 1*ml01_02_t1 + lamb2*ml01_03_t1 + lamb3*ml01_07_t1 + lamb4*ml01_08_t1 + lamb5*ml01_10_t1 # This specifies the measurement model for search_t1 
search_t2 =~ 1*ml01_02_t2 + lamb2*ml01_03_t2 + lamb3*ml01_07_t2 + lamb4*ml01_08_t2 + lamb5*ml01_10_t2 # This specifies the measurement model for search_t2 with the equality constrained factor loadings

search_t2 ~ 1*search_t1     # This parameter regresses search_t2 perfectly on search_t1
d_search_1 =~ 1*search_t2   # This defines the latent change score factor as measured perfectly by scores on search_t2
search_t2 ~ 0*1              # This line constrains the intercept of search_t2 to 0
search_t2 ~~ 0*search_t2    # This fixes the variance of search_t2 to 0

d_search_1 ~ 1              # This estimates the intercept of the change score 
search_t1 ~ 1               # This estimates the intercept of search_t1 
d_search_1 ~~ d_search_1   # This estimates the variance of the change scores 
search_t1 ~~ search_t1     # This estimates the variance of the search_t1 
d_search_1 ~~ search_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

ml01_02_t1 ~~ ml01_02_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_03_t1 ~~ ml01_03_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_07_t1 ~~ ml01_07_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_08_t1 ~~ ml01_08_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_10_t1 ~~ ml01_10_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_02_t1 ~~ res1*ml01_02_t1   # This allows residual variance on indicator X1 at T1 
ml01_03_t1 ~~ res2*ml01_03_t1   # This allows residual variance on indicator X2 at T1
ml01_07_t1 ~~ res3*ml01_07_t1   # This allows residual variance on indicator X3 at T1
ml01_08_t1 ~~ res4*ml01_08_t1   # This allows residual variance on indicator X4 at T1
ml01_10_t1 ~~ res5*ml01_10_t1   # This allows residual variance on indicator X5 at T1

ml01_02_t2 ~~ res1*ml01_02_t2  # This allows residual variance on indicator X1 at T2 
ml01_03_t2 ~~ res2*ml01_03_t2  # This allows residual variance on indicator X2 at T2 
ml01_07_t2 ~~ res3*ml01_07_t2  # This allows residual variance on indicator X3 at T2
ml01_08_t2 ~~ res4*ml01_08_t2  # This allows residual variance on indicator X4 at T2
ml01_10_t2 ~~ res5*ml01_10_t2  # This allows residual variance on indicator X5 at T2

ml01_02_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_03_t1 ~ m2*1     # This estimates the intercept of X2 at T1
ml01_07_t1 ~ m3*1     # This estimates the intercept of X3 at T1
ml01_08_t1 ~ m4*1     # This estimates the intercept of X4 at T1
ml01_10_t1 ~ m5*1     # This estimates the intercept of X5 at T1

ml01_02_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_03_t2 ~ m2*1     # This estimates the intercept of X2 at T2
ml01_07_t2 ~ m3*1     # This estimates the intercept of X3 at T2
ml01_08_t2 ~ m4*1     # This estimates the intercept of X4 at T2
ml01_10_t2 ~ m5*1     # This estimates the intercept of X5 at T2
'
fit_mi_lcs_search_hyp2 <- lavaan(mi_lcs_search_hyp2, data=df_sbsa3_wide_wb, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_search_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model fit
kable(broom::glance(fit_mi_lcs_search_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_search_hyp2 <- broom::tidy(fit_mi_lcs_search_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("search_t2 ~ search_t1", "d_search_1 =~ search_t2", "search_t1 ~~ d_search_1", # change parameters
                           "d_search_1 ~1 ", "search_t1 ~1 ", "", # means
                           "d_search_1 ~~ d_search_1")) # variances

kable(params_lcs_search_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
Participants decreased significantly in search for meaning in life across time, *b* = `r round(params_lcs_search_hyp2 %>% filter(term=="d_search_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_search_hyp2 %>% filter(term=="d_search_1 ~1 ") %>% pull(estimate) / (sd_wb_st3 %>% filter(trait=="search" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_search_hyp2 %>% filter(term=="d_search_1 ~1 ") %>% pull(p.value), 3)`.  
:::

#### Self-esteem

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from Kievit et al. (2018) -- CC-BY -- https://doi.org/10.1016/j.dcn.2017.11.007

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_selfes_hyp2 <- '
selfes_t1 =~ 1*selfes_par1_t1 + lamb2*selfes_par2_t1 + lamb3*selfes_par3_t1 # This specifies the measurement model for selfes_t1 
selfes_t2 =~ 1*selfes_par1_t2 + lamb2*selfes_par2_t2 + lamb3*selfes_par3_t2 # This specifies the measurement model for selfes_t2 with the equality constrained factor loadings

selfes_t2 ~ 1*selfes_t1     # This parameter regresses selfes_t2 perfectly on selfes_t1
d_selfes_1 =~ 1*selfes_t2   # This defines the latent change score factor as measured perfectly by scores on selfes_t2
selfes_t2 ~ 0*1             # This line constrains the intercept of selfes_t2 to 0
selfes_t2 ~~ 0*selfes_t2    # This fixes the variance of selfes_t2 to 0

d_selfes_1 ~ 1             # This estimates the intercept of the change score 
selfes_t1 ~ 1              # This estimates the intercept of selfes_t1 
d_selfes_1 ~~ d_selfes_1   # This estimates the variance of the change scores 
selfes_t1 ~~ selfes_t1     # This estimates the variance of the selfes_t1 
d_selfes_1 ~~ selfes_t1    # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

selfes_par1_t1 ~~ selfes_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
selfes_par2_t1 ~~ selfes_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
selfes_par3_t1 ~~ selfes_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

selfes_par1_t1 ~~ res1*selfes_par1_t1   # This allows residual variance on indicator X1 at T1 
selfes_par2_t1 ~~ res2*selfes_par2_t1   # This allows residual variance on indicator X2 at T1
selfes_par3_t1 ~~ res3*selfes_par3_t1   # This allows residual variance on indicator X3 at T1

selfes_par1_t2 ~~ res1*selfes_par1_t2  # This allows residual variance on indicator X1 at T2 
selfes_par2_t2 ~~ res2*selfes_par2_t2  # This allows residual variance on indicator X2 at T2 
selfes_par3_t2 ~~ res3*selfes_par3_t2  # This allows residual variance on indicator X3 at T2

selfes_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
selfes_par2_t1 ~ m2*1     # This estimates the intercept of X2 at T1
selfes_par3_t1 ~ m3*1     # This estimates the intercept of X3 at T1

selfes_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
selfes_par2_t2 ~ m2*1     # This estimates the intercept of X2 at T2
selfes_par3_t2 ~ m3*1     # This estimates the intercept of X3 at T2
'
fit_mi_lcs_selfes_hyp2 <- lavaan(mi_lcs_selfes_hyp2, data=df_sbsa3_wide_wb, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_selfes_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model fit
kable(broom::glance(fit_mi_lcs_selfes_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_selfes_hyp2 <- broom::tidy(fit_mi_lcs_selfes_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("selfes_t2 ~ selfes_t1", "d_selfes_1 =~ selfes_t2", "selfes_t1 ~~ d_selfes_1", # change parameters
                           "d_selfes_1 ~1 ", "selfes_t1 ~1 ", "", # means
                           "d_selfes_1 ~~ d_selfes_1")) # variances

kable(params_lcs_selfes_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
Participants increased significantly in self-esteem between the two assessments, *b* = `r round(params_lcs_selfes_hyp2 %>% filter(term=="d_selfes_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_selfes_hyp2 %>% filter(term=="d_selfes_1 ~1 ") %>% pull(estimate) / (sd_wb_st3 %>% filter(trait=="selfes" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_selfes_hyp2 %>% filter(term=="d_selfes_1 ~1 ") %>% pull(p.value), 3)`.
:::

#### Self concept clarity

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Code snippets adapted from Kievit et al. (2018) -- CC-BY -- https://doi.org/10.1016/j.dcn.2017.11.007

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_concept_hyp2 <- '
concept_t1 =~ 1*concept_par1_t1 + lamb2*concept_par2_t1 + lamb3*concept_par3_t1 # This specifies the measurement model for concept_t1 
concept_t2 =~ 1*concept_par1_t2 + lamb2*concept_par2_t2 + lamb3*concept_par3_t2 # This specifies the measurement model for concept_t2 with the equality constrained factor loadings

concept_t2 ~ 1*concept_t1     # This parameter regresses concept_t2 perfectly on concept_t1
d_concept_1 =~ 1*concept_t2   # This defines the latent change score factor as measured perfectly by scores on concept_t2
concept_t2 ~ 0*1              # This line constrains the intercept of concept_t2 to 0
concept_t2 ~~ 0*concept_t2    # This fixes the variance of concept_t2 to 0

d_concept_1 ~ 1              # This estimates the intercept of the change score 
concept_t1 ~ 1               # This estimates the intercept of concept_t1 
d_concept_1 ~~ d_concept_1   # This estimates the variance of the change scores 
concept_t1 ~~ concept_t1     # This estimates the variance of the concept_t1 
d_concept_1 ~~ concept_t1    # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

concept_par1_t1 ~~ concept_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
concept_par2_t1 ~~ concept_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
concept_par3_t1 ~~ concept_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

concept_par1_t1 ~~ res1*concept_par1_t1   # This allows residual variance on indicator X1 at T1 
concept_par2_t1 ~~ res2*concept_par2_t1   # This allows residual variance on indicator X2 at T1
concept_par3_t1 ~~ res3*concept_par3_t1   # This allows residual variance on indicator X3 at T1

concept_par1_t2 ~~ res1*concept_par1_t2  # This allows residual variance on indicator X1 at T2 
concept_par2_t2 ~~ res2*concept_par2_t2  # This allows residual variance on indicator X2 at T2 
concept_par3_t2 ~~ res3*concept_par3_t2  # This allows residual variance on indicator X3 at T2

concept_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
concept_par2_t1 ~ m2*1     # This estimates the intercept of X2 at T1
concept_par3_t1 ~ m3*1     # This estimates the intercept of X3 at T1

concept_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
concept_par2_t2 ~ m2*1     # This estimates the intercept of X2 at T2
concept_par3_t2 ~ m3*1     # This estimates the intercept of X3 at T2
'
fit_mi_lcs_concept_hyp2 <- lavaan(mi_lcs_concept_hyp2, data=df_sbsa3_wide_wb, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_concept_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model fit
kable(broom::glance(fit_mi_lcs_concept_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_concept_hyp2 <- broom::tidy(fit_mi_lcs_concept_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("concept_t2 ~ concept_t1", "d_concept_1 =~ concept_t2", "concept_t1 ~~ d_concept_1", # change parameters
                           "d_concept_1 ~1 ", "concept_t1 ~1 ", "", # means
                           "d_concept_1 ~~ d_concept_1")) # variances

kable(params_lcs_concept_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
Self concept clarity improved significantly across time, *b* = `r round(params_lcs_concept_hyp2 %>% filter(term=="d_concept_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_concept_hyp2 %>% filter(term=="d_concept_1 ~1 ") %>% pull(estimate) / (sd_wb_st3 %>% filter(trait=="concept" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_concept_hyp2 %>% filter(term=="d_concept_1 ~1 ") %>% pull(p.value), 3)`.
:::

------------------------------------------------------------------------

### Distance between ideal- and current personality over time (H1 in paper) {#hyp3}

*The distance between ideal- and current personality will decrease in both groups.* 

We will use two strategies to test this hypothesis. First, we will compute the Fisher z-transformed profile correlation between current- and ideal personality and test whether it increased across assessments. Second, we will test whether the squared difference between current- and ideal personality ratings for each Big Five trait decreased across assessments. We will test mean-level differences in profile correlations and squared differences between baseline and follow up using repeated-measures t-test.

In Study 3, we can only test this in Group 1 where we assessed both current and ideal personality ratings.  

#### Profile similarity

Reshape to wide:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"

# reshape to wide
df_sbsa3_wide_profdiff <- df_sbsa3 %>% 
  filter(group=="Group 1") %>% # not possible in the other groups
  arrange(pid, time) %>% 
  select(pid, time, profile_corr_item_z, profile_corr_facet_z, ends_with("_sqdiff")) %>% 
  pivot_wider(names_from = time,
              names_sep = "_t",
              values_from = -c(pid, time))
```

Checking assumptions
```{r}
#| echo: true
# item-level profile correlation
shapiro.test(df_sbsa3_wide_profdiff$profile_corr_item_z_t2 - df_sbsa3_wide_profdiff$profile_corr_item_z_t1) 
lillie.test(df_sbsa3_wide_profdiff$profile_corr_item_z_t2 - df_sbsa3_wide_profdiff$profile_corr_item_z_t1)

# descriptives
psych::describe(df_sbsa3_wide_profdiff$profile_corr_item_z_t1)
psych::describe(df_sbsa3_wide_profdiff$profile_corr_item_z_t2)

# facet-level profile correlation
shapiro.test(df_sbsa3_wide_profdiff$profile_corr_facet_z_t2 - df_sbsa3_wide_profdiff$profile_corr_facet_z_t1) 
lillie.test(df_sbsa3_wide_profdiff$profile_corr_facet_z_t2 - df_sbsa3_wide_profdiff$profile_corr_facet_z_t1)

# descriptives
psych::describe(df_sbsa3_wide_profdiff$profile_corr_facet_z_t1)
psych::describe(df_sbsa3_wide_profdiff$profile_corr_facet_z_t2)
```

Results summary:
```{r}
#| echo: true
#| warning: false
t_profile_corr_item <- t.test(df_sbsa3_wide_profdiff$profile_corr_item_z_t2, df_sbsa3_wide_profdiff$profile_corr_item_z_t1, paired = TRUE)
t_profile_corr_facet <- t.test(df_sbsa3_wide_profdiff$profile_corr_facet_z_t2, df_sbsa3_wide_profdiff$profile_corr_facet_z_t1, paired = TRUE)

kable(bind_rows(tidy(t_profile_corr_item), tidy(t_profile_corr_facet)) %>% mutate(outcome = c("Item-level profile corr.", "Facet-level profile corr.")) %>% select(outcome, everything()), digits = 3)

# effect sizes
d_profile_corr_item <- psych::cohen.d(profile_corr_item_z ~ time, data = df_sbsa3 %>% filter(group=="Group 1"))
d_profile_corr_item$cohen.d
d_profile_corr_facet <- psych::cohen.d(profile_corr_facet_z ~ time, data = df_sbsa3 %>% filter(group=="Group 1"))
d_profile_corr_facet$cohen.d
```

Plot 
```{r}
#| echo: true
#| warning: false
#| fig-width: 9.5
#| fig-height: 6.5
profile_df_plot <- df_sbsa3 %>% 
  filter(group=="Group 1") %>% 
  select(pid, time, profile_corr_item_z, profile_corr_facet_z) %>% 
  pivot_longer(-c(pid, time), names_to = "itemfacet", values_to = "corr") %>% 
  mutate(itemfacet2 = fct_recode(itemfacet, "Item-level" = "profile_corr_item_z", "Facet-level" = "profile_corr_facet_z"),
         itemfacet2 = fct_reorder(itemfacet2, corr, .desc = F))

ggplot(profile_df_plot) + 
  aes(x = as.factor(time), y = corr) + 
  geom_boxplot() + 
  geom_violin(fill = NA) +
  facet_wrap(vars(itemfacet2)) +
  labs(x = "Measurement Occasion", y = "Profile correlation") + # title = "Distance between ideal- and current personality"
  theme_bw()
```

::: {.callout-note appearance="minimal"}
Significantly higher profile correlations at the second measurement occasion, both for the item-level profile correlation and the facet-level profile correlations.
:::

#### Individual traits: squared differences

Checking assumptions
```{r}
#| echo: true

# extra
shapiro.test(df_sbsa3_wide_profdiff$extra_sqdiff_t2 - df_sbsa3_wide_profdiff$extra_sqdiff_t1) 
lillie.test(df_sbsa3_wide_profdiff$extra_sqdiff_t2 - df_sbsa3_wide_profdiff$extra_sqdiff_t1)
# descriptives
psych::describe(df_sbsa3_wide_profdiff$extra_sqdiff_t1)
psych::describe(df_sbsa3_wide_profdiff$extra_sqdiff_t2)

# agree
shapiro.test(df_sbsa3_wide_profdiff$agree_sqdiff_t2 - df_sbsa3_wide_profdiff$agree_sqdiff_t1) 
lillie.test(df_sbsa3_wide_profdiff$agree_sqdiff_t2 - df_sbsa3_wide_profdiff$agree_sqdiff_t1)
# descriptives
psych::describe(df_sbsa3_wide_profdiff$agree_sqdiff_t1)
psych::describe(df_sbsa3_wide_profdiff$agree_sqdiff_t2)

# consc
shapiro.test(df_sbsa3_wide_profdiff$consc_sqdiff_t2 - df_sbsa3_wide_profdiff$consc_sqdiff_t1) 
lillie.test(df_sbsa3_wide_profdiff$consc_sqdiff_t2 - df_sbsa3_wide_profdiff$consc_sqdiff_t1)
# descriptives
psych::describe(df_sbsa3_wide_profdiff$consc_sqdiff_t1)
psych::describe(df_sbsa3_wide_profdiff$consc_sqdiff_t2)

# neuro
shapiro.test(df_sbsa3_wide_profdiff$neuro_sqdiff_t2 - df_sbsa3_wide_profdiff$neuro_sqdiff_t1) 
lillie.test(df_sbsa3_wide_profdiff$neuro_sqdiff_t2 - df_sbsa3_wide_profdiff$neuro_sqdiff_t1)
# descriptives
psych::describe(df_sbsa3_wide_profdiff$neuro_sqdiff_t1)
psych::describe(df_sbsa3_wide_profdiff$neuro_sqdiff_t2)

# openn
shapiro.test(df_sbsa3_wide_profdiff$openn_sqdiff_t2 - df_sbsa3_wide_profdiff$openn_sqdiff_t1) 
lillie.test(df_sbsa3_wide_profdiff$openn_sqdiff_t2 - df_sbsa3_wide_profdiff$openn_sqdiff_t1)
# descriptives
psych::describe(df_sbsa3_wide_profdiff$openn_sqdiff_t1)
psych::describe(df_sbsa3_wide_profdiff$openn_sqdiff_t2)
```

Results summary:
```{r}
#| echo: true
#| warning: false
mod_traits_sqdiff <- df_sbsa3_wide_profdiff %>% 
  select(-starts_with("profile")) %>% 
  pivot_longer(-c(pid), 
               names_to = c("test", "time"), values_to = "score", 
               names_pattern = "(.*)_(t1|t2)") %>% 
  filter(!is.na(score)) %>% 
  group_by(pid, test) %>% 
  mutate(assessments = n()) %>% 
  ungroup() %>% 
  filter(assessments==2) %>% 
  select(-assessments) %>% 
  group_nest(test) %>% 
  mutate(t_tests = map(data, ~t.test(score ~ relevel(as.factor(time), "t2"), # need to relevel this to get T2-T1 diff (not sure why)
                                     data = .x, paired = TRUE))) %>% 
  pull(t_tests) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

mod_traits_unlist <- mod_traits_sqdiff[[1]] %>% tidy()
for (i in 2:length(mod_traits_sqdiff)) {
  mod_traits_unlist <- bind_rows(mod_traits_unlist, mod_traits_sqdiff[[i]] %>% tidy())
}

kable(mod_traits_unlist %>% mutate(outcome = sort(names(b5_vars))) %>% 
        select(outcome, everything()) %>% arrange(factor(outcome, levels = (names(b5_vars)))), digits = 3) # order by BFI traits

# effect sizes
cohend_cust = function(outcome, df) {
  form = as.formula(paste0(outcome, " ~ time"))
  psych::cohen.d(form, data = df)
}

d_trait <- cohend_cust(paste0(str_trunc(names(b5_vars)[1], 5, ellipsis = ""), "_sqdiff"), 
                       df_sbsa3 %>% filter(group=="Group 1"))
d_traits_unlist <- as_tibble(d_trait$cohen.d)
for (i in 2:length(names(b5_vars))) {
  d_trait <- cohend_cust(paste0(str_trunc(names(b5_vars)[i], 5, ellipsis = ""), "_sqdiff"), 
                         df_sbsa3 %>% filter(group=="Group 1"))
  d_traits_unlist <- bind_rows(d_traits_unlist, as_tibble(d_trait$cohen.d))
}
kable(d_traits_unlist %>% mutate(outcome = names(b5_vars)) %>% select(outcome, everything()), digits = 3)
```
[Note: These CIs for *d* are probably “wrong” -> not appropriate for paired t-test]  

::: {.callout-note appearance="minimal"}
Significantly lower squared mean-level differences at the second measurement occasion for extraversion and conscientiousness, but not for the rest of the Big Five traits and their 15 BFI-2 facets (at *p* < .01). Except for depression where the squared mean-level differences also decline significantly.
:::

Plot (traits/facets sorted by average size of squared differences)
```{r}
#| echo: true
#| warning: false
#| fig-width: 9.5
#| fig-height: 4.5
sqdiff_df_plot <- df_sbsa3 %>% 
  filter(group=="Group 1") %>% 
  select(pid, time, all_of(paste0(str_trunc(names(b5_vars), 5, ellipsis = ""), "_sqdiff"))) %>% 
  pivot_longer(-c(pid, time), names_to = "trait", values_to = "sqdiff") %>% 
  group_by(trait) %>% 
  mutate(cur_group_id()) %>% 
  ungroup() %>% 
  mutate(trait2 = fct_recode(trait, !!! setNames(paste0(str_trunc(names(b5_vars), 5, ellipsis = ""), "_sqdiff"),
                                                 str_to_title(names(b5_vars)))),
         trait2 = fct_reorder(trait2, sqdiff, .desc = T))

plot_sqdiff <- ggplot(sqdiff_df_plot) + 
  aes(x = as.factor(time), y = sqdiff) + 
  geom_boxplot() + 
  geom_violin(fill = NA) +
  ggforce::facet_wrap_paginate(~trait2, ncol=3, nrow=2) +
  labs(x = "Measurement Occasion", y = "Squared difference") + 
  theme_bw()

plot_sqdiff + ggforce::facet_wrap_paginate(~trait2, ncol=4, nrow=1, page = 1)
plot_sqdiff + ggforce::facet_wrap_paginate(~trait2, ncol=4, nrow=1, page = 2)
plot_sqdiff + ggforce::facet_wrap_paginate(~trait2, ncol=4, nrow=1, page = 3)
plot_sqdiff + ggforce::facet_wrap_paginate(~trait2, ncol=4, nrow=1, page = 4)
plot_sqdiff + ggforce::facet_wrap_paginate(~trait2, ncol=4, nrow=1, page = 5)
```

::: {.callout-note appearance="minimal"}
Distributions only look different for some of the facets (mostly E and C plus .
:::

------------------------------------------------------------------------

### Latent change in Big Five 

Amount of change on the latent level collapsed across all groups.

We will test the mean-level difference between baseline and follow up using a latent change model.

#### Extraversion

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_extra_hyp2 <- '
extra_t1 =~ 1*extra_curr_par1_t1 + lamb2*extra_curr_par2_t1 + lamb3*extra_curr_par3_t1 # Measurement model T1
extra_t2 =~ 1*extra_curr_par1_t2 + lamb2*extra_curr_par2_t2 + lamb3*extra_curr_par3_t2 # Measurement model T2 with the equality constrained factor loadings

extra_t2 ~ 1*extra_t1     # This parameter regresses extra_t2 perfectly on extra_t1
d_extra_1 =~ 1*extra_t2   # This defines the latent change score factor as measured perfectly by scores on extra_t2
extra_t2 ~ 0*1           # This line constrains the intercept of extra_t2 to 0
extra_t2 ~~ 0*extra_t2    # This fixes the variance of extra_t2 to 0

d_extra_1 ~ 1           # This estimates the intercept of the change score 
extra_t1 ~ 1            # This estimates the intercept of extra_t1 
d_extra_1 ~~ d_extra_1   # This estimates the variance of the change scores 
extra_t1 ~~ extra_t1     # This estimates the variance of the extra_t1 
d_extra_1 ~~ extra_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

extra_curr_par1_t1 ~~ extra_curr_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
extra_curr_par2_t1 ~~ extra_curr_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
extra_curr_par3_t1 ~~ extra_curr_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

extra_curr_par1_t1 ~~ res1*extra_curr_par1_t1   # This allows residual variance on indicator X1 at T1 
extra_curr_par2_t1 ~~ res2*extra_curr_par2_t1   # This allows residual variance on indicator X2 at T1
extra_curr_par3_t1 ~~ res3*extra_curr_par3_t1   # This allows residual variance on indicator X3 at T1

extra_curr_par1_t2 ~~ res1*extra_curr_par1_t2  # This allows residual variance on indicator X1 at T2 
extra_curr_par2_t2 ~~ res2*extra_curr_par2_t2  # This allows residual variance on indicator X2 at T2 
extra_curr_par3_t2 ~~ res3*extra_curr_par3_t2  # This allows residual variance on indicator X3 at T2

extra_curr_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
extra_curr_par2_t1 ~ m2*1     # This estimates the intercept of X2 at T1
extra_curr_par3_t1 ~ m3*1     # This estimates the intercept of X3 at T1

extra_curr_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
extra_curr_par2_t2 ~ m2*1     # This estimates the intercept of X2 at T2
extra_curr_par3_t2 ~ m3*1     # This estimates the intercept of X3 at T2
'
fit_mi_lcs_extra_hyp2 <- lavaan(mi_lcs_extra_hyp2, data=df_sbsa3_wide_pers, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_extra_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true

# model fit
kable(broom::glance(fit_mi_lcs_extra_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_extra_hyp2 <- broom::tidy(fit_mi_lcs_extra_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("extra_t2 ~ extra_t1", "d_extra_1 =~ extra_t2", "extra_t1 ~~ d_extra_1", # change parameters
                           "d_extra_1 ~1 ", "extra_t1 ~1 ", "", # means
                           "d_extra_1 ~~ d_extra_1")) # variances
kable(params_lcs_extra_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
Significantly higher extraversion at the post test, *b* = `r round(params_lcs_extra_hyp2 %>% filter(term=="d_extra_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_extra_hyp2 %>% filter(term=="d_extra_1 ~1 ") %>% pull(estimate) / (sd_pers_st3 %>% filter(trait=="extra" & reference=="current" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_extra_hyp2 %>% filter(term=="d_extra_1 ~1 ") %>% pull(p.value), 3)`. 
:::

#### Agreeableness

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_agree_hyp2 <- '
agree_t1 =~ 1*agree_curr_par1_t1 + lamb2*agree_curr_par2_t1 + lamb3*agree_curr_par3_t1 # Measurement model T1
agree_t2 =~ 1*agree_curr_par1_t2 + lamb2*agree_curr_par2_t2 + lamb3*agree_curr_par3_t2 # Measurement model T2 with the equality constrained factor loadings

agree_t2 ~ 1*agree_t1     # This parameter regresses agree_t2 perfectly on agree_t1
d_agree_1 =~ 1*agree_t2   # This defines the latent change score factor as measured perfectly by scores on agree_t2
agree_t2 ~ 0*1           # This line constrains the intercept of agree_t2 to 0
agree_t2 ~~ 0*agree_t2    # This fixes the variance of agree_t2 to 0

d_agree_1 ~ 1           # This estimates the intercept of the change score 
agree_t1 ~ 1            # This estimates the intercept of agree_t1 
d_agree_1 ~~ d_agree_1   # This estimates the variance of the change scores 
agree_t1 ~~ agree_t1     # This estimates the variance of the agree_t1 
d_agree_1 ~~ agree_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

agree_curr_par1_t1 ~~ agree_curr_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
agree_curr_par2_t1 ~~ agree_curr_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
agree_curr_par3_t1 ~~ agree_curr_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

agree_curr_par1_t1 ~~ res1*agree_curr_par1_t1   # This allows residual variance on indicator X1 at T1 
agree_curr_par2_t1 ~~ res2*agree_curr_par2_t1   # This allows residual variance on indicator X2 at T1
agree_curr_par3_t1 ~~ res3*agree_curr_par3_t1   # This allows residual variance on indicator X3 at T1

agree_curr_par1_t2 ~~ res1*agree_curr_par1_t2  # This allows residual variance on indicator X1 at T2 
agree_curr_par2_t2 ~~ res2*agree_curr_par2_t2  # This allows residual variance on indicator X2 at T2 
agree_curr_par3_t2 ~~ res3*agree_curr_par3_t2  # This allows residual variance on indicator X3 at T2

agree_curr_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
agree_curr_par2_t1 ~ m2*1     # This estimates the intercept of X2 at T1
agree_curr_par3_t1 ~ m3*1     # This estimates the intercept of X3 at T1

agree_curr_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
agree_curr_par2_t2 ~ m2*1     # This estimates the intercept of X2 at T2
agree_curr_par3_t2 ~ m3*1     # This estimates the intercept of X3 at T2
'
fit_mi_lcs_agree_hyp2 <- lavaan(mi_lcs_agree_hyp2, data=df_sbsa3_wide_pers, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_agree_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true

# model fit
kable(broom::glance(fit_mi_lcs_agree_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_agree_hyp2 <- broom::tidy(fit_mi_lcs_agree_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("agree_t2 ~ agree_t1", "d_agree_1 =~ agree_t2", "agree_t1 ~~ d_agree_1", # change parameters
                           "d_agree_1 ~1 ", "agree_t1 ~1 ", "", # means
                           "d_agree_1 ~~ d_agree_1")) # variances
kable(params_lcs_agree_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
No significant changes in agreeableness from pre to post test, *b* = `r round(params_lcs_agree_hyp2 %>% filter(term=="d_agree_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_agree_hyp2 %>% filter(term=="d_agree_1 ~1 ") %>% pull(estimate) / (sd_pers_st3 %>% filter(trait=="agree" & reference=="current" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_agree_hyp2 %>% filter(term=="d_agree_1 ~1 ") %>% pull(p.value), 3)`. 
:::

#### Conscientiousness

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_consc_hyp2 <- '
consc_t1 =~ 1*consc_curr_par1_t1 + lamb2*consc_curr_par2_t1 + lamb3*consc_curr_par3_t1 # Measurement model T1
consc_t2 =~ 1*consc_curr_par1_t2 + lamb2*consc_curr_par2_t2 + lamb3*consc_curr_par3_t2 # Measurement model T2 with the equality constrained factor loadings

consc_t2 ~ 1*consc_t1     # This parameter regresses consc_t2 perfectly on consc_t1
d_consc_1 =~ 1*consc_t2   # This defines the latent change score factor as measured perfectly by scores on consc_t2
consc_t2 ~ 0*1           # This line constrains the intercept of consc_t2 to 0
consc_t2 ~~ 0*consc_t2    # This fixes the variance of consc_t2 to 0

d_consc_1 ~ 1           # This estimates the intercept of the change score 
consc_t1 ~ 1            # This estimates the intercept of consc_t1 
d_consc_1 ~~ d_consc_1   # This estimates the variance of the change scores 
consc_t1 ~~ consc_t1     # This estimates the variance of the consc_t1 
d_consc_1 ~~ consc_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

consc_curr_par1_t1 ~~ consc_curr_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
consc_curr_par2_t1 ~~ consc_curr_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
consc_curr_par3_t1 ~~ consc_curr_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

consc_curr_par1_t1 ~~ res1*consc_curr_par1_t1   # This allows residual variance on indicator X1 at T1 
consc_curr_par2_t1 ~~ res2*consc_curr_par2_t1   # This allows residual variance on indicator X2 at T1
consc_curr_par3_t1 ~~ res3*consc_curr_par3_t1   # This allows residual variance on indicator X3 at T1

consc_curr_par1_t2 ~~ res1*consc_curr_par1_t2  # This allows residual variance on indicator X1 at T2 
consc_curr_par2_t2 ~~ res2*consc_curr_par2_t2  # This allows residual variance on indicator X2 at T2 
consc_curr_par3_t2 ~~ res3*consc_curr_par3_t2  # This allows residual variance on indicator X3 at T2

consc_curr_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
consc_curr_par2_t1 ~ m2*1     # This estimates the intercept of X2 at T1
consc_curr_par3_t1 ~ m3*1     # This estimates the intercept of X3 at T1

consc_curr_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
consc_curr_par2_t2 ~ m2*1     # This estimates the intercept of X2 at T2
consc_curr_par3_t2 ~ m3*1     # This estimates the intercept of X3 at T2
'
fit_mi_lcs_consc_hyp2 <- lavaan(mi_lcs_consc_hyp2, data=df_sbsa3_wide_pers, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_consc_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true

# model fit
kable(broom::glance(fit_mi_lcs_consc_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_consc_hyp2 <- broom::tidy(fit_mi_lcs_consc_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("consc_t2 ~ consc_t1", "d_consc_1 =~ consc_t2", "consc_t1 ~~ d_consc_1", # change parameters
                           "d_consc_1 ~1 ", "consc_t1 ~1 ", "", # means
                           "d_consc_1 ~~ d_consc_1")) # variances
kable(params_lcs_consc_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
Significantly higher conscientiousness at the post test, *b* = `r round(params_lcs_consc_hyp2 %>% filter(term=="d_consc_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_consc_hyp2 %>% filter(term=="d_consc_1 ~1 ") %>% pull(estimate) / (sd_pers_st3 %>% filter(trait=="consc" & reference=="current" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_consc_hyp2 %>% filter(term=="d_consc_1 ~1 ") %>% pull(p.value), 3)`. 
:::

#### Neuroticism

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_neuro_hyp2 <- '
neuro_t1 =~ 1*neuro_curr_par1_t1 + lamb2*neuro_curr_par2_t1 + lamb3*neuro_curr_par3_t1 # Measurement model T1
neuro_t2 =~ 1*neuro_curr_par1_t2 + lamb2*neuro_curr_par2_t2 + lamb3*neuro_curr_par3_t2 # Measurement model T2 with the equality constrained factor loadings

neuro_t2 ~ 1*neuro_t1     # This parameter regresses neuro_t2 perfectly on neuro_t1
d_neuro_1 =~ 1*neuro_t2   # This defines the latent change score factor as measured perfectly by scores on neuro_t2
neuro_t2 ~ 0*1           # This line constrains the intercept of neuro_t2 to 0
neuro_t2 ~~ 0*neuro_t2    # This fixes the variance of neuro_t2 to 0

d_neuro_1 ~ 1           # This estimates the intercept of the change score 
neuro_t1 ~ 1            # This estimates the intercept of neuro_t1 
d_neuro_1 ~~ d_neuro_1   # This estimates the variance of the change scores 
neuro_t1 ~~ neuro_t1     # This estimates the variance of the neuro_t1 
d_neuro_1 ~~ neuro_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

neuro_curr_par1_t1 ~~ neuro_curr_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
neuro_curr_par2_t1 ~~ neuro_curr_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
neuro_curr_par3_t1 ~~ neuro_curr_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

neuro_curr_par1_t1 ~~ res1*neuro_curr_par1_t1   # This allows residual variance on indicator X1 at T1 
neuro_curr_par2_t1 ~~ res2*neuro_curr_par2_t1   # This allows residual variance on indicator X2 at T1
neuro_curr_par3_t1 ~~ res3*neuro_curr_par3_t1   # This allows residual variance on indicator X3 at T1

neuro_curr_par1_t2 ~~ res1*neuro_curr_par1_t2  # This allows residual variance on indicator X1 at T2 
neuro_curr_par2_t2 ~~ res2*neuro_curr_par2_t2  # This allows residual variance on indicator X2 at T2 
neuro_curr_par3_t2 ~~ res3*neuro_curr_par3_t2  # This allows residual variance on indicator X3 at T2

neuro_curr_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
neuro_curr_par2_t1 ~ m2*1     # This estimates the intercept of X2 at T1
neuro_curr_par3_t1 ~ m3*1     # This estimates the intercept of X3 at T1

neuro_curr_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
neuro_curr_par2_t2 ~ m2*1     # This estimates the intercept of X2 at T2
neuro_curr_par3_t2 ~ m3*1     # This estimates the intercept of X3 at T2
'
fit_mi_lcs_neuro_hyp2 <- lavaan(mi_lcs_neuro_hyp2, data=df_sbsa3_wide_pers, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_neuro_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true

# model fit
kable(broom::glance(fit_mi_lcs_neuro_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_neuro_hyp2 <- broom::tidy(fit_mi_lcs_neuro_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("neuro_t2 ~ neuro_t1", "d_neuro_1 =~ neuro_t2", "neuro_t1 ~~ d_neuro_1", # change parameters
                           "d_neuro_1 ~1 ", "neuro_t1 ~1 ", "", # means
                           "d_neuro_1 ~~ d_neuro_1")) # variances
kable(params_lcs_neuro_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
Significantly lower neuroticism at the post test, *b* = `r round(params_lcs_neuro_hyp2 %>% filter(term=="d_neuro_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_neuro_hyp2 %>% filter(term=="d_neuro_1 ~1 ") %>% pull(estimate) / (sd_pers_st3 %>% filter(trait=="neuro" & reference=="current" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_neuro_hyp2 %>% filter(term=="d_neuro_1 ~1 ") %>% pull(p.value), 3)`. 
:::

#### Openness

Fit model:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# Fit the multiple indicator Univariate Latent Change Score model
mi_lcs_openn_hyp2 <- '
openn_t1 =~ 1*openn_curr_par1_t1 + lamb2*openn_curr_par2_t1 + lamb3*openn_curr_par3_t1 # Measurement model T1
openn_t2 =~ 1*openn_curr_par1_t2 + lamb2*openn_curr_par2_t2 + lamb3*openn_curr_par3_t2 # Measurement model T2 with the equality constrained factor loadings

openn_t2 ~ 1*openn_t1     # This parameter regresses openn_t2 perfectly on openn_t1
d_openn_1 =~ 1*openn_t2   # This defines the latent change score factor as measured perfectly by scores on openn_t2
openn_t2 ~ 0*1           # This line constrains the intercept of openn_t2 to 0
openn_t2 ~~ 0*openn_t2    # This fixes the variance of openn_t2 to 0

d_openn_1 ~ 1           # This estimates the intercept of the change score 
openn_t1 ~ 1            # This estimates the intercept of openn_t1 
d_openn_1 ~~ d_openn_1   # This estimates the variance of the change scores 
openn_t1 ~~ openn_t1     # This estimates the variance of the openn_t1 
d_openn_1 ~~ openn_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

openn_curr_par1_t1 ~~ openn_curr_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
openn_curr_par2_t1 ~~ openn_curr_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
openn_curr_par3_t1 ~~ openn_curr_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

openn_curr_par1_t1 ~~ res1*openn_curr_par1_t1   # This allows residual variance on indicator X1 at T1 
openn_curr_par2_t1 ~~ res2*openn_curr_par2_t1   # This allows residual variance on indicator X2 at T1
openn_curr_par3_t1 ~~ res3*openn_curr_par3_t1   # This allows residual variance on indicator X3 at T1

openn_curr_par1_t2 ~~ res1*openn_curr_par1_t2  # This allows residual variance on indicator X1 at T2 
openn_curr_par2_t2 ~~ res2*openn_curr_par2_t2  # This allows residual variance on indicator X2 at T2 
openn_curr_par3_t2 ~~ res3*openn_curr_par3_t2  # This allows residual variance on indicator X3 at T2

openn_curr_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
openn_curr_par2_t1 ~ m2*1     # This estimates the intercept of X2 at T1
openn_curr_par3_t1 ~ m3*1     # This estimates the intercept of X3 at T1

openn_curr_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
openn_curr_par2_t2 ~ m2*1     # This estimates the intercept of X2 at T2
openn_curr_par3_t2 ~ m3*1     # This estimates the intercept of X3 at T2
'
fit_mi_lcs_openn_hyp2 <- lavaan(mi_lcs_openn_hyp2, data=df_sbsa3_wide_pers, estimator='mlr', fixed.x=FALSE, missing='fiml')
summary(fit_mi_lcs_openn_hyp2, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

Results summary:
```{r}
#| echo: true

# model fit
kable(broom::glance(fit_mi_lcs_openn_hyp2) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)

# parameters of interest
params_lcs_openn_hyp2 <- broom::tidy(fit_mi_lcs_openn_hyp2, conf.int = TRUE, conf.level = 0.99) %>% 
        select(term, estimate, conf.low, conf.high, std.all, statistic, p.value) %>% 
        filter(term %in% c("openn_t2 ~ openn_t1", "d_openn_1 =~ openn_t2", "openn_t1 ~~ d_openn_1", # change parameters
                           "d_openn_1 ~1 ", "openn_t1 ~1 ", "", # means
                           "d_openn_1 ~~ d_openn_1")) # variances
kable(params_lcs_openn_hyp2, digits = 3)
```

::: {.callout-note appearance="minimal"}
No significant changes in openness from pre to post test, *b* = `r round(params_lcs_openn_hyp2 %>% filter(term=="d_openn_1 ~1 ") %>% pull(estimate), 3)`, *beta* = `r round(params_lcs_openn_hyp2 %>% filter(term=="d_openn_1 ~1 ") %>% pull(estimate) / (sd_pers_st3 %>% filter(trait=="openn" & reference=="current" & time==1) %>% pull(sd_trait)), 3)`, *p* = `r round(params_lcs_openn_hyp2 %>% filter(term=="d_openn_1 ~1 ") %>% pull(p.value), 3)`. 
:::

------------------------------------------------------------------------

## Differences in change across groups (SEM)

We will explore a) whether change in psychological well-being indicators as well as the difference between real- and ideal- self will differ across groups at follow-up.  

Create ordered factors first:  
```{r}
#| echo: true
#| warning: false

df_sbsa3_wide_wb <- df_sbsa3_wide_wb %>% 
  mutate(group = factor(group, ordered = T)) %>% 
  arrange(group, pid)

df_sbsa3_wide_pers <- df_sbsa3_wide_pers %>% 
  mutate(group = factor(group, ordered = T)) %>% 
  arrange(group, pid)
```

### Group 1 vs. Group 2: Effect of discrepancy awareness

#### Well-being change: differences across groups

##### Life satisfaction 

Life satisfaction: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance
mi_lcs_swls_group_config <- '
swls_t1 =~ 1*sw06_01_t1 + c("lamb2a", "lamb2b")*sw06_02_t1 + c("lamb3a", "lamb3b")*sw06_03_t1 + c("lamb4a", "lamb4b")*sw06_04_t1 # This specifies the measurement model for swls_t1 
swls_t2 =~ 1*sw06_01_t2 + c("lamb2a", "lamb2b")*sw06_02_t2 + c("lamb3a", "lamb3b")*sw06_03_t2 + c("lamb4a", "lamb4b")*sw06_04_t2 # This specifies the measurement model for swls_t2 with the equality constrained factor loadings

swls_t2 ~ 1*swls_t1     # This parameter regresses swls_t2 perfectly on swls_t1
d_swls_1 =~ 1*swls_t2   # This defines the latent change score factor as measured perfectly by scores on swls_t2
swls_t2 ~ 0*1           # This line constrains the intercept of swls_t2 to 0
swls_t2 ~~ 0*swls_t2    # This fixes the variance of swls_t2 to 0

d_swls_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
swls_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of swls_t1 
d_swls_1 ~~ c("d_var_a", "d_var_b")*d_swls_1   # This estimates the variance of the change scores 
swls_t1 ~~ c("wb_var_a", "wb_var_b")*swls_t1     # This estimates the variance of the swls_t1 
d_swls_1 ~~ c("fb_a", "fb_b")*swls_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score remains unconditional

sw06_01_t1 ~~ c("cov1a", "cov1b")*sw06_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
sw06_02_t1 ~~ c("cov2a", "cov2b")*sw06_02_t2   # This allows residual covariance on indicator X2 across T1 and T2
sw06_03_t1 ~~ c("cov3a", "cov3b")*sw06_03_t2   # This allows residual covariance on indicator X3 across T1 and T2
sw06_04_t1 ~~ c("cov4a", "cov4b")*sw06_04_t2   # This allows residual covariance on indicator X4 across T1 and T2

sw06_01_t1 ~~ c("res1a", "res1b")*sw06_01_t1   # This allows residual variance on indicator X1 at T1 
sw06_02_t1 ~~ c("res2a", "res2b")*sw06_02_t1   # This allows residual variance on indicator X2 at T1
sw06_03_t1 ~~ c("res3a", "res3b")*sw06_03_t1   # This allows residual variance on indicator X3 at T1
sw06_04_t1 ~~ c("res4a", "res4b")*sw06_04_t1   # This allows residual variance on indicator X4 at T1

sw06_01_t2 ~~ c("res1a", "res1b")*sw06_01_t2  # This allows residual variance on indicator X1 at T2 
sw06_02_t2 ~~ c("res2a", "res2b")*sw06_02_t2  # This allows residual variance on indicator X2 at T2 
sw06_03_t2 ~~ c("res3a", "res3b")*sw06_03_t2  # This allows residual variance on indicator X3 at T2
sw06_04_t2 ~~ c("res4a", "res4b")*sw06_04_t2  # This allows residual variance on indicator X4 at T2

sw06_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
sw06_02_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
sw06_03_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1
sw06_04_t1 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T1

sw06_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
sw06_02_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
sw06_03_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
sw06_04_t2 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T2
'
lcs_swls_group_12_config <- sem(mi_lcs_swls_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', 
                             fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance
mi_lcs_swls_group_weak <- '
swls_t1 =~ 1*sw06_01_t1 + c("lamb2", "lamb2")*sw06_02_t1 + c("lamb3", "lamb3")*sw06_03_t1 + c("lamb4", "lamb4")*sw06_04_t1 # This specifies the measurement model for swls_t1 
swls_t2 =~ 1*sw06_01_t2 + c("lamb2", "lamb2")*sw06_02_t2 + c("lamb3", "lamb3")*sw06_03_t2 + c("lamb4", "lamb4")*sw06_04_t2 # This specifies the measurement model for swls_t2 with the equality constrained factor loadings

swls_t2 ~ 1*swls_t1     # This parameter regresses swls_t2 perfectly on swls_t1
d_swls_1 =~ 1*swls_t2   # This defines the latent change score factor as measured perfectly by scores on swls_t2
swls_t2 ~ 0*1           # This line constrains the intercept of swls_t2 to 0
swls_t2 ~~ 0*swls_t2    # This fixes the variance of swls_t2 to 0

d_swls_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
swls_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of swls_t1 
d_swls_1 ~~ c("d_var_a", "d_var_b")*d_swls_1   # This estimates the variance of the change scores 
swls_t1 ~~ c("wb_var_a", "wb_var_b")*swls_t1     # This estimates the variance of the swls_t1 
d_swls_1 ~~ c("fb_a", "fb_b")*swls_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

sw06_01_t1 ~~ c("cov1a", "cov1b")*sw06_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
sw06_02_t1 ~~ c("cov2a", "cov2b")*sw06_02_t2   # This allows residual covariance on indicator X2 across T1 and T2
sw06_03_t1 ~~ c("cov3a", "cov3b")*sw06_03_t2   # This allows residual covariance on indicator X3 across T1 and T2
sw06_04_t1 ~~ c("cov4a", "cov4b")*sw06_04_t2   # This allows residual covariance on indicator X4 across T1 and T2

sw06_01_t1 ~~ c("res1a", "res1b")*sw06_01_t1   # This allows residual variance on indicator X1 at T1 
sw06_02_t1 ~~ c("res2a", "res2b")*sw06_02_t1   # This allows residual variance on indicator X2 at T1
sw06_03_t1 ~~ c("res3a", "res3b")*sw06_03_t1   # This allows residual variance on indicator X3 at T1
sw06_04_t1 ~~ c("res4a", "res4b")*sw06_04_t1   # This allows residual variance on indicator X4 at T1

sw06_01_t2 ~~ c("res1a", "res1b")*sw06_01_t2  # This allows residual variance on indicator X1 at T2 
sw06_02_t2 ~~ c("res2a", "res2b")*sw06_02_t2  # This allows residual variance on indicator X2 at T2 
sw06_03_t2 ~~ c("res3a", "res3b")*sw06_03_t2  # This allows residual variance on indicator X3 at T2
sw06_04_t2 ~~ c("res4a", "res4b")*sw06_04_t2  # This allows residual variance on indicator X4 at T2

sw06_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
sw06_02_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
sw06_03_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1
sw06_04_t1 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T1

sw06_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
sw06_02_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
sw06_03_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
sw06_04_t2 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T2
'

lcs_swls_group_12_weak <- sem(mi_lcs_swls_group_weak, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                           group = "group", group.equal = "loadings")

# strong invariance
mi_lcs_swls_group_strong <- '
swls_t1 =~ 1*sw06_01_t1 + c("lamb2", "lamb2")*sw06_02_t1 + c("lamb3", "lamb3")*sw06_03_t1 + c("lamb4", "lamb4")*sw06_04_t1 # This specifies the measurement model for swls_t1 
swls_t2 =~ 1*sw06_01_t2 + c("lamb2", "lamb2")*sw06_02_t2 + c("lamb3", "lamb3")*sw06_03_t2 + c("lamb4", "lamb4")*sw06_04_t2 # This specifies the measurement model for swls_t2 with the equality constrained factor loadings

swls_t2 ~ 1*swls_t1     # This parameter regresses swls_t2 perfectly on swls_t1
d_swls_1 =~ 1*swls_t2   # This defines the latent change score factor as measured perfectly by scores on swls_t2
swls_t2 ~ 0*1           # This line constrains the intercept of swls_t2 to 0
swls_t2 ~~ 0*swls_t2    # This fixes the variance of swls_t2 to 0

d_swls_1 ~ c("d_int", "d_int")*1           # This estimates the intercept of the change score 
swls_t1 ~ c("wb_int", "wb_int")*1            # This estimates the intercept of swls_t1 
d_swls_1 ~~ c("d_var_a", "d_var_b")*d_swls_1   # This estimates the variance of the change scores 
swls_t1 ~~ c("wb_var_a", "wb_var_b")*swls_t1     # This estimates the variance of the swls_t1 
d_swls_1 ~~ c("fb_a", "fb_b")*swls_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

sw06_01_t1 ~~ c("cov1a", "cov1b")*sw06_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
sw06_02_t1 ~~ c("cov2a", "cov2b")*sw06_02_t2   # This allows residual covariance on indicator X2 across T1 and T2
sw06_03_t1 ~~ c("cov3a", "cov3b")*sw06_03_t2   # This allows residual covariance on indicator X3 across T1 and T2
sw06_04_t1 ~~ c("cov4a", "cov4b")*sw06_04_t2   # This allows residual covariance on indicator X4 across T1 and T2

sw06_01_t1 ~~ c("res1a", "res1b")*sw06_01_t1   # This allows residual variance on indicator X1 at T1 
sw06_02_t1 ~~ c("res2a", "res2b")*sw06_02_t1   # This allows residual variance on indicator X2 at T1
sw06_03_t1 ~~ c("res3a", "res3b")*sw06_03_t1   # This allows residual variance on indicator X3 at T1
sw06_04_t1 ~~ c("res4a", "res4b")*sw06_04_t1   # This allows residual variance on indicator X4 at T1

sw06_01_t2 ~~ c("res1a", "res1b")*sw06_01_t2  # This allows residual variance on indicator X1 at T2 
sw06_02_t2 ~~ c("res2a", "res2b")*sw06_02_t2  # This allows residual variance on indicator X2 at T2 
sw06_03_t2 ~~ c("res3a", "res3b")*sw06_03_t2  # This allows residual variance on indicator X3 at T2
sw06_04_t2 ~~ c("res4a", "res4b")*sw06_04_t2  # This allows residual variance on indicator X4 at T2

sw06_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
sw06_02_t1 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T1
sw06_03_t1 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T1
sw06_04_t1 ~ c("m4", "m4")*1     # This estimates the intercept of X4 at T1

sw06_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
sw06_02_t2 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T2
sw06_03_t2 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T2
sw06_04_t2 ~ c("m4", "m4")*1     # This estimates the intercept of X4 at T2
'

lcs_swls_group_12_strong <- sem(mi_lcs_swls_group_strong, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                             group = "group", group.equal = c("intercepts", "loadings"))
```

Life satisfaction: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_swls_group_12_config, lcs_swls_group_12_weak, lcs_swls_group_12_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_swls_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_lcs_swls_group_12_weak <- broom::tidy(lcs_swls_group_12_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="swls" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_swls_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_lcs_swls_group_12_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_swls_group_12_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="swls" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_swls_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Slightly more positive change in life satisfaction in Group 2 compared to Group 1 but no substantial differences according to the LRTs.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_swls_group_12_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

##### Meaning in life

Meaning in life: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance
mi_lcs_meaning_group_config <- '
meaning_t1 =~ 1*ml01_01_t1 + c("lamb2a", "lamb2b")*ml01_04_t1 + c("lamb3a", "lamb3b")*ml01_05_t1 + c("lamb4a", "lamb4b")*ml01_06_t1 + c("lamb5a", "lamb5b")*ml01_09_t1 # This specifies the measurement model for meaning_t1 
meaning_t2 =~ 1*ml01_01_t2 + c("lamb2a", "lamb2b")*ml01_04_t2 + c("lamb3a", "lamb3b")*ml01_05_t2 + c("lamb4a", "lamb4b")*ml01_06_t2 + c("lamb5a", "lamb5b")*ml01_09_t2 # This specifies the measurement model for meaning_t2 with the equality constrained factor loadings

meaning_t2 ~ 1*meaning_t1     # This parameter regresses meaning_t2 perfectly on meaning_t1
d_meaning_1 =~ 1*meaning_t2   # This defines the latent change score factor as measured perfectly by scores on meaning_t2
meaning_t2 ~ 0*1           # This line constrains the intercept of meaning_t2 to 0
meaning_t2 ~~ 0*meaning_t2    # This fixes the variance of meaning_t2 to 0

d_meaning_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
meaning_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of meaning_t1 
d_meaning_1 ~~ c("d_var_a", "d_var_b")*d_meaning_1   # This estimates the variance of the change scores 
meaning_t1 ~~ c("wb_var_a", "wb_var_b")*meaning_t1     # This estimates the variance of the meaning_t1 
d_meaning_1 ~~ c("fb_a", "fb_b")*meaning_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ml01_01_t1 ~~ c("cov1a", "cov1b")*ml01_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_04_t1 ~~ c("cov2a", "cov2b")*ml01_04_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_05_t1 ~~ c("cov3a", "cov3b")*ml01_05_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_06_t1 ~~ c("cov4a", "cov4b")*ml01_06_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_09_t1 ~~ c("cov5a", "cov5b")*ml01_09_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_01_t1 ~~ c("res1a", "res1b")*ml01_01_t1   # This allows residual variance on indicator X1 at T1 
ml01_04_t1 ~~ c("res2a", "res2b")*ml01_04_t1   # This allows residual variance on indicator X2 at T1
ml01_05_t1 ~~ c("res3a", "res3b")*ml01_05_t1   # This allows residual variance on indicator X3 at T1
ml01_06_t1 ~~ c("res4a", "res4b")*ml01_06_t1   # This allows residual variance on indicator X4 at T1
ml01_09_t1 ~~ c("res5a", "res5b")*ml01_09_t1   # This allows residual variance on indicator X5 at T1

ml01_01_t2 ~~ c("res1a", "res1b")*ml01_01_t2  # This allows residual variance on indicator X1 at T2 
ml01_04_t2 ~~ c("res2a", "res2b")*ml01_04_t2  # This allows residual variance on indicator X2 at T2 
ml01_05_t2 ~~ c("res3a", "res3b")*ml01_05_t2  # This allows residual variance on indicator X3 at T2
ml01_06_t2 ~~ c("res4a", "res4b")*ml01_06_t2  # This allows residual variance on indicator X4 at T2
ml01_09_t2 ~~ c("res5a", "res5b")*ml01_09_t2  # This allows residual variance on indicator X5 at T2

ml01_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_04_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
ml01_05_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1
ml01_06_t1 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T1
ml01_09_t1 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T1

ml01_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_04_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
ml01_05_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
ml01_06_t2 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T2
ml01_09_t2 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T2
'
lcs_meaning_group_12_config <- sem(mi_lcs_meaning_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', 
                                fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance
mi_lcs_meaning_group_weak <- '
meaning_t1 =~ 1*ml01_01_t1 + c("lamb2", "lamb2")*ml01_04_t1 + c("lamb3", "lamb3")*ml01_05_t1 + c("lamb4", "lamb4")*ml01_06_t1 + c("lamb5", "lamb5")*ml01_09_t1 # This specifies the measurement model for meaning_t1 
meaning_t2 =~ 1*ml01_01_t2 + c("lamb2", "lamb2")*ml01_04_t2 + c("lamb3", "lamb3")*ml01_05_t2 + c("lamb4", "lamb4")*ml01_06_t2 + c("lamb5", "lamb5")*ml01_09_t2 # This specifies the measurement model for meaning_t2 with the equality constrained factor loadings

meaning_t2 ~ 1*meaning_t1     # This parameter regresses meaning_t2 perfectly on meaning_t1
d_meaning_1 =~ 1*meaning_t2   # This defines the latent change score factor as measured perfectly by scores on meaning_t2
meaning_t2 ~ 0*1           # This line constrains the intercept of meaning_t2 to 0
meaning_t2 ~~ 0*meaning_t2    # This fixes the variance of meaning_t2 to 0

d_meaning_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
meaning_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of meaning_t1 
d_meaning_1 ~~ c("d_var_a", "d_var_b")*d_meaning_1   # This estimates the variance of the change scores 
meaning_t1 ~~ c("wb_var_a", "wb_var_b")*meaning_t1     # This estimates the variance of the meaning_t1 
d_meaning_1 ~~ c("fb_a", "fb_b")*meaning_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ml01_01_t1 ~~ c("cov1a", "cov1b")*ml01_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_04_t1 ~~ c("cov2a", "cov2b")*ml01_04_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_05_t1 ~~ c("cov3a", "cov3b")*ml01_05_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_06_t1 ~~ c("cov4a", "cov4b")*ml01_06_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_09_t1 ~~ c("cov5a", "cov5b")*ml01_09_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_01_t1 ~~ c("res1a", "res1b")*ml01_01_t1   # This allows residual variance on indicator X1 at T1 
ml01_04_t1 ~~ c("res2a", "res2b")*ml01_04_t1   # This allows residual variance on indicator X2 at T1
ml01_05_t1 ~~ c("res3a", "res3b")*ml01_05_t1   # This allows residual variance on indicator X3 at T1
ml01_06_t1 ~~ c("res4a", "res4b")*ml01_06_t1   # This allows residual variance on indicator X4 at T1
ml01_09_t1 ~~ c("res5a", "res5b")*ml01_09_t1   # This allows residual variance on indicator X5 at T1

ml01_01_t2 ~~ c("res1a", "res1b")*ml01_01_t2  # This allows residual variance on indicator X1 at T2 
ml01_04_t2 ~~ c("res2a", "res2b")*ml01_04_t2  # This allows residual variance on indicator X2 at T2 
ml01_05_t2 ~~ c("res3a", "res3b")*ml01_05_t2  # This allows residual variance on indicator X3 at T2
ml01_06_t2 ~~ c("res4a", "res4b")*ml01_06_t2  # This allows residual variance on indicator X4 at T2
ml01_09_t2 ~~ c("res5a", "res5b")*ml01_09_t2  # This allows residual variance on indicator X5 at T2

ml01_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_04_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
ml01_05_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1
ml01_06_t1 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T1
ml01_09_t1 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T1

ml01_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_04_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
ml01_05_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
ml01_06_t2 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T2
ml01_09_t2 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T2
'

lcs_meaning_group_12_weak <- sem(mi_lcs_meaning_group_weak, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                           group = "group", group.equal = "loadings")

# strong invariance
mi_lcs_meaning_group_strong <- '
meaning_t1 =~ 1*ml01_01_t1 + c("lamb2", "lamb2")*ml01_04_t1 + c("lamb3", "lamb3")*ml01_05_t1 + c("lamb4", "lamb4")*ml01_06_t1 + c("lamb5", "lamb5")*ml01_09_t1 # This specifies the measurement model for meaning_t1 
meaning_t2 =~ 1*ml01_01_t2 + c("lamb2", "lamb2")*ml01_04_t2 + c("lamb3", "lamb3")*ml01_05_t2 + c("lamb4", "lamb4")*ml01_06_t2 + c("lamb5", "lamb5")*ml01_09_t2 # This specifies the measurement model for meaning_t2 with the equality constrained factor loadings

meaning_t2 ~ 1*meaning_t1     # This parameter regresses meaning_t2 perfectly on meaning_t1
d_meaning_1 =~ 1*meaning_t2   # This defines the latent change score factor as measured perfectly by scores on meaning_t2
meaning_t2 ~ 0*1           # This line constrains the intercept of meaning_t2 to 0
meaning_t2 ~~ 0*meaning_t2    # This fixes the variance of meaning_t2 to 0

d_meaning_1 ~ c("d_int", "d_int")*1           # This estimates the intercept of the change score 
meaning_t1 ~ c("wb_int", "wb_int")*1            # This estimates the intercept of meaning_t1 
d_meaning_1 ~~ c("d_var_a", "d_var_b")*d_meaning_1   # This estimates the variance of the change scores 
meaning_t1 ~~ c("wb_var_a", "wb_var_b")*meaning_t1     # This estimates the variance of the meaning_t1 
d_meaning_1 ~~ c("fb_a", "fb_b")*meaning_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ml01_01_t1 ~~ c("cov1a", "cov1b")*ml01_01_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_04_t1 ~~ c("cov2a", "cov2b")*ml01_04_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_05_t1 ~~ c("cov3a", "cov3b")*ml01_05_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_06_t1 ~~ c("cov4a", "cov4b")*ml01_06_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_09_t1 ~~ c("cov5a", "cov5b")*ml01_09_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_01_t1 ~~ c("res1a", "res1b")*ml01_01_t1   # This allows residual variance on indicator X1 at T1 
ml01_04_t1 ~~ c("res2a", "res2b")*ml01_04_t1   # This allows residual variance on indicator X2 at T1
ml01_05_t1 ~~ c("res3a", "res3b")*ml01_05_t1   # This allows residual variance on indicator X3 at T1
ml01_06_t1 ~~ c("res4a", "res4b")*ml01_06_t1   # This allows residual variance on indicator X4 at T1
ml01_09_t1 ~~ c("res5a", "res5b")*ml01_09_t1   # This allows residual variance on indicator X5 at T1

ml01_01_t2 ~~ c("res1a", "res1b")*ml01_01_t2  # This allows residual variance on indicator X1 at T2 
ml01_04_t2 ~~ c("res2a", "res2b")*ml01_04_t2  # This allows residual variance on indicator X2 at T2 
ml01_05_t2 ~~ c("res3a", "res3b")*ml01_05_t2  # This allows residual variance on indicator X3 at T2
ml01_06_t2 ~~ c("res4a", "res4b")*ml01_06_t2  # This allows residual variance on indicator X4 at T2
ml01_09_t2 ~~ c("res5a", "res5b")*ml01_09_t2  # This allows residual variance on indicator X5 at T2

ml01_01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_04_t1 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T1
ml01_05_t1 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T1
ml01_06_t1 ~ c("m4", "m4")*1     # This estimates the intercept of X4 at T1
ml01_09_t1 ~ c("m5", "m5")*1     # This estimates the intercept of X5 at T1

ml01_01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_04_t2 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T2
ml01_05_t2 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T2
ml01_06_t2 ~ c("m4", "m4")*1     # This estimates the intercept of X4 at T2
ml01_09_t2 ~ c("m5", "m5")*1     # This estimates the intercept of X5 at T2
'

lcs_meaning_group_12_strong <- sem(mi_lcs_meaning_group_strong, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                             group = "group", group.equal = c("intercepts", "loadings"))
```

Meaning in life: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_meaning_group_12_config, lcs_meaning_group_12_weak, lcs_meaning_group_12_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_meaning_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_lcs_meaning_group_12_weak <- broom::tidy(lcs_meaning_group_12_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="meaning" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_meaning_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_lcs_meaning_group_12_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_meaning_group_12_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="meaning" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_meaning_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Very similar degree of positive change in meaning in life in both groups and no substantial differences according to the LRTs.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_meaning_group_12_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

###### Search for Meaning

Search for Meaning (see preregistration deviation): fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance
mi_lcs_search_group_config <- '
search_t1 =~ 1*ml01_02_t1 + c("lamb2a", "lamb2b")*ml01_03_t1 + c("lamb3a", "lamb3b")*ml01_07_t1 + c("lamb4a", "lamb4b")*ml01_08_t1 + c("lamb5a", "lamb5b")*ml01_10_t1 # This specifies the measurement model for search_t1 
search_t2 =~ 1*ml01_02_t2 + c("lamb2a", "lamb2b")*ml01_03_t2 + c("lamb3a", "lamb3b")*ml01_07_t2 + c("lamb4a", "lamb4b")*ml01_08_t2 + c("lamb5a", "lamb5b")*ml01_10_t2 # This specifies the measurement model for search_t2 with the equality constrained factor loadings

search_t2 ~ 1*search_t1     # This parameter regresses search_t2 perfectly on search_t1
d_search_1 =~ 1*search_t2   # This defines the latent change score factor as measured perfectly by scores on search_t2
search_t2 ~ 0*1           # This line constrains the intercept of search_t2 to 0
search_t2 ~~ 0*search_t2    # This fixes the variance of search_t2 to 0

d_search_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
search_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of search_t1 
d_search_1 ~~ c("d_var_a", "d_var_b")*d_search_1   # This estimates the variance of the change scores 
search_t1 ~~ c("wb_var_a", "wb_var_b")*search_t1     # This estimates the variance of the search_t1 
d_search_1 ~~ c("fb_a", "fb_b")*search_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ml01_02_t1 ~~ c("cov1a", "cov1b")*ml01_02_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_03_t1 ~~ c("cov2a", "cov2b")*ml01_03_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_07_t1 ~~ c("cov3a", "cov3b")*ml01_07_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_08_t1 ~~ c("cov4a", "cov4b")*ml01_08_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_10_t1 ~~ c("cov5a", "cov5b")*ml01_10_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_02_t1 ~~ c("res1a", "res1b")*ml01_02_t1   # This allows residual variance on indicator X1 at T1 
ml01_03_t1 ~~ c("res2a", "res2b")*ml01_03_t1   # This allows residual variance on indicator X2 at T1
ml01_07_t1 ~~ c("res3a", "res3b")*ml01_07_t1   # This allows residual variance on indicator X3 at T1
ml01_08_t1 ~~ c("res4a", "res4b")*ml01_08_t1   # This allows residual variance on indicator X4 at T1
ml01_10_t1 ~~ c("res5a", "res5b")*ml01_10_t1   # This allows residual variance on indicator X5 at T1

ml01_02_t2 ~~ c("res1a", "res1b")*ml01_02_t2  # This allows residual variance on indicator X1 at T2 
ml01_03_t2 ~~ c("res2a", "res2b")*ml01_03_t2  # This allows residual variance on indicator X2 at T2 
ml01_07_t2 ~~ c("res3a", "res3b")*ml01_07_t2  # This allows residual variance on indicator X3 at T2
ml01_08_t2 ~~ c("res4a", "res4b")*ml01_08_t2  # This allows residual variance on indicator X4 at T2
ml01_10_t2 ~~ c("res5a", "res5b")*ml01_10_t2  # This allows residual variance on indicator X5 at T2

ml01_02_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_03_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
ml01_07_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1
ml01_08_t1 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T1
ml01_10_t1 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T1

ml01_02_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_03_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
ml01_07_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
ml01_08_t2 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T2
ml01_10_t2 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T2
'
lcs_search_group_12_config <- sem(mi_lcs_search_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', 
                                fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance
mi_lcs_search_group_weak <- '
search_t1 =~ 1*ml01_02_t1 + c("lamb2", "lamb2")*ml01_03_t1 + c("lamb3", "lamb3")*ml01_07_t1 + c("lamb4", "lamb4")*ml01_08_t1 + c("lamb5", "lamb5")*ml01_10_t1 # This specifies the measurement model for search_t1 
search_t2 =~ 1*ml01_02_t2 + c("lamb2", "lamb2")*ml01_03_t2 + c("lamb3", "lamb3")*ml01_07_t2 + c("lamb4", "lamb4")*ml01_08_t2 + c("lamb5", "lamb5")*ml01_10_t2 # This specifies the measurement model for search_t2 with the equality constrained factor loadings

search_t2 ~ 1*search_t1     # This parameter regresses search_t2 perfectly on search_t1
d_search_1 =~ 1*search_t2   # This defines the latent change score factor as measured perfectly by scores on search_t2
search_t2 ~ 0*1           # This line constrains the intercept of search_t2 to 0
search_t2 ~~ 0*search_t2    # This fixes the variance of search_t2 to 0

d_search_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
search_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of search_t1 
d_search_1 ~~ c("d_var_a", "d_var_b")*d_search_1   # This estimates the variance of the change scores 
search_t1 ~~ c("wb_var_a", "wb_var_b")*search_t1     # This estimates the variance of the search_t1 
d_search_1 ~~ c("fb_a", "fb_b")*search_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ml01_02_t1 ~~ c("cov1a", "cov1b")*ml01_02_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_03_t1 ~~ c("cov2a", "cov2b")*ml01_03_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_07_t1 ~~ c("cov3a", "cov3b")*ml01_07_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_08_t1 ~~ c("cov4a", "cov4b")*ml01_08_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_10_t1 ~~ c("cov5a", "cov5b")*ml01_10_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_02_t1 ~~ c("res1a", "res1b")*ml01_02_t1   # This allows residual variance on indicator X1 at T1 
ml01_03_t1 ~~ c("res2a", "res2b")*ml01_03_t1   # This allows residual variance on indicator X2 at T1
ml01_07_t1 ~~ c("res3a", "res3b")*ml01_07_t1   # This allows residual variance on indicator X3 at T1
ml01_08_t1 ~~ c("res4a", "res4b")*ml01_08_t1   # This allows residual variance on indicator X4 at T1
ml01_10_t1 ~~ c("res5a", "res5b")*ml01_10_t1   # This allows residual variance on indicator X5 at T1

ml01_02_t2 ~~ c("res1a", "res1b")*ml01_02_t2  # This allows residual variance on indicator X1 at T2 
ml01_03_t2 ~~ c("res2a", "res2b")*ml01_03_t2  # This allows residual variance on indicator X2 at T2 
ml01_07_t2 ~~ c("res3a", "res3b")*ml01_07_t2  # This allows residual variance on indicator X3 at T2
ml01_08_t2 ~~ c("res4a", "res4b")*ml01_08_t2  # This allows residual variance on indicator X4 at T2
ml01_10_t2 ~~ c("res5a", "res5b")*ml01_10_t2  # This allows residual variance on indicator X5 at T2

ml01_02_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_03_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
ml01_07_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1
ml01_08_t1 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T1
ml01_10_t1 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T1

ml01_02_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_03_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
ml01_07_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
ml01_08_t2 ~ c("m4a", "m4b")*1     # This estimates the intercept of X4 at T2
ml01_10_t2 ~ c("m5a", "m5b")*1     # This estimates the intercept of X5 at T2
'

lcs_search_group_12_weak <- sem(mi_lcs_search_group_weak, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                           group = "group", group.equal = "loadings")

# strong invariance
mi_lcs_search_group_strong <- '
search_t1 =~ 1*ml01_02_t1 + c("lamb2", "lamb2")*ml01_03_t1 + c("lamb3", "lamb3")*ml01_07_t1 + c("lamb4", "lamb4")*ml01_08_t1 + c("lamb5", "lamb5")*ml01_10_t1 # This specifies the measurement model for search_t1 
search_t2 =~ 1*ml01_02_t2 + c("lamb2", "lamb2")*ml01_03_t2 + c("lamb3", "lamb3")*ml01_07_t2 + c("lamb4", "lamb4")*ml01_08_t2 + c("lamb5", "lamb5")*ml01_10_t2 # This specifies the measurement model for search_t2 with the equality constrained factor loadings

search_t2 ~ 1*search_t1     # This parameter regresses search_t2 perfectly on search_t1
d_search_1 =~ 1*search_t2   # This defines the latent change score factor as measured perfectly by scores on search_t2
search_t2 ~ 0*1           # This line constrains the intercept of search_t2 to 0
search_t2 ~~ 0*search_t2    # This fixes the variance of search_t2 to 0

d_search_1 ~ c("d_int", "d_int")*1           # This estimates the intercept of the change score 
search_t1 ~ c("wb_int", "wb_int")*1            # This estimates the intercept of search_t1 
d_search_1 ~~ c("d_var_a", "d_var_b")*d_search_1   # This estimates the variance of the change scores 
search_t1 ~~ c("wb_var_a", "wb_var_b")*search_t1     # This estimates the variance of the search_t1 
d_search_1 ~~ c("fb_a", "fb_b")*search_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ml01_02_t1 ~~ c("cov1a", "cov1b")*ml01_02_t2   # This allows residual covariance on indicator X1 across T1 and T2
ml01_03_t1 ~~ c("cov2a", "cov2b")*ml01_03_t2   # This allows residual covariance on indicator X2 across T1 and T2
ml01_07_t1 ~~ c("cov3a", "cov3b")*ml01_07_t2   # This allows residual covariance on indicator X3 across T1 and T2
ml01_08_t1 ~~ c("cov4a", "cov4b")*ml01_08_t2   # This allows residual covariance on indicator X4 across T1 and T2
ml01_10_t1 ~~ c("cov5a", "cov5b")*ml01_10_t2   # This allows residual covariance on indicator X5 across T1 and T2

ml01_02_t1 ~~ c("res1a", "res1b")*ml01_02_t1   # This allows residual variance on indicator X1 at T1 
ml01_03_t1 ~~ c("res2a", "res2b")*ml01_03_t1   # This allows residual variance on indicator X2 at T1
ml01_07_t1 ~~ c("res3a", "res3b")*ml01_07_t1   # This allows residual variance on indicator X3 at T1
ml01_08_t1 ~~ c("res4a", "res4b")*ml01_08_t1   # This allows residual variance on indicator X4 at T1
ml01_10_t1 ~~ c("res5a", "res5b")*ml01_10_t1   # This allows residual variance on indicator X5 at T1

ml01_02_t2 ~~ c("res1a", "res1b")*ml01_02_t2  # This allows residual variance on indicator X1 at T2 
ml01_03_t2 ~~ c("res2a", "res2b")*ml01_03_t2  # This allows residual variance on indicator X2 at T2 
ml01_07_t2 ~~ c("res3a", "res3b")*ml01_07_t2  # This allows residual variance on indicator X3 at T2
ml01_08_t2 ~~ c("res4a", "res4b")*ml01_08_t2  # This allows residual variance on indicator X4 at T2
ml01_10_t2 ~~ c("res5a", "res5b")*ml01_10_t2  # This allows residual variance on indicator X5 at T2

ml01_02_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ml01_03_t1 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T1
ml01_07_t1 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T1
ml01_08_t1 ~ c("m4", "m4")*1     # This estimates the intercept of X4 at T1
ml01_10_t1 ~ c("m5", "m5")*1     # This estimates the intercept of X5 at T1

ml01_02_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ml01_03_t2 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T2
ml01_07_t2 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T2
ml01_08_t2 ~ c("m4", "m4")*1     # This estimates the intercept of X4 at T2
ml01_10_t2 ~ c("m5", "m5")*1     # This estimates the intercept of X5 at T2
'

lcs_search_group_12_strong <- sem(mi_lcs_search_group_strong, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                             group = "group", group.equal = c("intercepts", "loadings"))
```

Meaning in life: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_search_group_12_config, lcs_search_group_12_weak, lcs_search_group_12_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_search_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_lcs_search_group_12_weak <- broom::tidy(lcs_search_group_12_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="search" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_search_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_lcs_search_group_12_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_search_group_12_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="search" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_search_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Very similar degree of positive change in search for meaning in life in both groups and no substantial differences (in means) according to the LRTs.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_search_group_12_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

##### Self-esteem 

Self-esteem: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance
mi_lcs_selfes_group_config <- '
selfes_t1 =~ 1*selfes_par1_t1 + c("lamb2a", "lamb2b")*selfes_par2_t1 + c("lamb3a", "lamb3b")*selfes_par3_t1 # This specifies the measurement model for selfes_t1 
selfes_t2 =~ 1*selfes_par1_t2 + c("lamb2a", "lamb2b")*selfes_par2_t2 + c("lamb3a", "lamb3b")*selfes_par3_t2 # This specifies the measurement model for selfes_t2 with the equality constrained factor loadings

selfes_t2 ~ 1*selfes_t1     # This parameter regresses selfes_t2 perfectly on selfes_t1
d_selfes_1 =~ 1*selfes_t2   # This defines the latent change score factor as measured perfectly by scores on selfes_t2
selfes_t2 ~ 0*1           # This line constrains the intercept of selfes_t2 to 0
selfes_t2 ~~ 0*selfes_t2    # This fixes the variance of selfes_t2 to 0

d_selfes_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
selfes_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of selfes_t1 
d_selfes_1 ~~ c("d_var_a", "d_var_b")*d_selfes_1   # This estimates the variance of the change scores 
selfes_t1 ~~ c("wb_var_a", "wb_var_b")*selfes_t1     # This estimates the variance of the selfes_t1 
d_selfes_1 ~~ c("fb_a", "fb_b")*selfes_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

selfes_par1_t1 ~~ c("cov1a", "cov1b")*selfes_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
selfes_par2_t1 ~~ c("cov2a", "cov2b")*selfes_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
selfes_par3_t1 ~~ c("cov3a", "cov3b")*selfes_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

selfes_par1_t1 ~~ c("res1a", "res1b")*selfes_par1_t1   # This allows residual variance on indicator X1 at T1 
selfes_par2_t1 ~~ c("res2a", "res2b")*selfes_par2_t1   # This allows residual variance on indicator X2 at T1
selfes_par3_t1 ~~ c("res3a", "res3b")*selfes_par3_t1   # This allows residual variance on indicator X3 at T1

selfes_par1_t2 ~~ c("res1a", "res1b")*selfes_par1_t2  # This allows residual variance on indicator X1 at T2 
selfes_par2_t2 ~~ c("res2a", "res2b")*selfes_par2_t2  # This allows residual variance on indicator X2 at T2 
selfes_par3_t2 ~~ c("res3a", "res3b")*selfes_par3_t2  # This allows residual variance on indicator X3 at T2

selfes_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
selfes_par2_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
selfes_par3_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1

selfes_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
selfes_par2_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
selfes_par3_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
'
lcs_selfes_group_12_config <- sem(mi_lcs_selfes_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', 
                                fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance
mi_lcs_selfes_group_weak <- '
selfes_t1 =~ 1*selfes_par1_t1 + c("lamb2", "lamb2")*selfes_par2_t1 + c("lamb3", "lamb3")*selfes_par3_t1 # This specifies the measurement model for selfes_t1 
selfes_t2 =~ 1*selfes_par1_t2 + c("lamb2", "lamb2")*selfes_par2_t2 + c("lamb3", "lamb3")*selfes_par3_t2 # This specifies the measurement model for selfes_t2 with the equality constrained factor loadings

selfes_t2 ~ 1*selfes_t1     # This parameter regresses selfes_t2 perfectly on selfes_t1
d_selfes_1 =~ 1*selfes_t2   # This defines the latent change score factor as measured perfectly by scores on selfes_t2
selfes_t2 ~ 0*1           # This line constrains the intercept of selfes_t2 to 0
selfes_t2 ~~ 0*selfes_t2    # This fixes the variance of selfes_t2 to 0

d_selfes_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
selfes_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of selfes_t1 
d_selfes_1 ~~ c("d_var_a", "d_var_b")*d_selfes_1   # This estimates the variance of the change scores 
selfes_t1 ~~ c("wb_var_a", "wb_var_b")*selfes_t1     # This estimates the variance of the selfes_t1 
d_selfes_1 ~~ c("fb_a", "fb_b")*selfes_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

selfes_par1_t1 ~~ c("cov1a", "cov1b")*selfes_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
selfes_par2_t1 ~~ c("cov2a", "cov2b")*selfes_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
selfes_par3_t1 ~~ c("cov3a", "cov3b")*selfes_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

selfes_par1_t1 ~~ c("res1a", "res1b")*selfes_par1_t1   # This allows residual variance on indicator X1 at T1 
selfes_par2_t1 ~~ c("res2a", "res2b")*selfes_par2_t1   # This allows residual variance on indicator X2 at T1
selfes_par3_t1 ~~ c("res3a", "res3b")*selfes_par3_t1   # This allows residual variance on indicator X3 at T1

selfes_par1_t2 ~~ c("res1a", "res1b")*selfes_par1_t2  # This allows residual variance on indicator X1 at T2 
selfes_par2_t2 ~~ c("res2a", "res2b")*selfes_par2_t2  # This allows residual variance on indicator X2 at T2 
selfes_par3_t2 ~~ c("res3a", "res3b")*selfes_par3_t2  # This allows residual variance on indicator X3 at T2

selfes_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
selfes_par2_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
selfes_par3_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1

selfes_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
selfes_par2_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
selfes_par3_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
'

lcs_selfes_group_12_weak <- sem(mi_lcs_selfes_group_weak, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                           group = "group", group.equal = "loadings")

# strong invariance
mi_lcs_selfes_group_strong <- '
selfes_t1 =~ 1*selfes_par1_t1 + c("lamb2", "lamb2")*selfes_par2_t1 + c("lamb3", "lamb3")*selfes_par3_t1 # This specifies the measurement model for selfes_t1 
selfes_t2 =~ 1*selfes_par1_t2 + c("lamb2", "lamb2")*selfes_par2_t2 + c("lamb3", "lamb3")*selfes_par3_t2 # This specifies the measurement model for selfes_t2 with the equality constrained factor loadings

selfes_t2 ~ 1*selfes_t1     # This parameter regresses selfes_t2 perfectly on selfes_t1
d_selfes_1 =~ 1*selfes_t2   # This defines the latent change score factor as measured perfectly by scores on selfes_t2
selfes_t2 ~ 0*1           # This line constrains the intercept of selfes_t2 to 0
selfes_t2 ~~ 0*selfes_t2    # This fixes the variance of selfes_t2 to 0

d_selfes_1 ~ c("d_int", "d_int")*1           # This estimates the intercept of the change score 
selfes_t1 ~ c("wb_int", "wb_int")*1            # This estimates the intercept of selfes_t1 
d_selfes_1 ~~ c("d_var_a", "d_var_b")*d_selfes_1   # This estimates the variance of the change scores 
selfes_t1 ~~ c("wb_var_a", "wb_var_b")*selfes_t1     # This estimates the variance of the selfes_t1 
d_selfes_1 ~~ c("fb_a", "fb_b")*selfes_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

selfes_par1_t1 ~~ c("cov1a", "cov1b")*selfes_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
selfes_par2_t1 ~~ c("cov2a", "cov2b")*selfes_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
selfes_par3_t1 ~~ c("cov3a", "cov3b")*selfes_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

selfes_par1_t1 ~~ c("res1a", "res1b")*selfes_par1_t1   # This allows residual variance on indicator X1 at T1 
selfes_par2_t1 ~~ c("res2a", "res2b")*selfes_par2_t1   # This allows residual variance on indicator X2 at T1
selfes_par3_t1 ~~ c("res3a", "res3b")*selfes_par3_t1   # This allows residual variance on indicator X3 at T1

selfes_par1_t2 ~~ c("res1a", "res1b")*selfes_par1_t2  # This allows residual variance on indicator X1 at T2 
selfes_par2_t2 ~~ c("res2a", "res2b")*selfes_par2_t2  # This allows residual variance on indicator X2 at T2 
selfes_par3_t2 ~~ c("res3a", "res3b")*selfes_par3_t2  # This allows residual variance on indicator X3 at T2

selfes_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
selfes_par2_t1 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T1
selfes_par3_t1 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T1

selfes_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
selfes_par2_t2 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T2
selfes_par3_t2 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T2
'

lcs_selfes_group_12_strong <- sem(mi_lcs_selfes_group_strong, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                             group = "group", group.equal = c("intercepts", "loadings"))
```

Meaning in life: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_selfes_group_12_config, lcs_selfes_group_12_weak, lcs_selfes_group_12_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_selfes_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_lcs_selfes_group_12_weak <- broom::tidy(lcs_selfes_group_12_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="selfes" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_selfes_1 ~1 ")) %>% mutate(sig_diff = "**")
kable(params_lcs_selfes_group_12_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_selfes_group_12_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="selfes" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_selfes_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Significantly more positive change in self-esteem in Group 2 compared to Group 1. 
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_selfes_group_12_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

##### Self-concept clarity 

Self-concept clarity: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance
mi_lcs_concept_group_config <- '
concept_t1 =~ 1*concept_par1_t1 + c("lamb2a", "lamb2b")*concept_par2_t1 + c("lamb3a", "lamb3b")*concept_par3_t1 # This specifies the measurement model for concept_t1 
concept_t2 =~ 1*concept_par1_t2 + c("lamb2a", "lamb2b")*concept_par2_t2 + c("lamb3a", "lamb3b")*concept_par3_t2 # This specifies the measurement model for concept_t2 with the equality constrained factor loadings

concept_t2 ~ 1*concept_t1     # This parameter regresses concept_t2 perfectly on concept_t1
d_concept_1 =~ 1*concept_t2   # This defines the latent change score factor as measured perfectly by scores on concept_t2
concept_t2 ~ 0*1           # This line constrains the intercept of concept_t2 to 0
concept_t2 ~~ 0*concept_t2    # This fixes the variance of concept_t2 to 0

d_concept_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
concept_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of concept_t1 
d_concept_1 ~~ c("d_var_a", "d_var_b")*d_concept_1   # This estimates the variance of the change scores 
concept_t1 ~~ c("wb_var_a", "wb_var_b")*concept_t1     # This estimates the variance of the concept_t1 
d_concept_1 ~~ c("fb_a", "fb_b")*concept_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

concept_par1_t1 ~~ c("cov1a", "cov1b")*concept_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
concept_par2_t1 ~~ c("cov2a", "cov2b")*concept_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
concept_par3_t1 ~~ c("cov3a", "cov3b")*concept_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

concept_par1_t1 ~~ c("res1a", "res1b")*concept_par1_t1   # This allows residual variance on indicator X1 at T1 
concept_par2_t1 ~~ c("res2a", "res2b")*concept_par2_t1   # This allows residual variance on indicator X2 at T1
concept_par3_t1 ~~ c("res3a", "res3b")*concept_par3_t1   # This allows residual variance on indicator X3 at T1

concept_par1_t2 ~~ c("res1a", "res1b")*concept_par1_t2  # This allows residual variance on indicator X1 at T2 
concept_par2_t2 ~~ c("res2a", "res2b")*concept_par2_t2  # This allows residual variance on indicator X2 at T2 
concept_par3_t2 ~~ c("res3a", "res3b")*concept_par3_t2  # This allows residual variance on indicator X3 at T2

concept_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
concept_par2_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
concept_par3_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1

concept_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
concept_par2_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
concept_par3_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
'
lcs_concept_group_12_config <- sem(mi_lcs_concept_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', 
                                fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance
mi_lcs_concept_group_weak <- '
concept_t1 =~ 1*concept_par1_t1 + c("lamb2", "lamb2")*concept_par2_t1 + c("lamb3", "lamb3")*concept_par3_t1 # This specifies the measurement model for concept_t1 
concept_t2 =~ 1*concept_par1_t2 + c("lamb2", "lamb2")*concept_par2_t2 + c("lamb3", "lamb3")*concept_par3_t2 # This specifies the measurement model for concept_t2 with the equality constrained factor loadings

concept_t2 ~ 1*concept_t1     # This parameter regresses concept_t2 perfectly on concept_t1
d_concept_1 =~ 1*concept_t2   # This defines the latent change score factor as measured perfectly by scores on concept_t2
concept_t2 ~ 0*1           # This line constrains the intercept of concept_t2 to 0
concept_t2 ~~ 0*concept_t2    # This fixes the variance of concept_t2 to 0

d_concept_1 ~ c("d_int_a", "d_int_b")*1           # This estimates the intercept of the change score 
concept_t1 ~ c("wb_int_a", "wb_int_b")*1            # This estimates the intercept of concept_t1 
d_concept_1 ~~ c("d_var_a", "d_var_b")*d_concept_1   # This estimates the variance of the change scores 
concept_t1 ~~ c("wb_var_a", "wb_var_b")*concept_t1     # This estimates the variance of the concept_t1 
d_concept_1 ~~ c("fb_a", "fb_b")*concept_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

concept_par1_t1 ~~ c("cov1a", "cov1b")*concept_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
concept_par2_t1 ~~ c("cov2a", "cov2b")*concept_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
concept_par3_t1 ~~ c("cov3a", "cov3b")*concept_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

concept_par1_t1 ~~ c("res1a", "res1b")*concept_par1_t1   # This allows residual variance on indicator X1 at T1 
concept_par2_t1 ~~ c("res2a", "res2b")*concept_par2_t1   # This allows residual variance on indicator X2 at T1
concept_par3_t1 ~~ c("res3a", "res3b")*concept_par3_t1   # This allows residual variance on indicator X3 at T1

concept_par1_t2 ~~ c("res1a", "res1b")*concept_par1_t2  # This allows residual variance on indicator X1 at T2 
concept_par2_t2 ~~ c("res2a", "res2b")*concept_par2_t2  # This allows residual variance on indicator X2 at T2 
concept_par3_t2 ~~ c("res3a", "res3b")*concept_par3_t2  # This allows residual variance on indicator X3 at T2

concept_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
concept_par2_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
concept_par3_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1

concept_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
concept_par2_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
concept_par3_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
'

lcs_concept_group_12_weak <- sem(mi_lcs_concept_group_weak, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                           group = "group", group.equal = "loadings")

# strong invariance
mi_lcs_concept_group_strong <- '
concept_t1 =~ 1*concept_par1_t1 + c("lamb2", "lamb2")*concept_par2_t1 + c("lamb3", "lamb3")*concept_par3_t1 # This specifies the measurement model for concept_t1 
concept_t2 =~ 1*concept_par1_t2 + c("lamb2", "lamb2")*concept_par2_t2 + c("lamb3", "lamb3")*concept_par3_t2 # This specifies the measurement model for concept_t2 with the equality constrained factor loadings

concept_t2 ~ 1*concept_t1     # This parameter regresses concept_t2 perfectly on concept_t1
d_concept_1 =~ 1*concept_t2   # This defines the latent change score factor as measured perfectly by scores on concept_t2
concept_t2 ~ 0*1           # This line constrains the intercept of concept_t2 to 0
concept_t2 ~~ 0*concept_t2    # This fixes the variance of concept_t2 to 0

d_concept_1 ~ c("d_int", "d_int")*1           # This estimates the intercept of the change score 
concept_t1 ~ c("wb_int", "wb_int")*1            # This estimates the intercept of concept_t1 
d_concept_1 ~~ c("d_var_a", "d_var_b")*d_concept_1   # This estimates the variance of the change scores 
concept_t1 ~~ c("wb_var_a", "wb_var_b")*concept_t1     # This estimates the variance of the concept_t1 
d_concept_1 ~~ c("fb_a", "fb_b")*concept_t1     # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

concept_par1_t1 ~~ c("cov1a", "cov1b")*concept_par1_t2   # This allows residual covariance on indicator X1 across T1 and T2
concept_par2_t1 ~~ c("cov2a", "cov2b")*concept_par2_t2   # This allows residual covariance on indicator X2 across T1 and T2
concept_par3_t1 ~~ c("cov3a", "cov3b")*concept_par3_t2   # This allows residual covariance on indicator X3 across T1 and T2

concept_par1_t1 ~~ c("res1a", "res1b")*concept_par1_t1   # This allows residual variance on indicator X1 at T1 
concept_par2_t1 ~~ c("res2a", "res2b")*concept_par2_t1   # This allows residual variance on indicator X2 at T1
concept_par3_t1 ~~ c("res3a", "res3b")*concept_par3_t1   # This allows residual variance on indicator X3 at T1

concept_par1_t2 ~~ c("res1a", "res1b")*concept_par1_t2  # This allows residual variance on indicator X1 at T2 
concept_par2_t2 ~~ c("res2a", "res2b")*concept_par2_t2  # This allows residual variance on indicator X2 at T2 
concept_par3_t2 ~~ c("res3a", "res3b")*concept_par3_t2  # This allows residual variance on indicator X3 at T2

concept_par1_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
concept_par2_t1 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T1
concept_par3_t1 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T1

concept_par1_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
concept_par2_t2 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T2
concept_par3_t2 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T2
'

lcs_concept_group_12_strong <- sem(mi_lcs_concept_group_strong, data=df_sbsa3_wide_wb %>% filter(group!="Group 3"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                             group = "group", group.equal = c("intercepts", "loadings"))
```

Self-concept clarity: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_concept_group_12_config, lcs_concept_group_12_weak, lcs_concept_group_12_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_concept_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_lcs_concept_group_12_weak <- broom::tidy(lcs_concept_group_12_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="concept" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_concept_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_lcs_concept_group_12_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_concept_group_12_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="concept" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_concept_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
More positive change in self-concept clarity in the Group 1 compared to Group 2 but no substantial differences according to the LRTs. Slight caveat: weak measurement invariance could not be established as a first step at p < .05.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_concept_group_12_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

#### Latent change: differences in personality change

##### Run models 

Adapt latent change score model from above (but without any moderation) and add grouping factor in estimation (adding vectorized equality constraints to the model step by step):  

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# create templates:

# configural invariance
trait_template_main_config <- '
trait_t1 =~ 1*ind01_t1 +  c("lamb2a", "lamb2b")*ind02_t1 + c("lamb3a", "lamb3b")*ind03_t1 # This specifies the measurement model for trait_t1 
trait_t2 =~ 1*ind01_t2 +  c("lamb2a", "lamb2b")*ind02_t2 + c("lamb3a", "lamb3b")*ind03_t2 # This specifies the measurement model for trait_t2 with the equality constrained factor loadings

trait_t2 ~ 1*trait_t1     # This parameter regresses trait_t2 perfectly on trait_t1
d_trait_1 =~ 1*trait_t2   # This defines the latent change score factor as measured perfectly by scores on trait_t2
trait_t2 ~ 0*1            # This line constrains the intercept of trait_t2 to 0
trait_t2 ~~ 0*trait_t2    # This fixes the variance of trait_t2 to 0

d_trait_1 ~ c("d_int_a", "d_int_b")*1              # This estimates the intercept of the change score 
trait_t1 ~ c("b5_int_a", "b5_int_b")*1               # This estimates the intercept of trait_t1 
d_trait_1 ~~ c("d_var_a", "d_var_b")*d_trait_1     # This estimates the variance of the change scores 
trait_t1 ~~ c("b5_var_a", "b5_var_b")*trait_t1         # This estimates the variance of trait_t1 
d_trait_1 ~~ c("fb_a", "fb_b")* trait_t1   # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ind01_t1 ~~ c("cov1a", "cov1b")*ind01_t2   # This allows residual covariance on indicator X1 across T1 and T2
ind02_t1 ~~ c("cov2a", "cov2b")*ind02_t2   # This allows residual covariance on indicator X2 across T1 and T2
ind03_t1 ~~ c("cov3a", "cov3b")*ind03_t2   # This allows residual covariance on indicator X3 across T1 and T2

ind01_t1 ~~ c("res1a", "res1b")*ind01_t1   # This allows residual variance on indicator X1 at T1 
ind02_t1 ~~ c("res2a", "res2b")*ind02_t1   # This allows residual variance on indicator X2 at T1
ind03_t1 ~~ c("res3a", "res3b")*ind03_t1   # This allows residual variance on indicator X3 at T1

ind01_t2 ~~ c("res1a", "res1b")*ind01_t2  # This allows residual variance on indicator X1 at T2 
ind02_t2 ~~ c("res2a", "res2b")*ind02_t2  # This allows residual variance on indicator X2 at T2 
ind03_t2 ~~ c("res3a", "res3b")*ind03_t2  # This allows residual variance on indicator X3 at T2

ind01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ind02_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
ind03_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1

ind01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ind02_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
ind03_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
'

# weak invariance
trait_template_main_weak <- '
trait_t1 =~ 1*ind01_t1 +  c("lamb2", "lamb2")*ind02_t1 + c("lamb3", "lamb3")*ind03_t1 # This specifies the measurement model for trait_t1 
trait_t2 =~ 1*ind01_t2 +  c("lamb2", "lamb2")*ind02_t2 + c("lamb3", "lamb3")*ind03_t2 # This specifies the measurement model for trait_t2 with the equality constrained factor loadings

trait_t2 ~ 1*trait_t1     # This parameter regresses trait_t2 perfectly on trait_t1
d_trait_1 =~ 1*trait_t2   # This defines the latent change score factor as measured perfectly by scores on trait_t2
trait_t2 ~ 0*1            # This line constrains the intercept of trait_t2 to 0
trait_t2 ~~ 0*trait_t2    # This fixes the variance of trait_t2 to 0

d_trait_1 ~ c("d_int_a", "d_int_b")*1              # This estimates the intercept of the change score 
trait_t1 ~ c("b5_int_a", "b5_int_b")*1               # This estimates the intercept of trait_t1 
d_trait_1 ~~ c("d_var_a", "d_var_b")*d_trait_1     # This estimates the variance of the change scores 
trait_t1 ~~ c("b5_var_a", "b5_var_b")*trait_t1         # This estimates the variance of trait_t1 
d_trait_1 ~~ c("fb_a", "fb_b")* trait_t1   # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ind01_t1 ~~ c("cov1a", "cov1b")*ind01_t2   # This allows residual covariance on indicator X1 across T1 and T2
ind02_t1 ~~ c("cov2a", "cov2b")*ind02_t2   # This allows residual covariance on indicator X2 across T1 and T2
ind03_t1 ~~ c("cov3a", "cov3b")*ind03_t2   # This allows residual covariance on indicator X3 across T1 and T2

ind01_t1 ~~ c("res1a", "res1b")*ind01_t1   # This allows residual variance on indicator X1 at T1 
ind02_t1 ~~ c("res2a", "res2b")*ind02_t1   # This allows residual variance on indicator X2 at T1
ind03_t1 ~~ c("res3a", "res3b")*ind03_t1   # This allows residual variance on indicator X3 at T1

ind01_t2 ~~ c("res1a", "res1b")*ind01_t2  # This allows residual variance on indicator X1 at T2 
ind02_t2 ~~ c("res2a", "res2b")*ind02_t2  # This allows residual variance on indicator X2 at T2 
ind03_t2 ~~ c("res3a", "res3b")*ind03_t2  # This allows residual variance on indicator X3 at T2

ind01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ind02_t1 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T1
ind03_t1 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T1

ind01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ind02_t2 ~ c("m2a", "m2b")*1     # This estimates the intercept of X2 at T2
ind03_t2 ~ c("m3a", "m3b")*1     # This estimates the intercept of X3 at T2
'

# strong invariance
trait_template_main_strong <- '
trait_t1 =~ 1*ind01_t1 +  c("lamb2", "lamb2")*ind02_t1 + c("lamb3", "lamb3")*ind03_t1 # This specifies the measurement model for trait_t1 
trait_t2 =~ 1*ind01_t2 +  c("lamb2", "lamb2")*ind02_t2 + c("lamb3", "lamb3")*ind03_t2 # This specifies the measurement model for trait_t2 with the equality constrained factor loadings

trait_t2 ~ 1*trait_t1     # This parameter regresses trait_t2 perfectly on trait_t1
d_trait_1 =~ 1*trait_t2   # This defines the latent change score factor as measured perfectly by scores on trait_t2
trait_t2 ~ 0*1            # This line constrains the intercept of trait_t2 to 0
trait_t2 ~~ 0*trait_t2    # This fixes the variance of trait_t2 to 0

d_trait_1 ~ c("d_int", "d_int")*1              # This estimates the intercept of the change score 
trait_t1 ~ c("b5_int", "b5_int")*1               # This estimates the intercept of trait_t1 
d_trait_1 ~~ c("d_var_a", "d_var_b")*d_trait_1     # This estimates the variance of the change scores 
trait_t1 ~~ c("b5_var_a", "b5_var_b")*trait_t1         # This estimates the variance of trait_t1 
d_trait_1 ~~ c("fb_a", "fb_b")* trait_t1   # This estimates the self-feedback parameter, as a covariance! -> therefore, the interpretation of the change score

ind01_t1 ~~ c("cov1a", "cov1b")*ind01_t2   # This allows residual covariance on indicator X1 across T1 and T2
ind02_t1 ~~ c("cov2a", "cov2b")*ind02_t2   # This allows residual covariance on indicator X2 across T1 and T2
ind03_t1 ~~ c("cov3a", "cov3b")*ind03_t2   # This allows residual covariance on indicator X3 across T1 and T2

ind01_t1 ~~ c("res1a", "res1b")*ind01_t1   # This allows residual variance on indicator X1 at T1 
ind02_t1 ~~ c("res2a", "res2b")*ind02_t1   # This allows residual variance on indicator X2 at T1
ind03_t1 ~~ c("res3a", "res3b")*ind03_t1   # This allows residual variance on indicator X3 at T1

ind01_t2 ~~ c("res1a", "res1b")*ind01_t2  # This allows residual variance on indicator X1 at T2 
ind02_t2 ~~ c("res2a", "res2b")*ind02_t2  # This allows residual variance on indicator X2 at T2 
ind03_t2 ~~ c("res3a", "res3b")*ind03_t2  # This allows residual variance on indicator X3 at T2

ind01_t1 ~ 0*1      # This constrains the intercept of X1 to 0 at T1
ind02_t1 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T1
ind03_t1 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T1

ind01_t2 ~ 0*1      # This constrains the intercept of X1 to 0 at T2
ind02_t2 ~ c("m2", "m2")*1     # This estimates the intercept of X2 at T2
ind03_t2 ~ c("m3", "m3")*1     # This estimates the intercept of X3 at T2
'

# strict invariance -> not really needed for this analysis

# loop across 5 traits
for (i in 1:5) {
  item_nrs = b5_vars[[i]][[1]]
  short_name = str_trunc(names(b5_vars)[i], 5, ellipsis = "")
  # configural - current
  template_filled_config_current <- str_replace_all(trait_template_main_config, 
                                       c("trait" = short_name,
                                         "ind01" = paste0(short_name, "_curr_par1"), 
                                         "ind02" = paste0(short_name, "_curr_par2"), 
                                         "ind03" = paste0(short_name, "_curr_par3")))
  trait_main_fit_config_current <- lavaan(template_filled_config_current, 
                                          data = df_sbsa3_wide_pers %>% filter(group!="Group 3"), 
                                          estimator='mlr', fixed.x=FALSE, missing='fiml', group = "group")
  eval(call("<-", as.name(paste0("lcs_", short_name, "_main_config_group_12")), template_filled_config_current))
  eval(call("<-", as.name(paste0("fit_lcs_", short_name, "_main_config_group_12")), trait_main_fit_config_current))
  # weak - current
  template_filled_weak_current <- str_replace_all(trait_template_main_weak, 
                                       c("trait" = short_name,
                                         "ind01" = paste0(short_name, "_curr_par1"), 
                                         "ind02" = paste0(short_name, "_curr_par2"), 
                                         "ind03" = paste0(short_name, "_curr_par3")))
  trait_main_fit_weak_current <- lavaan(template_filled_weak_current, 
                                          data = df_sbsa3_wide_pers %>% filter(group!="Group 3"), 
                                          estimator='mlr', fixed.x=FALSE, missing='fiml', group = "group", group.equal = "loadings")
  eval(call("<-", as.name(paste0("lcs_", short_name, "_main_weak_group_12")), template_filled_weak_current))
  eval(call("<-", as.name(paste0("fit_lcs_", short_name, "_main_weak_group_12")), trait_main_fit_weak_current))
  # strong - current
  template_filled_strong_current <- str_replace_all(trait_template_main_strong, 
                                       c("trait" = short_name,
                                         "ind01" = paste0(short_name, "_curr_par1"), 
                                         "ind02" = paste0(short_name, "_curr_par2"), 
                                         "ind03" = paste0(short_name, "_curr_par3")))
  trait_main_fit_strong_current <- lavaan(template_filled_strong_current, 
                                          data = df_sbsa3_wide_pers %>% filter(group!="Group 3"), 
                                          estimator='mlr', fixed.x=FALSE, missing='fiml', group = "group", group.equal = c("intercepts", "loadings"))
  eval(call("<-", as.name(paste0("lcs_", short_name, "_main_strong_group_12")), template_filled_strong_current))
  eval(call("<-", as.name(paste0("fit_lcs_", short_name, "_main_strong_group_12")), trait_main_fit_strong_current))
}
```

##### Current personality personality traits

Extraversion (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_extra_main_config_group_12, fit_lcs_extra_main_weak_group_12, fit_lcs_extra_main_strong_group_12)

# show model with varying latent change parameters 
# -> key parameter is "d_extra_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_main_lcs_extra_group_12 <- broom::tidy(fit_lcs_extra_main_weak_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="extra" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_extra_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_main_lcs_extra_group_12, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_extra_main_strong_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="extra" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_extra_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_extra_main_weak_group_12) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Very similar change in extraversion in both groups. No significant differences according to the LRTs.
:::

Agreeableness (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_agree_main_config_group_12, fit_lcs_agree_main_weak_group_12, fit_lcs_agree_main_strong_group_12)

# show model with varying latent change parameters 
# -> key parameter is "d_agree_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_main_lcs_agree_group_12 <- broom::tidy(fit_lcs_agree_main_weak_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="agree" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_agree_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_main_lcs_agree_group_12, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_agree_main_strong_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="agree" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_agree_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_agree_main_weak_group_12) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Similar change in agreeableness in both groups. No significant differences according to the LRTs.
:::

Conscientiousness (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_consc_main_config_group_12, fit_lcs_consc_main_weak_group_12, fit_lcs_consc_main_strong_group_12)

# show model with varying latent change parameters 
# -> key parameter is "d_consc_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_main_lcs_consc_group_12 <- broom::tidy(fit_lcs_consc_main_weak_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="consc" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_consc_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_main_lcs_consc_group_12, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_consc_main_strong_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="consc" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_consc_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_consc_main_weak_group_12) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Similar change in conscientiousness in both groups (increase is slightly larger in Group 1 compared to Group 2). No significant differences according to the LRTs.
:::

Neuroticism (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_neuro_main_config_group_12, fit_lcs_neuro_main_weak_group_12, fit_lcs_neuro_main_strong_group_12)

# show model with varying latent change parameters 
# -> key parameter is "d_neuro_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_main_lcs_neuro_group_12 <- broom::tidy(fit_lcs_neuro_main_weak_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="neuro" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_neuro_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_main_lcs_neuro_group_12, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_neuro_main_strong_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="neuro" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_neuro_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_neuro_main_weak_group_12) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Small decreases in neuroticism in both groups. Decrease is larger in Group 2 compared to Group 1. No significant differences according to the LRTs.
:::

Openness (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_openn_main_config_group_12, fit_lcs_openn_main_weak_group_12, fit_lcs_openn_main_strong_group_12)

# show model with varying latent change parameters 
# -> key parameter is "d_openn_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 1, b = Group 2)
params_main_lcs_openn_group_12 <- broom::tidy(fit_lcs_openn_main_weak_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="openn" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_openn_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_main_lcs_openn_group_12, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_openn_main_strong_group_12, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="openn" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_openn_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_openn_main_weak_group_12) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Almost no change in current personality openness in both groups. No significant differences according to the LRTs.
:::

##### Ideal personality traits

In Study 3, we can only examine this in Group 1, so no multi-group comparison of ideal personality possible. 

### Group 2 vs. Group 3: Effect of demand characteristics

#### Well-being change: differences across groups

##### Life satisfaction 

Life satisfaction: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance -> model template created above
lcs_swls_group_23_config <- sem(mi_lcs_swls_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 1"), estimator='mlr', 
                             fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance -> model template created above
lcs_swls_group_23_weak <- sem(mi_lcs_swls_group_weak, data=df_sbsa3_wide_wb %>% 
                                filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                              group = "group", group.equal = "loadings")

# strong invariance -> model template created above
lcs_swls_group_23_strong <- sem(mi_lcs_swls_group_strong, data=df_sbsa3_wide_wb %>% 
                                  filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                group = "group", group.equal = c("intercepts", "loadings"))
```

Life satisfaction: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_swls_group_23_config, lcs_swls_group_23_weak, lcs_swls_group_23_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_swls_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_lcs_swls_group_23_weak <- broom::tidy(lcs_swls_group_23_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="swls" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_swls_1 ~1 ")) %>% mutate(sig_diff = "**")
kable(params_lcs_swls_group_23_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_swls_group_23_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="swls" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_swls_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Significantly more positive change in life satisfaction in the Group 2 compared to Group 3 (difference significant according to the LRT). Change almost zero in Group 3.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_swls_group_23_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

##### Meaning in life

Meaning in life: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance -> model template created above
lcs_meaning_group_23_config <- sem(mi_lcs_meaning_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 1"), estimator='mlr', 
                                fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance -> model template created above
lcs_meaning_group_23_weak <- sem(mi_lcs_meaning_group_weak, data=df_sbsa3_wide_wb %>% 
                                   filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                 group = "group", group.equal = "loadings")

# strong invariance -> model template created above
lcs_meaning_group_23_strong <- sem(mi_lcs_meaning_group_strong, data=df_sbsa3_wide_wb %>% 
                                     filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                   group = "group", group.equal = c("intercepts", "loadings"))
```

Meaning in life: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_meaning_group_23_config, lcs_meaning_group_23_weak, lcs_meaning_group_23_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_meaning_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_lcs_meaning_group_23_weak <- broom::tidy(lcs_meaning_group_23_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="meaning" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_meaning_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_lcs_meaning_group_23_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_meaning_group_23_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="meaning" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_meaning_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Slightly more positive change in meaning in life in the Group 2 compared to Group 3 but no substantial differences according to the LRTs and not significantly different from zero in all models at *p* < .01.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_meaning_group_23_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

###### Search for Meaning

Search for Meaning in life (see preregistration deviations): fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance -> model template created above
lcs_search_group_23_config <- sem(mi_lcs_search_group_config, data=df_sbsa3_wide_wb %>% filter(group!="Group 1"), estimator='mlr', 
                                fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance -> model template created above
lcs_search_group_23_weak <- sem(mi_lcs_search_group_weak, data=df_sbsa3_wide_wb %>% 
                                   filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                 group = "group", group.equal = "loadings")

# strong invariance -> model template created above
lcs_search_group_23_strong <- sem(mi_lcs_search_group_strong, data=df_sbsa3_wide_wb %>% 
                                     filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                   group = "group", group.equal = c("intercepts", "loadings"))
```

Meaning in life: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_search_group_23_config, lcs_search_group_23_weak, lcs_search_group_23_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_search_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_lcs_search_group_23_weak <- broom::tidy(lcs_search_group_23_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="search" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_search_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_lcs_search_group_23_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_search_group_23_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="search" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_search_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Similar decreases in search for meaning in life in Group 2 compared to Group 3 but no substantial differences according to the LRTs and not significantly different from zero in all models at *p* < .01.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_meaning_group_23_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

##### Self-esteem 

Self-esteem: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance -> model template created above
lcs_selfes_group_23_config <- sem(mi_lcs_selfes_group_config, data=df_sbsa3_wide_wb %>% 
                                    filter(group!="Group 1"), estimator='mlr', 
                                fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance -> model template created above
lcs_selfes_group_23_weak <- sem(mi_lcs_selfes_group_weak, data=df_sbsa3_wide_wb %>% 
                                  filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                group = "group", group.equal = "loadings")

# strong invariance -> model template created above
lcs_selfes_group_23_strong <- sem(mi_lcs_selfes_group_strong, data=df_sbsa3_wide_wb %>% 
                                    filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                  group = "group", group.equal = c("intercepts", "loadings"))
```

Self-esteem: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_selfes_group_23_config, lcs_selfes_group_23_weak, lcs_selfes_group_23_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_selfes_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_lcs_selfes_group_23_weak <- broom::tidy(lcs_selfes_group_23_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="selfes" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_selfes_1 ~1 ")) %>% mutate(sig_diff = "**")
kable(params_lcs_selfes_group_23_weak, digits = 3)

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_selfes_group_23_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="selfes" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_selfes_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Significant positive change in self-esteem in the Group 2 but no change in Grouo 3. Significant difference according to the LRT.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_selfes_group_23_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

##### Self-concept clarity 

Self-concept clarity: fitting multi-group models
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# adapt latent change score model from above and add grouping factor in estimation (also add vectorized equality constraints to the model)

# configural invariance -> model template created above
lcs_concept_group_23_config <- sem(mi_lcs_concept_group_config, data=df_sbsa3_wide_wb %>% 
                                     filter(group!="Group 1"), estimator='mlr', 
                                   fixed.x=FALSE, missing='fiml', group = "group")

# weak invariance -> model template created above
lcs_concept_group_23_weak <- sem(mi_lcs_concept_group_weak, data=df_sbsa3_wide_wb %>% 
                                   filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                 group = "group", group.equal = "loadings")

# strong invariance -> model template created above
lcs_concept_group_23_strong <- sem(mi_lcs_concept_group_strong, data=df_sbsa3_wide_wb %>% 
                                     filter(group!="Group 1"), estimator='mlr', fixed.x=FALSE, missing='fiml',
                                   group = "group", group.equal = c("intercepts", "loadings"))
```

Self-concept clarity: results
```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5

# model comparison tests for measurement invariance
lavTestLRT(lcs_concept_group_23_config, lcs_concept_group_23_weak, lcs_concept_group_23_strong)

# show model with varying latent change parameters 
# -> key parameter is "d_concept_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_lcs_concept_group_23_weak <- broom::tidy(lcs_concept_group_23_weak, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="concept" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_concept_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_lcs_concept_group_23_weak, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(lcs_concept_group_23_strong, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_wb_st3 %>% filter(trait=="concept" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_concept_1 ~1 ")), digits = 3) 
```

::: {.callout-note appearance="minimal"}
Only very small positive change in self-concept clarity both groups (very similar in the two groups), that is n.s. in the weak invariance model but significant in the strong invariance model. No substantial differences according to the LRTs.
:::

```{r}
#| echo: true
#| fig-width: 9.5
#| fig-height: 6.5
# whole model (weak invariance)
summary(lcs_concept_group_23_weak, fit.measures=TRUE, standardized=TRUE, rsquare=F)
```

#### Latent change: differences in personality change

##### Run models 

Adapt latent change score model from above (but without any moderation) and add grouping factor in estimation (adding vectorized equality constraints to the model step by step):  

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

# create templates: (same as those already created above)

# loop across 5 traits
for (i in 1:5) {
  item_nrs = b5_vars[[i]][[1]]
  short_name = str_trunc(names(b5_vars)[i], 5, ellipsis = "")
  # configural - current
  template_filled_config_current <- str_replace_all(trait_template_main_config, 
                                       c("trait" = short_name,
                                         "ind01" = paste0(short_name, "_curr_par1"), 
                                         "ind02" = paste0(short_name, "_curr_par2"), 
                                         "ind03" = paste0(short_name, "_curr_par3")))
  trait_main_fit_config_current <- lavaan(template_filled_config_current, 
                                          data = df_sbsa3_wide_pers %>% 
                                            filter(group!="Group 1"), 
                                          estimator='mlr', fixed.x=FALSE, missing='fiml', group = "group")
  eval(call("<-", as.name(paste0("lcs_", short_name, "_main_config_group_23")), template_filled_config_current))
  eval(call("<-", as.name(paste0("fit_lcs_", short_name, "_main_config_group_23")), trait_main_fit_config_current))
  # weak - current
  template_filled_weak_current <- str_replace_all(trait_template_main_weak, 
                                       c("trait" = short_name,
                                         "ind01" = paste0(short_name, "_curr_par1"), 
                                         "ind02" = paste0(short_name, "_curr_par2"), 
                                         "ind03" = paste0(short_name, "_curr_par3")))
  trait_main_fit_weak_current <- lavaan(template_filled_weak_current, 
                                          data = df_sbsa3_wide_pers %>% 
                                          filter(group!="Group 1"), 
                                          estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                        group = "group", group.equal = "loadings")
  eval(call("<-", as.name(paste0("lcs_", short_name, "_main_weak_group_23")), template_filled_weak_current))
  eval(call("<-", as.name(paste0("fit_lcs_", short_name, "_main_weak_group_23")), trait_main_fit_weak_current))
  # strong - current
  template_filled_strong_current <- str_replace_all(trait_template_main_strong, 
                                       c("trait" = short_name,
                                         "ind01" = paste0(short_name, "_curr_par1"), 
                                         "ind02" = paste0(short_name, "_curr_par2"), 
                                         "ind03" = paste0(short_name, "_curr_par3")))
  trait_main_fit_strong_current <- lavaan(template_filled_strong_current, 
                                          data = df_sbsa3_wide_pers %>% 
                                            filter(group!="Group 1"), 
                                          estimator='mlr', fixed.x=FALSE, missing='fiml', 
                                          group = "group", group.equal = c("intercepts", "loadings"))
  eval(call("<-", as.name(paste0("lcs_", short_name, "_main_strong_group_23")), template_filled_strong_current))
  eval(call("<-", as.name(paste0("fit_lcs_", short_name, "_main_strong_group_23")), trait_main_fit_strong_current))
}
```

##### Current personality personality traits

Extraversion (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_extra_main_config_group_23, fit_lcs_extra_main_weak_group_23, fit_lcs_extra_main_strong_group_23)

# show model with varying latent change parameters 
# -> key parameter is "d_extra_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_main_lcs_extra_group_23 <- broom::tidy(fit_lcs_extra_main_weak_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="extra" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_extra_1 ~1 ")) %>% mutate(sig_diff = "*")
kable(params_main_lcs_extra_group_23, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_extra_main_strong_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="extra" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_extra_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_extra_main_weak_group_23) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Small but significant change in extraversion in Group 2 but no significant change in Group 3 (in weak invariance model). No change in strong invariance model. According to the LRT, only weak invariance is given (at *p* < .05; strong at *p* < .01).
:::

Agreeableness (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_agree_main_config_group_23, fit_lcs_agree_main_weak_group_23, fit_lcs_agree_main_strong_group_23)

# show model with varying latent change parameters 
# -> key parameter is "d_agree_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_main_lcs_agree_group_23 <- broom::tidy(fit_lcs_agree_main_weak_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="agree" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_agree_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_main_lcs_agree_group_23, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_agree_main_strong_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="agree" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_agree_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_agree_main_weak_group_23) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
No change in agreeableness in both groups (increase is a tiny bit larger in Group 2 compared to Group 3). No significant differences according to the LRTs.
:::

Conscientiousness (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_consc_main_config_group_23, fit_lcs_consc_main_weak_group_23, fit_lcs_consc_main_strong_group_23)

# show model with varying latent change parameters 
# -> key parameter is "d_consc_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_main_lcs_consc_group_23 <- broom::tidy(fit_lcs_consc_main_weak_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="consc" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_consc_1 ~1 ")) %>% mutate(sig_diff = "*")
kable(params_main_lcs_consc_group_23, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_consc_main_strong_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="consc" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_consc_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_consc_main_weak_group_23) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Small positive change in conscientiousness in both groups. This increase is slightly larger in Group 2 compared to Group 3. No significant differences according to the LRTs (at *p* < .01, but strong invariance not given at *p* < .05).
:::

Neuroticism (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_neuro_main_config_group_23, fit_lcs_neuro_main_weak_group_23, fit_lcs_neuro_main_strong_group_23)

# show model with varying latent change parameters 
# -> key parameter is "d_neuro_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_main_lcs_neuro_group_23 <- broom::tidy(fit_lcs_neuro_main_weak_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="neuro" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_neuro_1 ~1 ")) %>% mutate(sig_diff = "**")
kable(params_main_lcs_neuro_group_23, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_neuro_main_strong_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="neuro" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_neuro_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_neuro_main_weak_group_23) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Significant decrease in neuroticism only in Group 2, no change in Group 3. Significant difference according to the LRT (strong invariance not given!).
:::

Openness (current personality): results  
```{r}
#| echo: true
#| warning: false

# model comparison tests for measurement invariance
lavTestLRT(fit_lcs_openn_main_config_group_23, fit_lcs_openn_main_weak_group_23, fit_lcs_openn_main_strong_group_23)

# show model with varying latent change parameters 
# -> key parameter is "d_openn_1 ~1"
# labelled parameter as "d_int_a" & "d_int_b" (a = Group 2, b = Group 3)
params_main_lcs_openn_group_23 <- broom::tidy(fit_lcs_openn_main_weak_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="openn" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_openn_1 ~1 ")) %>% mutate(sig_diff = " ")
kable(params_main_lcs_openn_group_23, digits = 3) 

# constrained to be equal in the strong measurement invariance model:
kable(broom::tidy(fit_lcs_openn_main_strong_group_23, conf.int = TRUE, conf.level = 0.99) %>% 
        mutate(beta = estimate / 
           (sd_pers_st3 %>% filter(trait=="openn" & reference=="current" & time==1) %>% pull(sd_trait))) %>% 
        select(term, label, estimate, beta, std.all, statistic, p.value) %>% 
        filter(term %in% c("d_openn_1 ~1 ")), digits = 3) 

# model fit
kable(broom::glance(fit_lcs_openn_main_weak_group_23) %>% 
        select(nobs, npar, AIC, BIC, cfi, rmsea, srmr), digits = 3)
```

::: {.callout-note appearance="minimal"}
Almost no change in current personality openness in both groups but slightly stronger increase in Group 2 compared to Group 3. No significant differences according to the LRTs, though.
:::

### Summary of latent main effects

#### Big Five

##### Group 1 vs. 2
```{r}
#| echo: true
#| warning: false

params_main_summary_12 <- bind_rows(
  params_main_lcs_extra_group_12 %>% mutate(trait = names(b5_vars)[1], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_agree_group_12 %>% mutate(trait = names(b5_vars)[2], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_consc_group_12 %>% mutate(trait = names(b5_vars)[3], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_neuro_group_12 %>% mutate(trait = names(b5_vars)[4], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_openn_group_12 %>% mutate(trait = names(b5_vars)[5], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff)) %>% mutate(group = ifelse(group=="d_int_a", "Group 1", "Group 2"))

kable(params_main_summary_12, digits = 3)
```

##### Group 2 vs. 3
```{r}
#| echo: true
#| warning: false

params_main_summary_23 <- bind_rows(
  params_main_lcs_extra_group_23 %>% mutate(trait = names(b5_vars)[1], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_agree_group_23 %>% mutate(trait = names(b5_vars)[2], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_consc_group_23 %>% mutate(trait = names(b5_vars)[3], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_neuro_group_23 %>% mutate(trait = names(b5_vars)[4], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff),
  params_main_lcs_openn_group_23 %>% mutate(trait = names(b5_vars)[5], self = "current") %>% select(trait, self, group = label, estimate, beta, p.value, sig_diff)) %>% mutate(group = ifelse(group=="d_int_a", "Group 2", "Group 3"))

kable(params_main_summary_23, digits = 3)
```

::: {.callout-note appearance="minimal"}
Group 2 estimates very similar across model comparisons!
:::

#### Well-being

##### Group 1 vs. 2
```{r}
#| echo: true
#| warning: false

params_main_summary_wb_12 <- bind_rows(
  params_lcs_swls_group_12_weak %>% mutate(trait = "Life Satisfaction") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),
  params_lcs_meaning_group_12_weak %>% mutate(trait = "Meaning in Life") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),
    params_lcs_search_group_12_weak %>% mutate(trait = "Search for Meaning") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),
  params_lcs_selfes_group_12_weak %>% mutate(trait = "Self-Esteem") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),
  params_lcs_concept_group_12_weak %>% mutate(trait = "Self-Concept Clarity") %>% select(trait, group = label, estimate, beta, p.value, sig_diff)) %>% mutate(group = ifelse(group=="d_int_a", "Group 1", "Group 2"))

kable(params_main_summary_wb_12, digits = 3)
```

##### Group 2 vs. 3

```{r}
#| echo: true
#| warning: false

params_main_summary_wb_23 <- bind_rows(
  params_lcs_swls_group_23_weak %>% mutate(trait = "Life Satisfaction") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),
  params_lcs_meaning_group_23_weak %>% mutate(trait = "Meaning in Life") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),  
  params_lcs_search_group_23_weak %>% mutate(trait = "Search for Meaning") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),
  params_lcs_selfes_group_23_weak %>% mutate(trait = "Self-Esteem") %>% select(trait, group = label, estimate, beta, p.value, sig_diff),
  params_lcs_concept_group_23_weak %>% mutate(trait = "Self-Concept Clarity") %>% select(trait, group = label, estimate, beta, p.value, sig_diff)) %>% mutate(group = ifelse(group=="d_int_a", "Group 2", "Group 3"))

kable(params_main_summary_wb_23, digits = 3)
```

::: {.callout-note appearance="minimal"}
Group 2 estimates very similar across model comparisons!
:::

### Plot Changes (Latent Scores)

#### Personality 

Gather all latent intercepts at T1 and latent change scores: 

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

b5_latent_df_plot <- bind_rows(
  broom::tidy(fit_lcs_extra_main_weak_group_12, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("extra_t1 ~1 ", "d_extra_1 ~1 ")) %>% 
    mutate(Trait = "Extraversion", Group = ifelse(label %in% c("d_int_a", "b5_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(fit_lcs_extra_main_weak_group_23, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("extra_t1 ~1 ", "d_extra_1 ~1 ") & label %in% c("d_int_b", "b5_int_b")) %>% 
    mutate(Trait = "Extraversion", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(fit_lcs_agree_main_weak_group_12, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("agree_t1 ~1 ", "d_agree_1 ~1 ")) %>% 
    mutate(Trait = "Agreeableness", Group = ifelse(label %in% c("d_int_a", "b5_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(fit_lcs_agree_main_weak_group_23, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("agree_t1 ~1 ", "d_agree_1 ~1 ") & label %in% c("d_int_b", "b5_int_b")) %>% 
    mutate(Trait = "Agreeableness", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(fit_lcs_consc_main_weak_group_12, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("consc_t1 ~1 ", "d_consc_1 ~1 ")) %>% 
    mutate(Trait = "Conscientiousness", Group = ifelse(label %in% c("d_int_a", "b5_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(fit_lcs_consc_main_weak_group_23, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("consc_t1 ~1 ", "d_consc_1 ~1 ") & label %in% c("d_int_b", "b5_int_b")) %>% 
    mutate(Trait = "Conscientiousness", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(fit_lcs_neuro_main_weak_group_12, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("neuro_t1 ~1 ", "d_neuro_1 ~1 ")) %>% 
    mutate(Trait = "Neuroticism", Group = ifelse(label %in% c("d_int_a", "b5_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(fit_lcs_neuro_main_weak_group_23, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("neuro_t1 ~1 ", "d_neuro_1 ~1 ") & label %in% c("d_int_b", "b5_int_b")) %>% 
    mutate(Trait = "Neuroticism", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(fit_lcs_openn_main_weak_group_12, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("openn_t1 ~1 ", "d_openn_1 ~1 ")) %>% 
    mutate(Trait = "Openness", Group = ifelse(label %in% c("d_int_a", "b5_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(fit_lcs_openn_main_weak_group_23, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("openn_t1 ~1 ", "d_openn_1 ~1 ") & label %in% c("d_int_b", "b5_int_b")) %>% 
    mutate(Trait = "Openness", Group = "Group 3:\nDevelopmental trends\n"))

# select and mutate relevant vars
b5_latent_df_plot <- b5_latent_df_plot %>% 
  mutate(param = ifelse(label %in% c("d_int_a", "d_int_b"), "slope", "intercept")) %>% 
  select(Trait, Group, estimate, std.error, param, conf.low, conf.high) %>% 
  pivot_wider(names_from = param,
              names_sep = "_",
              values_from = -c(Trait, Group, param)) %>% 
  mutate(T2_estimate = estimate_intercept + estimate_slope, T1_estimate = estimate_intercept,
         T2_cilow = T2_estimate - qnorm(0.995)*(sqrt(std.error_intercept^2 + std.error_slope^2)), 
         T2_cihi  = T2_estimate + qnorm(0.995)*(sqrt(std.error_intercept^2 + std.error_slope^2))) %>% 
  rename(T1_cilow = conf.low_intercept, T1_cihi = conf.high_intercept) %>% 
  select(-c(estimate_slope, estimate_intercept, conf.low_slope, conf.high_slope, std.error_slope, std.error_intercept))

# reshape
b5_latent_df_plot <- b5_latent_df_plot %>% 
  pivot_longer(-c(Trait, Group),
               names_to = c("Time", ".value"),
               names_pattern = "T(\\d)_(.*)") %>% 
  mutate(Time = factor(str_c("T", Time), levels = c("T1", "T2"), labels = c("T1", "T2"), ordered = T))
```

Plot changes (unstandardized effect size metric): all together 

```{r}
#| echo: true
#| fig-width: 10
#| fig-height: 6
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(b5_latent_df_plot, 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(2.5, 4.5) + 
  facet_wrap( ~ Trait, ncol = 3) +
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Extraversion
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(b5_latent_df_plot %>% filter(Trait=="Extraversion"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(2.5, 3.5) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Agreeableness
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(b5_latent_df_plot %>% filter(Trait=="Agreeableness"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(3.5, 4.5) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Conscientiousness
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(b5_latent_df_plot %>% filter(Trait=="Conscientiousness"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(2.75, 3.75) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Neuroticism
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(b5_latent_df_plot %>% filter(Trait=="Neuroticism"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(2.5, 3.5) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Openness
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(b5_latent_df_plot %>% filter(Trait=="Openness"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(3, 4) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

#### Well-being 

Gather all latent intercepts at T1 and latent change scores: 

```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

wb_latent_df_plot <- bind_rows(
  broom::tidy(lcs_swls_group_12_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("swls_t1 ~1 ", "d_swls_1 ~1 ")) %>% 
    mutate(Trait = "Life Satisfaction", Group = ifelse(label %in% c("d_int_a", "wb_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(lcs_swls_group_23_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("swls_t1 ~1 ", "d_swls_1 ~1 ") & label %in% c("d_int_b", "wb_int_b")) %>% 
    mutate(Trait = "Life Satisfaction", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(lcs_meaning_group_12_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("meaning_t1 ~1 ", "d_meaning_1 ~1 ")) %>% 
    mutate(Trait = "Meaning in Life", Group = ifelse(label %in% c("d_int_a", "wb_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(lcs_meaning_group_23_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("meaning_t1 ~1 ", "d_meaning_1 ~1 ") & label %in% c("d_int_b", "wb_int_b")) %>% 
    mutate(Trait = "Meaning in Life", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(lcs_search_group_12_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("search_t1 ~1 ", "d_search_1 ~1 ")) %>% 
    mutate(Trait = "Search for Meaning", Group = ifelse(label %in% c("d_int_a", "wb_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(lcs_search_group_23_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("search_t1 ~1 ", "d_search_1 ~1 ") & label %in% c("d_int_b", "wb_int_b")) %>% 
    mutate(Trait = "Search for Meaning", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(lcs_selfes_group_12_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("selfes_t1 ~1 ", "d_selfes_1 ~1 ")) %>% 
    mutate(Trait = "Self-Esteem", Group = ifelse(label %in% c("d_int_a", "wb_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(lcs_selfes_group_23_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("selfes_t1 ~1 ", "d_selfes_1 ~1 ") & label %in% c("d_int_b", "wb_int_b")) %>% 
    mutate(Trait = "Self-Esteem", Group = "Group 3:\nDevelopmental trends\n"),
  broom::tidy(lcs_concept_group_12_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("concept_t1 ~1 ", "d_concept_1 ~1 ")) %>% 
    mutate(Trait = "Self-Concept Clarity", Group = ifelse(label %in% c("d_int_a", "wb_int_a"), "Group 1:\nDiscrepancy awareness\n", "Group 2:\nDemand effects\n")),
  broom::tidy(lcs_concept_group_23_weak, conf.int = T, conf.level = .99) %>% select(term, label, estimate, std.error, conf.low, conf.high) %>% 
    filter(term %in% c("concept_t1 ~1 ", "d_concept_1 ~1 ") & label %in% c("d_int_b", "wb_int_b")) %>% 
    mutate(Trait = "Self-Concept Clarity", Group = "Group 3:\nDevelopmental trends\n"))

# select and mutate relevant vars
wb_latent_df_plot <- wb_latent_df_plot %>% 
  mutate(param = ifelse(label %in% c("d_int_a", "d_int_b"), "slope", "intercept")) %>% 
  select(Trait, Group, estimate, std.error, param, conf.low, conf.high) %>% 
  pivot_wider(names_from = param,
              names_sep = "_",
              values_from = -c(Trait, Group, param)) %>% 
  mutate(T2_estimate = estimate_intercept + estimate_slope, T1_estimate = estimate_intercept,
         T2_cilow = T2_estimate - qnorm(0.995)*(sqrt(std.error_intercept^2 + std.error_slope^2)), 
         T2_cihi  = T2_estimate + qnorm(0.995)*(sqrt(std.error_intercept^2 + std.error_slope^2))) %>% 
  rename(T1_cilow = conf.low_intercept, T1_cihi = conf.high_intercept) %>% 
  select(-c(estimate_slope, estimate_intercept, conf.low_slope, conf.high_slope, std.error_slope, std.error_intercept))

# reshape
wb_latent_df_plot <- wb_latent_df_plot %>% 
  pivot_longer(-c(Trait, Group),
               names_to = c("Time", ".value"),
               names_pattern = "T(\\d)_(.*)") %>% 
  mutate(Time = factor(str_c("T", Time), levels = c("T1", "T2"), labels = c("T1", "T2"), ordered = T))
```

Plot changes (unstandardized effect size metric): all together 

```{r}
#| echo: true
#| fig-width: 8
#| fig-height: 6
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(wb_latent_df_plot %>% filter(Trait!="Search for Meaning"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  facet_wrap( ~ Trait, ncol = 2) +
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Life Satisfaction
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(wb_latent_df_plot %>% filter(Trait=="Life Satisfaction"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(2, 3.5) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Meaning in Life
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(wb_latent_df_plot %>% filter(Trait=="Meaning in Life"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(3.5, 5) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Search for Meaning
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(wb_latent_df_plot %>% filter(Trait=="Search for Meaning"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(4, 6) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Self-Esteem
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(wb_latent_df_plot %>% filter(Trait=="Self-Esteem"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(2.5, 4) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

Plotting model based mean-level changes: Self-Concept Clarity
```{r}
#| echo: true
#| fig-width: 6
#| fig-height: 3.5
#| cache: false
#| code-fold: true
#| code-summary: "Show the code"

ggplot(wb_latent_df_plot %>% filter(Trait=="Self-Concept Clarity"), 
       aes(y = estimate, x = Time)) + 
  geom_point(aes(shape = Group, group = Group, color = Group), position = position_dodge(0.3)) +
  geom_line(aes(group = Group, color = Group, linetype = Group), position = position_dodge(0.3)) +
  scale_shape_manual(values=c(17, 19, 15)) + 
  geom_errorbar(aes(group = Group, color = Group, ymin = cilow, ymax = cihi), width=.3, position=position_dodge(0.3)) + 
  ylab("Mean Trait Level\n(Model-Based, 99% CI)") + 
  ylim(2.5, 4) + 
  theme_bw() +
  theme(panel.grid.minor = element_blank(),
        strip.background=element_rect(fill="grey93"))
```

## Robustness check (MLMs)

Do changes in current personality trait change depend on the study group? Using multilevel change models instead of SEM latent change score models.

### Group 1 vs. Group 2: Effect of discrepancy awareness

Changes in current personality traits over time:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

df_manip_check_curr_12 <- df_sbsa3 %>% 
  filter(group!="Group 3") %>% 
  mutate(time_d = time - 1) %>% 
  select(pid, time_d, group, 
         paste0(str_trunc(names(b5_vars), 5, ellipsis = ""), "_comb_curr")) %>% 
  pivot_longer(ends_with("_comb_curr"), 
               names_to = "test", names_prefix = "facet", values_to = "score", values_drop_na = TRUE) %>% 
  mutate(group_1 = ifelse(group=="Group 1", 1, 0)) %>% 
  group_nest(test) %>% 
  mutate(lmer_mods = map(data, ~lmerTest::lmer(score ~ time_d * group_1 + (1 | pid), data = .x))) %>% 
  pull(lmer_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_manip_check_curr_unlist_12 <- as.data.frame(summary(df_manip_check_curr_12[[1]])$coefficients) %>% as_tibble()
for (i in 2:length(df_manip_check_curr_12)) {
  df_manip_check_curr_unlist_12 <- bind_rows(df_manip_check_curr_unlist_12, 
                                          as.data.frame(summary(df_manip_check_curr_12[[i]])$coefficients) %>% as_tibble())
}
```

```{r}
#| echo: true
#| warning: false

kable(df_manip_check_curr_unlist_12 %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=4), 
               term = c(rep(c("Intercept", "time", "group_1", "time*group_1"), 20))) %>% 
        rename(p = `Pr(>|t|)`, str_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, str_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars)))), # order by BFI traits, 
      digits = 3)
```

::: {.callout-note appearance="minimal"}
No significant *group_1* effects (higher trait level in Group 1 at baseline) and also no significant differences in the changes over time in current personality trait levels (*timeXgroup*) at *p* < .01 (only for depression at *p* < .05). Significant changes over time in current personality trait levels (*time*) for extraversion (also sociability) and neuroticism (also depression.
:::

Plot of main effects: extraversion and neuroticism
```{r}
#| echo: true
#| warning: false
#| fig-width: 7
#| fig-height: 5
#| code-fold: true
#| code-summary: "Show the code"

ggeffects::ggpredict(df_manip_check_curr_12$extraversion, 
                     terms = c("time_d[0,1]", "group_1[0,1]")) |> plot() +
  aes(linetype=group, color=group, shape=group) + geom_point() +
  theme_light() +
  scale_x_continuous(breaks = c(0,1), labels = c("T1", "T2")) +
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "Extraversion", x = "Time", y = "Predicted values of\nextraversion",
       linetype="Group\n(0 = Group 2,\n1 = Group 1)", color="Group\n(0 = Group 2,\n1 = Group 1)", 
       shape="Group\n(0 = Group 2,\n1 = Group 1)")
``` 

```{r}
#| echo: true
#| warning: false
#| fig-width: 7
#| fig-height: 5
#| code-fold: true
#| code-summary: "Show the code"

ggeffects::ggpredict(df_manip_check_curr_12$neuroticism, 
                     terms = c("time_d[0,1]", "group_1[0,1]")) |> plot() +
  aes(linetype=group, color=group, shape=group) + geom_point() +
  theme_light() +
  scale_x_continuous(breaks = c(0,1), labels = c("T1", "T2")) +
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "Neuroticism", x = "Time", y = "Predicted values of\nneuroticism",
       linetype="Group\n(0 = Group 2,\n1 = Group 1)", color="Group\n(0 = Group 2,\n1 = Group 1)", 
       shape="Group\n(0 = Group 2,\n1 = Group 1)")
``` 

Group interaction effect: Depression (but only at *p* < .05)

```{r}
#| echo: true
#| warning: false
#| fig-width: 7
#| fig-height: 5
#| code-fold: true
#| code-summary: "Show the code"

ggeffects::ggpredict(df_manip_check_curr_12$depression, 
                     terms = c("time_d[0,1]", "group_1[0,1]")) |> plot() +
  aes(linetype=group, color=group, shape=group) + geom_point() +
  theme_light() +
  scale_x_continuous(breaks = c(0,1), labels = c("T1", "T2")) +
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "Depression", x = "Time", y = "Predicted values of\ndepression",
       linetype="Group\n(0 = Group 2,\n1 = Group 1)", color="Group\n(0 = Group 2,\n1 = Group 1)", 
       shape="Group\n(0 = Group 2,\n1 = Group 1)")
``` 

Changes in ideal personality traits over time:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

df_manip_check_ideal <- df_sbsa3 %>% 
  filter(group=="Group 1") %>% 
  mutate(time_d = time - 1) %>% 
  select(pid, time_d, 
         paste0(str_trunc(names(b5_vars), 5, ellipsis = ""), "_comb_ideal")) %>% 
  pivot_longer(ends_with("_comb_ideal"), 
               names_to = "test", names_prefix = "facet", values_to = "score", values_drop_na = TRUE) %>% 
  group_nest(test) %>% 
  mutate(lmer_mods = map(data, ~lmerTest::lmer(score ~ time_d + (1 | pid), data = .x))) %>% 
  pull(lmer_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_manip_check_ideal_unlist <- as.data.frame(summary(df_manip_check_ideal[[1]])$coefficients) %>% as_tibble()
for (i in 2:length(df_manip_check_ideal)) {
  df_manip_check_ideal_unlist <- bind_rows(df_manip_check_ideal_unlist, 
                                          as.data.frame(summary(df_manip_check_ideal[[i]])$coefficients) %>% as_tibble())
}
```

```{r}
#| echo: true
#| warning: false

kable(df_manip_check_ideal_unlist %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=2), 
               term = c(rep(c("Intercept", "time"), 20))) %>% 
        rename(p = `Pr(>|t|)`, str_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, str_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars)))), # order by BFI traits, 
      digits = 3)
```

::: {.callout-note appearance="minimal"}
Significant changes over time in ideal personality trait levels (*time*) for extraversion and assertiveness (decrease). Stable otherwise.
:::

### Group 2 vs. Group 3: Effect of demand characteristics

Changes in current personality traits over time:
```{r}
#| echo: true
#| warning: false
#| code-fold: true
#| code-summary: "Show the code"
#| output: false
#| cache: true

df_manip_check_curr_23 <- df_sbsa3 %>% 
  filter(group!="Group 1") %>% 
  mutate(time_d = time - 1) %>% 
  select(pid, time_d, group, 
         paste0(str_trunc(names(b5_vars), 5, ellipsis = ""), "_comb_curr")) %>% 
  pivot_longer(ends_with("_comb_curr"), 
               names_to = "test", names_prefix = "facet", values_to = "score", values_drop_na = TRUE) %>% 
  mutate(group_2 = ifelse(group=="Group 2", 1, 0)) %>% 
  group_nest(test) %>% 
  mutate(lmer_mods = map(data, ~lmerTest::lmer(score ~ time_d * group_2 + (1 | pid), data = .x))) %>% 
  pull(lmer_mods) %>% 
  purrr::set_names(sort(names(b5_vars))) # ordered alphabetically

df_manip_check_curr_unlist_23 <- as.data.frame(summary(df_manip_check_curr_23[[1]])$coefficients) %>% as_tibble()
for (i in 2:length(df_manip_check_curr_23)) {
  df_manip_check_curr_unlist_23 <- bind_rows(df_manip_check_curr_unlist_23, 
                                          as.data.frame(summary(df_manip_check_curr_23[[i]])$coefficients) %>% as_tibble())
}
```

```{r}
#| echo: true
#| warning: false

kable(df_manip_check_curr_unlist_23 %>% 
        mutate(outcome = rep(sort(names(b5_vars)), each=4), 
               term = c(rep(c("Intercept", "time", "group_2", "time*group_2"), 20))) %>% 
        rename(p = `Pr(>|t|)`, str_err = `Std. Error`, est = Estimate) %>% select(outcome, term, est, str_err, p) %>% 
        mutate(sig = ifelse(p < .05, ifelse(p < .01, ifelse(p < .001, "***", "**"), "*"), " ")) %>% 
        arrange(factor(outcome, levels = (names(b5_vars)))), # order by BFI traits, 
      digits = 3)
```

::: {.callout-note appearance="minimal"}
One significant *group_2* effect: higher depression trait level in Group 2 at baseline compared to Group 3. Significant differences in the changes over time in current personality trait levels (*timeXgroup*) for extraversion, neuroticism, and depression (at *p* < .01). Significant changes over time in current personality trait levels (main effects of *time*) for productiveness (independent of group membership).
:::

Plot of main effects: productiveness
```{r}
#| echo: true
#| warning: false
#| fig-width: 7
#| fig-height: 5
#| code-fold: true
#| code-summary: "Show the code"

ggeffects::ggpredict(df_manip_check_curr_23$productiveness, 
                     terms = c("time_d[0,1]", "group_2[0,1]")) |> plot() +
  aes(linetype=group, color=group, shape=group) + geom_point() +
  theme_light() +
  scale_x_continuous(breaks = c(0,1), labels = c("T1", "T2")) +
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "Productiveness", x = "Time", y = "Predicted values of\nproductiveness",
       linetype="Group\n(0 = Group 3,\n1 = Group 2)", color="Group\n(0 = Group 3,\n1 = Group 2)", 
       shape="Group\n(0 = Group 3,\n1 = Group 2)")
``` 

Group interaction effects: extraversion, neuroticism, and depression  

```{r}
#| echo: true
#| warning: false
#| fig-width: 7
#| fig-height: 5
#| code-fold: true
#| code-summary: "Show the code"

ggeffects::ggpredict(df_manip_check_curr_23$extraversion, 
                     terms = c("time_d[0,1]", "group_2[0,1]")) |> plot() +
  aes(linetype=group, color=group, shape=group) + geom_point() +
  theme_light() +
  scale_x_continuous(breaks = c(0,1), labels = c("T1", "T2")) +
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "Extraversion", x = "Time", y = "Predicted values of\nextraversion",
       linetype="Group\n(0 = Group 3,\n1 = Group 2)", color="Group\n(0 = Group 3,\n1 = Group 2)", 
       shape="Group\n(0 = Group 3,\n1 = Group 2)")
``` 

```{r}
#| echo: true
#| warning: false
#| fig-width: 7
#| fig-height: 5
#| code-fold: true
#| code-summary: "Show the code"

ggeffects::ggpredict(df_manip_check_curr_23$neuroticism, 
                     terms = c("time_d[0,1]", "group_2[0,1]")) |> plot() +
  aes(linetype=group, color=group, shape=group) + geom_point() +
  theme_light() +
  scale_x_continuous(breaks = c(0,1), labels = c("T1", "T2")) +
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "Neuroticism", x = "Time", y = "Predicted values of\nneuroticism",
       linetype="Group\n(0 = Group 3,\n1 = Group 2)", color="Group\n(0 = Group 3,\n1 = Group 2)", 
       shape="Group\n(0 = Group 3,\n1 = Group 2)")
``` 

```{r}
#| echo: true
#| warning: false
#| fig-width: 7
#| fig-height: 5
#| code-fold: true
#| code-summary: "Show the code"

ggeffects::ggpredict(df_manip_check_curr_23$depression, 
                     terms = c("time_d[0,1]", "group_2[0,1]")) |> plot() +
  aes(linetype=group, color=group, shape=group) + geom_point() +
  theme_light() +
  scale_x_continuous(breaks = c(0,1), labels = c("T1", "T2")) +
  theme(panel.grid.minor.x = element_blank()) + 
  labs(title = "Depression", x = "Time", y = "Predicted values of\ndepression",
       linetype="Group\n(0 = Group 3,\n1 = Group 2)", color="Group\n(0 = Group 3,\n1 = Group 2)", 
       shape="Group\n(0 = Group 3,\n1 = Group 2)")
``` 

### Initial group differences at T1

#### Big Five personality traits

```{r}
#| echo: true
#| warning: false

df_sbsa3 <- df_sbsa3 %>% mutate(interv = ifelse(group=="Group 3", 0, 1))
# extra
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(extra_comb_curr), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(extra_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(extra_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# agree
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(agree_comb_curr), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(agree_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(agree_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# consc
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(consc_comb_curr), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(consc_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(consc_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# neuro
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(neuro_comb_curr), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(neuro_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(neuro_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# openn
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(openn_comb_curr), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(openn_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(openn_comb_curr ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)
```

#### Well-being

```{r}
#| echo: true
#| warning: false

# swls
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(swls), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(swls ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(swls ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# meaning
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(meaning), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(meaning ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(meaning ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# search for meaning
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(search), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(search ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(search ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# selfes
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(selfes), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(selfes ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(selfes ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)

# concept
psych::describeBy(df_sbsa3 %>% filter(time==1) %>% pull(concept), 
                  group = df_sbsa3 %>% filter(time==1) %>% pull(interv))
t.test(concept ~ interv, data = df_sbsa3 %>% filter(time==1), paired = F, conf.level = 0.99)
cohen.d(concept ~ interv, data = df_sbsa3 %>% filter(time==1), alpha=.01)
```

<!--
## References

::: {#refs}
:::
-->